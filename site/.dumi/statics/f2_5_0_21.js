(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.F2 = {}));
}(this, (function (exports) { 'use strict';

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * Rotates a mat2d by the given angle
   *
   * @param {mat2d} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat2d} out
   */

  function rotate(out, a, rad) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5];
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    out[0] = a0 * c + a2 * s;
    out[1] = a1 * c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
  }

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {ReadonlyMat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$1(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {ReadonlyMat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate$1(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {ReadonlyQuat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Alias for {@link mat4.perspectiveNO}
   * @function
   */

  var perspective = perspectiveNO;
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link mat4.orthoNO}
   * @function
   */

  var ortho = orthoNO;
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoZO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {ReadonlyMat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul = multiply;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub = subtract;

  var mat4 = /*#__PURE__*/Object.freeze({
      __proto__: null,
      create: create$1,
      clone: clone,
      copy: copy,
      fromValues: fromValues$1,
      set: set,
      identity: identity,
      transpose: transpose,
      invert: invert,
      adjoint: adjoint,
      determinant: determinant,
      multiply: multiply,
      translate: translate,
      scale: scale,
      rotate: rotate$1,
      rotateX: rotateX,
      rotateY: rotateY,
      rotateZ: rotateZ,
      fromTranslation: fromTranslation,
      fromScaling: fromScaling,
      fromRotation: fromRotation,
      fromXRotation: fromXRotation,
      fromYRotation: fromYRotation,
      fromZRotation: fromZRotation,
      fromRotationTranslation: fromRotationTranslation,
      fromQuat2: fromQuat2,
      getTranslation: getTranslation,
      getScaling: getScaling,
      getRotation: getRotation,
      fromRotationTranslationScale: fromRotationTranslationScale,
      fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
      fromQuat: fromQuat,
      frustum: frustum,
      perspectiveNO: perspectiveNO,
      perspective: perspective,
      perspectiveZO: perspectiveZO,
      perspectiveFromFieldOfView: perspectiveFromFieldOfView,
      orthoNO: orthoNO,
      ortho: ortho,
      orthoZO: orthoZO,
      lookAt: lookAt,
      targetTo: targetTo,
      str: str,
      frob: frob,
      add: add,
      subtract: subtract,
      multiplyScalar: multiplyScalar,
      multiplyScalarAndAdd: multiplyScalarAndAdd,
      exactEquals: exactEquals,
      equals: equals,
      mul: mul,
      sub: sub
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   *
   * @param {ReadonlyVec3} a vector to clone
   * @returns {vec3} a new 3D vector
   */

  function clone$1(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$2(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Copy the values from one vec3 to another
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the source vector
   * @returns {vec3} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$1(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Multiplies two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function multiply$1(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {vec3} out
   */

  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat3} m the 3x3 matrix to transform with
   * @returns {vec3} out
   */

  function transformMat3(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyQuat} q quaternion to transform with
   * @returns {vec3} out
   */

  function transformQuat(out, a, q) {
    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
    var qx = q[0],
        qy = q[1],
        qz = q[2],
        qw = q[3];
    var x = a[0],
        y = a[1],
        z = a[2]; // var qvec = [qx, qy, qz];
    // var uv = vec3.cross([], qvec, a);

    var uvx = qy * z - qz * y,
        uvy = qz * x - qx * z,
        uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

    var uuvx = qy * uvz - qz * uvy,
        uuvy = qz * uvx - qx * uvz,
        uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2; // vec3.scale(uuv, uuv, 2);

    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$3(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Copy the values from one vec4 to another
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the source vector
   * @returns {vec4} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$4() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   */

  function multiply$2(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Calculates the inverse of a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate inverse of
   * @returns {quat} out
   */

  function invert$1(out, a) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a2 * invDot;
    out[3] = a3 * invDot;
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues$4 = fromValues$3;
  /**
   * Copy the values from one quat to another
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the source quaternion
   * @returns {quat} out
   * @function
   */

  var copy$3 = copy$2;
  /**
   * Alias for {@link quat.multiply}
   * @function
   */

  var mul$1 = multiply$2;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$2();
    var xUnitVec3 = fromValues$2(1, 0, 0);
    var yUnitVec3 = fromValues$2(0, 1, 0);
    return function (out, a, b) {
      var dot$1 = dot(a, b);

      if (dot$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$1;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$4();
    var temp2 = create$4();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$5() {
    var out = new ARRAY_TYPE(2);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec2 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @returns {vec2} a new 2D vector
   */

  function fromValues$5(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  /**
   * Copy the values from one vec2 to another
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the source vector
   * @returns {vec2} out
   */

  function copy$4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  /**
   * Adds two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  /**
   * Returns the minimum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  /**
   * Returns the maximum of two vec2's
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {vec2} out
   */

  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  /**
   * Scales a vec2 by a scalar number
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec2} out
   */

  function scale$2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} distance between a and b
   */

  function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  /**
   * Calculates the length of a vec2
   *
   * @param {ReadonlyVec2} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length$1(a) {
    var x = a[0],
        y = a[1];
    return Math.hypot(x, y);
  }
  /**
   * Normalize a vec2
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a vector to normalize
   * @returns {vec2} out
   */

  function normalize$3(out, a) {
    var x = a[0],
        y = a[1];
    var len = x * x + y * y;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec2's
   *
   * @param {ReadonlyVec2} a the first operand
   * @param {ReadonlyVec2} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Transforms the vec2 with a mat2d
   *
   * @param {vec2} out the receiving vector
   * @param {ReadonlyVec2} a the vector to transform
   * @param {ReadonlyMat2d} m matrix to transform with
   * @returns {vec2} out
   */

  function transformMat2d(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  /**
   * Get the angle between two 2D vectors
   * @param {ReadonlyVec2} a The first operand
   * @param {ReadonlyVec2} b The second operand
   * @returns {Number} The angle in radians
   */

  function angle(a, b) {
    var x1 = a[0],
        y1 = a[1],
        x2 = b[0],
        y2 = b[1],
        // mag is the product of the magnitudes of a and b
    mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
        // mag &&.. short circuits if mag == 0
    cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  /**
   * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec2} a The first vector.
   * @param {ReadonlyVec2} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  /**
   * Alias for {@link vec2.subtract}
   * @function
   */

  var sub$1 = subtract$2;
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$5();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  function clonePath(path) {
      return path.map(function (x) { return (Array.isArray(x) ? [].concat(x) : x); });
  }

  /**
   * Rounds the values of a `PathArray` instance to
   * a specified amount of decimals and returns it.
   */
  function roundPath(path, round) {
      if (round === 'off')
          return clonePath(path);
      // to round values to the power
      // the `round` value must be integer
      var pow = typeof round === 'number' && round >= 1 ? Math.pow(10, round) : 1;
      return path.map(function (pi) {
          var values = pi
              .slice(1)
              .map(Number)
              .map(function (n) { return (round ? Math.round(n * pow) / pow : Math.round(n)); });
          // @ts-ignore
          return [pi[0]].concat(values);
      });
  }

  /**
   * Returns a valid `d` attribute string value created
   * by rounding values and concatenating the `pathArray` segments.
   */
  function path2String(path, round) {
      if (round === void 0) { round = 'off'; }
      return roundPath(path, round)
          .map(function (x) { return x[0] + x.slice(1).join(' '); })
          .join('');
  }

  var paramsParser = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      x: 0,
      y: 0,
      qx: null,
      qy: null,
  };

  function fixArc(pathArray, allPathCommands, i) {
      if (pathArray[i].length > 7) {
          pathArray[i].shift();
          var pi = pathArray[i];
          // const ni = i + 1;
          var ni = i;
          while (pi.length) {
              // if created multiple C:s, their original seg is saved
              allPathCommands[i] = 'A';
              // @ts-ignore
              pathArray.splice((ni += 1), 0, ['C'].concat(pi.splice(0, 6)));
          }
          pathArray.splice(i, 1);
      }
  }

  var paramsCount = {
      a: 7,
      c: 6,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      z: 0,
  };

  /**
   * Iterates an array to check if it's an actual `PathArray`.
   */
  function isPathArray(path) {
      return (Array.isArray(path) &&
          path.every(function (seg) {
              var lk = seg[0].toLowerCase();
              return paramsCount[lk] === seg.length - 1 && 'achlmqstvz'.includes(lk);
          }));
  }

  /**
   * Iterates an array to check if it's a `PathArray`
   * with all absolute values.
   */
  function isAbsoluteArray(path) {
      return (isPathArray(path) &&
          // @ts-ignore -- `isPathArray` also checks if it's `Array`
          path.every(function (_a) {
              var x = _a[0];
              return x === x.toUpperCase();
          }));
  }

  /**
   * Iterates an array to check if it's a `PathArray`
   * with all segments are in non-shorthand notation
   * with absolute values.
   */
  function isNormalizedArray(path) {
      return isAbsoluteArray(path) && path.every(function (_a) {
          var pc = _a[0];
          return 'ACLMQZ'.includes(pc);
      });
  }

  /**
   * Breaks the parsing of a pathString once a segment is finalized.
   */
  function finalizeSegment(path) {
      var pathCommand = path.pathValue[path.segmentStart];
      var LK = pathCommand.toLowerCase();
      var data = path.data;
      while (data.length >= paramsCount[LK]) {
          // overloaded `moveTo`
          // https://github.com/rveciana/svg-path-properties/blob/master/src/parse.ts
          if (LK === 'm' && data.length > 2) {
              // @ts-ignore
              path.segments.push([pathCommand].concat(data.splice(0, 2)));
              LK = 'l';
              pathCommand = pathCommand === 'm' ? 'l' : 'L';
          }
          else {
              // @ts-ignore
              path.segments.push([pathCommand].concat(data.splice(0, paramsCount[LK])));
          }
          if (!paramsCount[LK]) {
              break;
          }
      }
  }

  /**
   * Validates an A (arc-to) specific path command value.
   * Usually a `large-arc-flag` or `sweep-flag`.
   */
  function scanFlag(path) {
      var index = path.index, pathValue = path.pathValue;
      var code = pathValue.charCodeAt(index);
      if (code === 0x30 /* 0 */) {
          path.param = 0;
          path.index += 1;
          return;
      }
      if (code === 0x31 /* 1 */) {
          path.param = 1;
          path.index += 1;
          return;
      }
      path.err = "[path-util]: invalid Arc flag \"" + pathValue[index] + "\", expecting 0 or 1 at index " + index;
  }

  /**
   * Checks if the character is or belongs to a number.
   * [0-9]|+|-|.
   */
  function isDigitStart(code) {
      return ((code >= 48 && code <= 57) /* 0..9 */ || code === 0x2b /* + */ || code === 0x2d /* - */ || code === 0x2e); /* . */
  }
  function isDigit(code) {
      return code >= 48 && code <= 57; // 0..9
  }

  /**
   * Validates every character of the path string,
   * every path command, negative numbers or floating point numbers.
   */
  function scanParam(path) {
      var max = path.max, pathValue = path.pathValue, start = path.index;
      var index = start;
      var zeroFirst = false;
      var hasCeiling = false;
      var hasDecimal = false;
      var hasDot = false;
      var ch;
      if (index >= max) {
          // path.err = 'SvgPath: missed param (at pos ' + index + ')';
          path.err = "[path-util]: Invalid path value at index " + index + ", \"pathValue\" is missing param";
          return;
      }
      ch = pathValue.charCodeAt(index);
      if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
          index += 1;
          // ch = (index < max) ? pathValue.charCodeAt(index) : 0;
          ch = pathValue.charCodeAt(index);
      }
      // This logic is shamelessly borrowed from Esprima
      // https://github.com/ariya/esprimas
      if (!isDigit(ch) && ch !== 0x2e /* . */) {
          // path.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';
          path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" is not a number";
          return;
      }
      if (ch !== 0x2e /* . */) {
          zeroFirst = ch === 0x30 /* 0 */;
          index += 1;
          ch = pathValue.charCodeAt(index);
          if (zeroFirst && index < max) {
              // decimal number starts with '0' such as '09' is illegal.
              if (ch && isDigit(ch)) {
                  // path.err = 'SvgPath: numbers started with `0` such as `09`
                  // are illegal (at pos ' + start + ')';
                  path.err = "[path-util]: Invalid path value at index " + start + ", \"" + pathValue[start] + "\" illegal number";
                  return;
              }
          }
          while (index < max && isDigit(pathValue.charCodeAt(index))) {
              index += 1;
              hasCeiling = true;
          }
          ch = pathValue.charCodeAt(index);
      }
      if (ch === 0x2e /* . */) {
          hasDot = true;
          index += 1;
          while (isDigit(pathValue.charCodeAt(index))) {
              index += 1;
              hasDecimal = true;
          }
          ch = pathValue.charCodeAt(index);
      }
      if (ch === 0x65 /* e */ || ch === 0x45 /* E */) {
          if (hasDot && !hasCeiling && !hasDecimal) {
              path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" invalid float exponent";
              return;
          }
          index += 1;
          ch = pathValue.charCodeAt(index);
          if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
              index += 1;
          }
          if (index < max && isDigit(pathValue.charCodeAt(index))) {
              while (index < max && isDigit(pathValue.charCodeAt(index))) {
                  index += 1;
              }
          }
          else {
              path.err = "[path-util]: Invalid path value at index " + index + ", \"" + pathValue[index] + "\" invalid integer exponent";
              return;
          }
      }
      path.index = index;
      path.param = +path.pathValue.slice(start, index);
  }

  /**
   * Checks if the character is a space.
   */
  function isSpace(ch) {
      var specialSpaces = [
          0x1680, 0x180e, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200a, 0x202f,
          0x205f, 0x3000, 0xfeff,
      ];
      /* istanbul ignore next */
      return (ch === 0x0a ||
          ch === 0x0d ||
          ch === 0x2028 ||
          ch === 0x2029 || // Line terminators
          // White spaces
          ch === 0x20 ||
          ch === 0x09 ||
          ch === 0x0b ||
          ch === 0x0c ||
          ch === 0xa0 ||
          (ch >= 0x1680 && specialSpaces.includes(ch)));
  }

  /**
   * Points the parser to the next character in the
   * path string every time it encounters any kind of
   * space character.
   */
  function skipSpaces(path) {
      var pathValue = path.pathValue, max = path.max;
      while (path.index < max && isSpace(pathValue.charCodeAt(path.index))) {
          path.index += 1;
      }
  }

  /**
   * Checks if the character is a path command.
   */
  function isPathCommand(code) {
      // eslint-disable-next-line no-bitwise -- Impossible to satisfy
      switch (code | 0x20) {
          case 0x6d /* m */:
          case 0x7a /* z */:
          case 0x6c /* l */:
          case 0x68 /* h */:
          case 0x76 /* v */:
          case 0x63 /* c */:
          case 0x73 /* s */:
          case 0x71 /* q */:
          case 0x74 /* t */:
          case 0x61 /* a */:
              // case 0x72/* r */:
              return true;
          default:
              return false;
      }
  }

  /**
   * Checks if the character is an A (arc-to) path command.
   */
  function isArcCommand(code) {
      return (code | 0x20) === 0x61;
  }

  /**
   * Scans every character in the path string to determine
   * where a segment starts and where it ends.
   */
  function scanSegment(path) {
      var max = path.max, pathValue = path.pathValue, index = path.index;
      var cmdCode = pathValue.charCodeAt(index);
      var reqParams = paramsCount[pathValue[index].toLowerCase()];
      path.segmentStart = index;
      if (!isPathCommand(cmdCode)) {
          path.err = "[path-util]: Invalid path value \"" + pathValue[index] + "\" is not a path command";
          return;
      }
      path.index += 1;
      skipSpaces(path);
      path.data = [];
      if (!reqParams) {
          // Z
          finalizeSegment(path);
          return;
      }
      for (;;) {
          for (var i = reqParams; i > 0; i -= 1) {
              if (isArcCommand(cmdCode) && (i === 3 || i === 4))
                  scanFlag(path);
              else
                  scanParam(path);
              if (path.err.length) {
                  return;
              }
              path.data.push(path.param);
              skipSpaces(path);
              // after ',' param is mandatory
              if (path.index < max && pathValue.charCodeAt(path.index) === 0x2c /* , */) {
                  path.index += 1;
                  skipSpaces(path);
              }
          }
          if (path.index >= path.max) {
              break;
          }
          // Stop on next segment
          if (!isDigitStart(pathValue.charCodeAt(path.index))) {
              break;
          }
      }
      finalizeSegment(path);
  }

  /**
   * The `PathParser` is used by the `parsePathString` static method
   * to generate a `pathArray`.
   */
  var PathParser = /** @class */ (function () {
      function PathParser(pathString) {
          this.pathValue = pathString;
          // @ts-ignore
          this.segments = [];
          this.max = pathString.length;
          this.index = 0;
          this.param = 0.0;
          this.segmentStart = 0;
          this.data = [];
          this.err = '';
      }
      return PathParser;
  }());

  /**
   * Parses a path string value and returns an array
   * of segments we like to call `pathArray`.
   */
  function parsePathString(pathInput) {
      if (isPathArray(pathInput)) {
          return clonePath(pathInput);
      }
      var path = new PathParser(pathInput);
      skipSpaces(path);
      while (path.index < path.max && !path.err.length) {
          scanSegment(path);
      }
      return path.err ? path.err : path.segments;
  }

  function path2Absolute(pathInput) {
      if (isAbsoluteArray(pathInput)) {
          return clonePath(pathInput);
      }
      var path = parsePathString(pathInput);
      // if (!path || !path.length) {
      //   return [['M', 0, 0]];
      // }
      var x = 0;
      var y = 0;
      var mx = 0;
      var my = 0;
      // @ts-ignore
      return path.map(function (segment) {
          var values = segment.slice(1).map(Number);
          var pathCommand = segment[0];
          var absCommand = pathCommand.toUpperCase();
          if (pathCommand === 'M') {
              x = values[0], y = values[1];
              mx = x;
              my = y;
              return ['M', x, y];
          }
          var absoluteSegment;
          if (pathCommand !== absCommand) {
              switch (absCommand) {
                  case 'A':
                      absoluteSegment = [
                          absCommand,
                          values[0],
                          values[1],
                          values[2],
                          values[3],
                          values[4],
                          values[5] + x,
                          values[6] + y,
                      ];
                      break;
                  case 'V':
                      absoluteSegment = [absCommand, values[0] + y];
                      break;
                  case 'H':
                      absoluteSegment = [absCommand, values[0] + x];
                      break;
                  default: {
                      // use brakets for `eslint: no-case-declaration`
                      // https://stackoverflow.com/a/50753272/803358
                      var absValues = values.map(function (n, j) { return n + (j % 2 ? y : x); });
                      // for n, l, c, s, q, t
                      // @ts-ignore
                      absoluteSegment = [absCommand].concat(absValues);
                  }
              }
          }
          else {
              // @ts-ignore
              absoluteSegment = [absCommand].concat(values);
          }
          var segLength = absoluteSegment.length;
          switch (absCommand) {
              case 'Z':
                  x = mx;
                  y = my;
                  break;
              case 'H':
                  x = absoluteSegment[1];
                  break;
              case 'V':
                  y = absoluteSegment[1];
                  break;
              default:
                  x = absoluteSegment[segLength - 2];
                  y = absoluteSegment[segLength - 1];
                  if (absCommand === 'M') {
                      mx = x;
                      my = y;
                  }
          }
          return absoluteSegment;
      });
  }

  /**
   * Normalizes a single segment of a `PathArray` object.
   * eg. H/V -> L, T -> Q
   */
  function normalizeSegment(segment, params) {
      var pathCommand = segment[0];
      var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
      var values = segment.slice(1).map(Number);
      var result = segment;
      if (!'TQ'.includes(pathCommand)) {
          // optional but good to be cautious
          params.qx = null;
          params.qy = null;
      }
      if (pathCommand === 'H') {
          result = ['L', segment[1], py1];
      }
      else if (pathCommand === 'V') {
          result = ['L', px1, segment[1]];
      }
      else if (pathCommand === 'S') {
          var x1 = px1 * 2 - px2;
          var y1 = py1 * 2 - py2;
          params.x1 = x1;
          params.y1 = y1;
          result = ['C', x1, y1].concat(values);
      }
      else if (pathCommand === 'T') {
          var qx = px1 * 2 - params.qx;
          var qy = py1 * 2 - params.qy;
          params.qx = qx;
          params.qy = qy;
          result = ['Q', qx, qy].concat(values);
      }
      else if (pathCommand === 'Q') {
          var nqx = values[0], nqy = values[1];
          params.qx = nqx;
          params.qy = nqy;
      }
      return result;
  }

  /**
   * @example
   * const path = 'M0 0 H50';
   * const normalizedPath = SVGPathCommander.normalizePath(path);
   * // result => [['M', 0, 0], ['L', 50, 0]]
   */
  function normalizePath(pathInput) {
      if (isNormalizedArray(pathInput)) {
          return clonePath(pathInput);
      }
      var path = path2Absolute(pathInput);
      var params = __assign({}, paramsParser);
      for (var i = 0; i < path.length; i += 1) {
          // Save current path command
          path[i] = normalizeSegment(path[i], params);
          var segment = path[i];
          var seglen = segment.length;
          params.x1 = +segment[seglen - 2];
          params.y1 = +segment[seglen - 1];
          params.x2 = +segment[seglen - 4] || params.x1;
          params.y2 = +segment[seglen - 3] || params.y1;
      }
      return path;
  }

  /**
   * Iterates an array to check if it's a `PathArray`
   * with all C (cubic bezier) segments.
   *
   * @param {string | PathArray} path the `Array` to be checked
   * @returns {boolean} iteration result
   */
  function isCurveArray(path) {
      return isNormalizedArray(path) && path.every(function (_a) {
          var pc = _a[0];
          return 'MC'.includes(pc);
      });
  }

  function rotateVector(x, y, rad) {
      var X = x * Math.cos(rad) - y * Math.sin(rad);
      var Y = x * Math.sin(rad) + y * Math.cos(rad);
      return { x: X, y: Y };
  }

  /**
   * Converts A (arc-to) segments to C (cubic-bezier-to).
   *
   * For more information of where this math came from visit:
   * http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
   */
  function arcToCubic(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, recursive) {
      var x1 = X1;
      var y1 = Y1;
      var rx = RX;
      var ry = RY;
      var x2 = X2;
      var y2 = Y2;
      // for more information of where this Math came from visit:
      // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
      var d120 = (Math.PI * 120) / 180;
      var rad = (Math.PI / 180) * (+angle || 0);
      /** @type {number[]} */
      var res = [];
      var xy;
      var f1;
      var f2;
      var cx;
      var cy;
      if (!recursive) {
          xy = rotateVector(x1, y1, -rad);
          x1 = xy.x;
          y1 = xy.y;
          xy = rotateVector(x2, y2, -rad);
          x2 = xy.x;
          y2 = xy.y;
          var x = (x1 - x2) / 2;
          var y = (y1 - y2) / 2;
          var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
          if (h > 1) {
              h = Math.sqrt(h);
              rx *= h;
              ry *= h;
          }
          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (LAF === SF ? -1 : 1) *
              Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
          cx = (k * rx * y) / ry + (x1 + x2) / 2;
          cy = (k * -ry * x) / rx + (y1 + y2) / 2;
          // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise
          f1 = Math.asin(((((y1 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));
          // eslint-disable-next-line no-bitwise -- Impossible to satisfy no-bitwise
          f2 = Math.asin(((((y2 - cy) / ry) * Math.pow(10, 9)) >> 0) / Math.pow(10, 9));
          f1 = x1 < cx ? Math.PI - f1 : f1;
          f2 = x2 < cx ? Math.PI - f2 : f2;
          if (f1 < 0)
              f1 = Math.PI * 2 + f1;
          if (f2 < 0)
              f2 = Math.PI * 2 + f2;
          if (SF && f1 > f2) {
              f1 -= Math.PI * 2;
          }
          if (!SF && f2 > f1) {
              f2 -= Math.PI * 2;
          }
      }
      else {
          f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
      }
      var df = f2 - f1;
      if (Math.abs(df) > d120) {
          var f2old = f2;
          var x2old = x2;
          var y2old = y2;
          f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          res = arcToCubic(x2, y2, rx, ry, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
      }
      df = f2 - f1;
      var c1 = Math.cos(f1);
      var s1 = Math.sin(f1);
      var c2 = Math.cos(f2);
      var s2 = Math.sin(f2);
      var t = Math.tan(df / 4);
      var hx = (4 / 3) * rx * t;
      var hy = (4 / 3) * ry * t;
      var m1 = [x1, y1];
      var m2 = [x1 + hx * s1, y1 - hy * c1];
      var m3 = [x2 + hx * s2, y2 - hy * c2];
      var m4 = [x2, y2];
      m2[0] = 2 * m1[0] - m2[0];
      m2[1] = 2 * m1[1] - m2[1];
      if (recursive) {
          return m2.concat(m3, m4, res);
          // return [...m2, ...m3, ...m4, ...res];
      }
      res = m2.concat(m3, m4, res);
      // res = [...m2, ...m3, ...m4, ...res];
      var newres = [];
      for (var i = 0, ii = res.length; i < ii; i += 1) {
          newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;
      }
      return newres;
  }
  // const TAU = Math.PI * 2;
  // const mapToEllipse = (
  //   { x, y }: { x: number; y: number },
  //   rx: number,
  //   ry: number,
  //   cosphi: number,
  //   sinphi: number,
  //   centerx: number,
  //   centery: number,
  // ) => {
  //   x *= rx;
  //   y *= ry;
  //   const xp = cosphi * x - sinphi * y;
  //   const yp = sinphi * x + cosphi * y;
  //   return {
  //     x: xp + centerx,
  //     y: yp + centery,
  //   };
  // };
  // const approxUnitArc = (ang1: number, ang2: number) => {
  //   // If 90 degree circular arc, use a constant
  //   // as derived from http://spencermortensen.com/articles/bezier-circle
  //   const a =
  //     ang2 === 1.5707963267948966
  //       ? 0.551915024494
  //       : ang2 === -1.5707963267948966
  //       ? -0.551915024494
  //       : (4 / 3) * Math.tan(ang2 / 4);
  //   const x1 = Math.cos(ang1);
  //   const y1 = Math.sin(ang1);
  //   const x2 = Math.cos(ang1 + ang2);
  //   const y2 = Math.sin(ang1 + ang2);
  //   return [
  //     {
  //       x: x1 - y1 * a,
  //       y: y1 + x1 * a,
  //     },
  //     {
  //       x: x2 + y2 * a,
  //       y: y2 - x2 * a,
  //     },
  //     {
  //       x: x2,
  //       y: y2,
  //     },
  //   ];
  // };
  // const vectorAngle = (ux: number, uy: number, vx: number, vy: number) => {
  //   const sign = ux * vy - uy * vx < 0 ? -1 : 1;
  //   let dot = ux * vx + uy * vy;
  //   if (dot > 1) {
  //     dot = 1;
  //   }
  //   if (dot < -1) {
  //     dot = -1;
  //   }
  //   return sign * Math.acos(dot);
  // };
  // const getArcCenter = (
  //   px: any,
  //   py: any,
  //   cx: any,
  //   cy: any,
  //   rx: number,
  //   ry: number,
  //   largeArcFlag: number,
  //   sweepFlag: number,
  //   sinphi: number,
  //   cosphi: number,
  //   pxp: number,
  //   pyp: number,
  // ) => {
  //   const rxsq = Math.pow(rx, 2);
  //   const rysq = Math.pow(ry, 2);
  //   const pxpsq = Math.pow(pxp, 2);
  //   const pypsq = Math.pow(pyp, 2);
  //   let radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  //   if (radicant < 0) {
  //     radicant = 0;
  //   }
  //   radicant /= rxsq * pypsq + rysq * pxpsq;
  //   radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  //   const centerxp = ((radicant * rx) / ry) * pyp;
  //   const centeryp = ((radicant * -ry) / rx) * pxp;
  //   const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  //   const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  //   const vx1 = (pxp - centerxp) / rx;
  //   const vy1 = (pyp - centeryp) / ry;
  //   const vx2 = (-pxp - centerxp) / rx;
  //   const vy2 = (-pyp - centeryp) / ry;
  //   const ang1 = vectorAngle(1, 0, vx1, vy1);
  //   let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  //   if (sweepFlag === 0 && ang2 > 0) {
  //     ang2 -= TAU;
  //   }
  //   if (sweepFlag === 1 && ang2 < 0) {
  //     ang2 += TAU;
  //   }
  //   return [centerx, centery, ang1, ang2];
  // };
  // const arcToBezier = ({ px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0 }) => {
  //   const curves = [];
  //   if (rx === 0 || ry === 0) {
  //     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
  //   }
  //   const sinphi = Math.sin((xAxisRotation * TAU) / 360);
  //   const cosphi = Math.cos((xAxisRotation * TAU) / 360);
  //   const pxp = (cosphi * (px - cx)) / 2 + (sinphi * (py - cy)) / 2;
  //   const pyp = (-sinphi * (px - cx)) / 2 + (cosphi * (py - cy)) / 2;
  //   if (pxp === 0 && pyp === 0) {
  //     return [{ x1: 0, y1: 0, x2: 0, y2: 0, x: cx, y: cy }];
  //   }
  //   rx = Math.abs(rx);
  //   ry = Math.abs(ry);
  //   const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  //   if (lambda > 1) {
  //     rx *= Math.sqrt(lambda);
  //     ry *= Math.sqrt(lambda);
  //   }
  //   let [centerx, centery, ang1, ang2] = getArcCenter(
  //     px,
  //     py,
  //     cx,
  //     cy,
  //     rx,
  //     ry,
  //     largeArcFlag,
  //     sweepFlag,
  //     sinphi,
  //     cosphi,
  //     pxp,
  //     pyp,
  //   );
  //   // If 'ang2' == 90.0000000001, then `ratio` will evaluate to
  //   // 1.0000000001. This causes `segments` to be greater than one, which is an
  //   // unecessary split, and adds extra points to the bezier curve. To alleviate
  //   // this issue, we round to 1.0 when the ratio is close to 1.0.
  //   let ratio = Math.abs(ang2) / (TAU / 4);
  //   if (Math.abs(1.0 - ratio) < 0.0000001) {
  //     ratio = 1.0;
  //   }
  //   const segments = Math.max(Math.ceil(ratio), 1);
  //   ang2 /= segments;
  //   for (let i = 0; i < segments; i++) {
  //     curves.push(approxUnitArc(ang1, ang2));
  //     ang1 += ang2;
  //   }
  //   return curves.map((curve) => {
  //     const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery);
  //     const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery);
  //     const { x, y } = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery);
  //     return { x1, y1, x2, y2, x, y };
  //   });
  // };
  // export function arcToCubic(
  //   x1: number,
  //   y1: number,
  //   rx: number,
  //   ry: number,
  //   angle: number,
  //   LAF: number,
  //   SF: number,
  //   x2: number,
  //   y2: number,
  // ) {
  //   const curves = arcToBezier({
  //     px: x1,
  //     py: y1,
  //     cx: x2,
  //     cy: y2,
  //     rx,
  //     ry,
  //     xAxisRotation: angle,
  //     largeArcFlag: LAF,
  //     sweepFlag: SF,
  //   });
  //   return curves.reduce((prev, cur) => {
  //     const { x1, y1, x2, y2, x, y } = cur;
  //     prev.push(x1, y1, x2, y2, x, y);
  //     return prev;
  //   }, [] as number[]);
  // }

  function quadToCubic(x1, y1, qx, qy, x2, y2) {
      var r13 = 1 / 3;
      var r23 = 2 / 3;
      return [
          r13 * x1 + r23 * qx,
          r13 * y1 + r23 * qy,
          r13 * x2 + r23 * qx,
          r13 * y2 + r23 * qy,
          x2,
          y2, // x,y
      ];
  }

  function midPoint(a, b, t) {
      var ax = a[0];
      var ay = a[1];
      var bx = b[0];
      var by = b[1];
      return [ax + (bx - ax) * t, ay + (by - ay) * t];
  }

  function distanceSquareRoot(a, b) {
      return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));
  }

  /**
   * Returns a {x,y} point at a given length, the total length and
   * the minimum and maximum {x,y} coordinates of a line (L,V,H,Z) segment.
   */
  function segmentLineFactory(x1, y1, x2, y2, distance) {
      var length = distanceSquareRoot([x1, y1], [x2, y2]);
      var point = { x: 0, y: 0 };
      if (typeof distance === 'number') {
          if (distance <= 0) {
              point = { x: x1, y: y1 };
          }
          else if (distance >= length) {
              point = { x: x2, y: y2 };
          }
          else {
              var _a = midPoint([x1, y1], [x2, y2], distance / length), x = _a[0], y = _a[1];
              point = { x: x, y: y };
          }
      }
      return {
          length: length,
          point: point,
          min: {
              x: Math.min(x1, x2),
              y: Math.min(y1, y2),
          },
          max: {
              x: Math.max(x1, x2),
              y: Math.max(y1, y2),
          },
      };
  }

  function lineToCubic(x1, y1, x2, y2) {
      var t = 0.5;
      var p0 = [x1, y1];
      var p1 = [x2, y2];
      var p2 = midPoint(p0, p1, t);
      var p3 = midPoint(p1, p2, t);
      var p4 = midPoint(p2, p3, t);
      var p5 = midPoint(p3, p4, t);
      var p6 = midPoint(p4, p5, t);
      // const seg1 = [...p0, ...p2, ...p4, ...p6, t];
      // @ts-ignore
      var cp1 = segmentLineFactory(p0[0], p0[1], p2[0], p2[1], p4[0]).point;
      // const seg2 = [...p6, ...p5, ...p3, ...p1, 0];
      // @ts-ignore
      var cp2 = segmentLineFactory(p6[0], p6[1], p5[0], p5[1], p3[0]).point;
      return [cp1.x, cp1.y, cp2.x, cp2.y, x2, y2];
  }

  function segmentToCubic(segment, params) {
      var pathCommand = segment[0];
      var values = segment.slice(1).map(Number);
      var x = values[0], y = values[1];
      var args;
      var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
      if (!'TQ'.includes(pathCommand)) {
          params.qx = null;
          params.qy = null;
      }
      switch (pathCommand) {
          case 'M':
              params.x = x;
              params.y = y;
              return segment;
          case 'A':
              args = [px1, py1].concat(values);
              // @ts-ignore
              return ['C'].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
          case 'Q':
              params.qx = x;
              params.qy = y;
              args = [px1, py1].concat(values);
              // @ts-ignore
              return ['C'].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
          case 'L':
              // @ts-ignore
              return ['C'].concat(lineToCubic(px1, py1, x, y));
          case 'Z':
              // prevent NaN from divide 0
              if (px1 === px && py1 === py) {
                  return ['C', px1, py1, px, py, px, py];
              }
              // @ts-ignore
              return ['C'].concat(lineToCubic(px1, py1, px, py));
      }
      return segment;
  }

  // import { fixPath } from '../process/fix-path';
  function path2Curve(pathInput, needZCommandIndexes) {
      if (needZCommandIndexes === void 0) { needZCommandIndexes = false; }
      if (isCurveArray(pathInput)) {
          var cloned = clonePath(pathInput);
          if (needZCommandIndexes) {
              return [cloned, []];
          }
          else {
              return cloned;
          }
      }
      // fixPath will remove 'Z' command
      // const path = fixPath(normalizePath(pathInput));
      var path = normalizePath(pathInput);
      var params = __assign({}, paramsParser);
      var allPathCommands = [];
      var pathCommand = '';
      var ii = path.length;
      var segment;
      var seglen;
      var zCommandIndexes = [];
      for (var i = 0; i < ii; i += 1) {
          if (path[i])
              pathCommand = path[i][0];
          allPathCommands[i] = pathCommand;
          var curveSegment = segmentToCubic(path[i], params);
          path[i] = curveSegment;
          fixArc(path, allPathCommands, i);
          ii = path.length; // solves curveArrays ending in Z
          // keep Z command account for lineJoin
          // @see https://github.com/antvis/util/issues/68
          if (pathCommand === 'Z') {
              zCommandIndexes.push(i);
          }
          segment = path[i];
          seglen = segment.length;
          params.x1 = +segment[seglen - 2];
          params.y1 = +segment[seglen - 1];
          params.x2 = +segment[seglen - 4] || params.x1;
          params.y2 = +segment[seglen - 3] || params.y1;
      }
      // validate
      if (needZCommandIndexes) {
          return [path, zCommandIndexes];
      }
      else {
          return path;
      }
  }

  // reverse CURVE based pathArray segments only
  function reverseCurve(pathArray) {
      var rotatedCurve = pathArray
          .slice(1)
          .map(function (x, i, curveOnly) {
          // @ts-ignore
          return !i ? pathArray[0].slice(1).concat(x.slice(1)) : curveOnly[i - 1].slice(-2).concat(x.slice(1));
      })
          // @ts-ignore
          .map(function (x) { return x.map(function (y, i) { return x[x.length - i - 2 * (1 - (i % 2))]; }); })
          .reverse();
      return [['M'].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function (x) { return ['C'].concat(x.slice(2)); }));
  }

  function angleBetween(v0, v1) {
      var v0x = v0.x, v0y = v0.y;
      var v1x = v1.x, v1y = v1.y;
      var p = v0x * v1x + v0y * v1y;
      var n = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
      var sign = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
      var angle = sign * Math.acos(p / n);
      return angle;
  }
  /**
   * Returns a {x,y} point at a given length, the total length and
   * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.
   * @see https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js
   */
  function getPointAtArcSegmentLength(x1, y1, RX, RY, angle, LAF, SF, x, y, t) {
      var abs = Math.abs, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, PI = Math.PI;
      var rx = abs(RX);
      var ry = abs(RY);
      var xRot = ((angle % 360) + 360) % 360;
      var xRotRad = xRot * (PI / 180);
      if (x1 === x && y1 === y) {
          return { x: x1, y: y1 };
      }
      if (rx === 0 || ry === 0) {
          return segmentLineFactory(x1, y1, x, y, t).point;
      }
      var dx = (x1 - x) / 2;
      var dy = (y1 - y) / 2;
      var transformedPoint = {
          x: cos(xRotRad) * dx + sin(xRotRad) * dy,
          y: -sin(xRotRad) * dx + cos(xRotRad) * dy,
      };
      var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
      if (radiiCheck > 1) {
          rx *= sqrt(radiiCheck);
          ry *= sqrt(radiiCheck);
      }
      var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
      var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
      var cRadicand = cSquareNumerator / cSquareRootDenom;
      cRadicand = cRadicand < 0 ? 0 : cRadicand;
      var cCoef = (LAF !== SF ? 1 : -1) * sqrt(cRadicand);
      var transformedCenter = {
          x: cCoef * ((rx * transformedPoint.y) / ry),
          y: cCoef * (-(ry * transformedPoint.x) / rx),
      };
      var center = {
          x: cos(xRotRad) * transformedCenter.x - sin(xRotRad) * transformedCenter.y + (x1 + x) / 2,
          y: sin(xRotRad) * transformedCenter.x + cos(xRotRad) * transformedCenter.y + (y1 + y) / 2,
      };
      var startVector = {
          x: (transformedPoint.x - transformedCenter.x) / rx,
          y: (transformedPoint.y - transformedCenter.y) / ry,
      };
      var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
      var endVector = {
          x: (-transformedPoint.x - transformedCenter.x) / rx,
          y: (-transformedPoint.y - transformedCenter.y) / ry,
      };
      var sweepAngle = angleBetween(startVector, endVector);
      if (!SF && sweepAngle > 0) {
          sweepAngle -= 2 * PI;
      }
      else if (SF && sweepAngle < 0) {
          sweepAngle += 2 * PI;
      }
      sweepAngle %= 2 * PI;
      var alpha = startAngle + sweepAngle * t;
      var ellipseComponentX = rx * cos(alpha);
      var ellipseComponentY = ry * sin(alpha);
      var point = {
          x: cos(xRotRad) * ellipseComponentX - sin(xRotRad) * ellipseComponentY + center.x,
          y: sin(xRotRad) * ellipseComponentX + cos(xRotRad) * ellipseComponentY + center.y,
      };
      // to be used later
      // point.ellipticalArcStartAngle = startAngle;
      // point.ellipticalArcEndAngle = startAngle + sweepAngle;
      // point.ellipticalArcAngle = alpha;
      // point.ellipticalArcCenter = center;
      // point.resultantRx = rx;
      // point.resultantRy = ry;
      return point;
  }
  /**
   * Returns a {x,y} point at a given length, the total length and
   * the shape minimum and maximum {x,y} coordinates of an A (arc-to) segment.
   *
   * For better performance, it can skip calculate bbox or length in some scenario.
   */
  function segmentArcFactory(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, distance, options) {
      var _a;
      var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
      var distanceIsNumber = typeof distance === 'number';
      var x = X1;
      var y = Y1;
      var LENGTH = 0;
      var prev = [x, y, LENGTH];
      var cur = [x, y];
      var t = 0;
      var POINT = { x: 0, y: 0 };
      var POINTS = [{ x: x, y: y }];
      if (distanceIsNumber && distance <= 0) {
          POINT = { x: x, y: y };
      }
      // bad perf when size > 100
      for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          (_a = getPointAtArcSegmentLength(X1, Y1, RX, RY, angle, LAF, SF, X2, Y2, t), x = _a.x, y = _a.y);
          if (bbox) {
              POINTS.push({ x: x, y: y });
          }
          if (length) {
              LENGTH += distanceSquareRoot(cur, [x, y]);
          }
          cur = [x, y];
          if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
              var dv = (LENGTH - distance) / (LENGTH - prev[2]);
              POINT = {
                  x: cur[0] * (1 - dv) + prev[0] * dv,
                  y: cur[1] * (1 - dv) + prev[1] * dv,
              };
          }
          prev = [x, y, LENGTH];
      }
      if (distanceIsNumber && distance >= LENGTH) {
          POINT = { x: X2, y: Y2 };
      }
      return {
          length: LENGTH,
          point: POINT,
          min: {
              x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
          },
          max: {
              x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
          },
      };
  }

  /**
   * Returns a {x,y} point at a given length, the total length and
   * the minimum and maximum {x,y} coordinates of a C (cubic-bezier) segment.
   */
  function getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t) {
      var t1 = 1 - t;
      return {
          x: Math.pow(t1, 3) * x1 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x2,
          y: Math.pow(t1, 3) * y1 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y2,
      };
  }
  /**
   * Returns the length of a C (cubic-bezier) segment
   * or an {x,y} point at a given length.
   */
  function segmentCubicFactory(x1, y1, c1x, c1y, c2x, c2y, x2, y2, distance, options) {
      var _a;
      var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
      var distanceIsNumber = typeof distance === 'number';
      var x = x1;
      var y = y1;
      var LENGTH = 0;
      var prev = [x, y, LENGTH];
      var cur = [x, y];
      var t = 0;
      var POINT = { x: 0, y: 0 };
      var POINTS = [{ x: x, y: y }];
      if (distanceIsNumber && distance <= 0) {
          POINT = { x: x, y: y };
      }
      // bad perf when size = 300
      for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          (_a = getPointAtCubicSegmentLength(x1, y1, c1x, c1y, c2x, c2y, x2, y2, t), x = _a.x, y = _a.y);
          if (bbox) {
              POINTS.push({ x: x, y: y });
          }
          if (length) {
              LENGTH += distanceSquareRoot(cur, [x, y]);
          }
          cur = [x, y];
          if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
              var dv = (LENGTH - distance) / (LENGTH - prev[2]);
              POINT = {
                  x: cur[0] * (1 - dv) + prev[0] * dv,
                  y: cur[1] * (1 - dv) + prev[1] * dv,
              };
          }
          prev = [x, y, LENGTH];
      }
      if (distanceIsNumber && distance >= LENGTH) {
          POINT = { x: x2, y: y2 };
      }
      return {
          length: LENGTH,
          point: POINT,
          min: {
              x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
          },
          max: {
              x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
          },
      };
  }

  /**
   * Returns the {x,y} coordinates of a point at a
   * given length of a quadratic-bezier segment.
   *
   * @see https://github.com/substack/point-at-length
   */
  function getPointAtQuadSegmentLength(x1, y1, cx, cy, x2, y2, t) {
      var t1 = 1 - t;
      return {
          x: Math.pow(t1, 2) * x1 + 2 * t1 * t * cx + Math.pow(t, 2) * x2,
          y: Math.pow(t1, 2) * y1 + 2 * t1 * t * cy + Math.pow(t, 2) * y2,
      };
  }
  /**
   * Returns a {x,y} point at a given length, the total length and
   * the minimum and maximum {x,y} coordinates of a Q (quadratic-bezier) segment.
   */
  function segmentQuadFactory(x1, y1, qx, qy, x2, y2, distance, options) {
      var _a;
      var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
      var distanceIsNumber = typeof distance === 'number';
      var x = x1;
      var y = y1;
      var LENGTH = 0;
      var prev = [x, y, LENGTH];
      var cur = [x, y];
      var t = 0;
      var POINT = { x: 0, y: 0 };
      var POINTS = [{ x: x, y: y }];
      if (distanceIsNumber && distance <= 0) {
          POINT = { x: x, y: y };
      }
      for (var j = 0; j <= sampleSize; j += 1) {
          t = j / sampleSize;
          (_a = getPointAtQuadSegmentLength(x1, y1, qx, qy, x2, y2, t), x = _a.x, y = _a.y);
          if (bbox) {
              POINTS.push({ x: x, y: y });
          }
          if (length) {
              LENGTH += distanceSquareRoot(cur, [x, y]);
          }
          cur = [x, y];
          if (distanceIsNumber && LENGTH >= distance && distance > prev[2]) {
              var dv = (LENGTH - distance) / (LENGTH - prev[2]);
              POINT = {
                  x: cur[0] * (1 - dv) + prev[0] * dv,
                  y: cur[1] * (1 - dv) + prev[1] * dv,
              };
          }
          prev = [x, y, LENGTH];
      }
      /* istanbul ignore else */
      if (distanceIsNumber && distance >= LENGTH) {
          POINT = { x: x2, y: y2 };
      }
      return {
          length: LENGTH,
          point: POINT,
          min: {
              x: Math.min.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.min.apply(null, POINTS.map(function (n) { return n.y; })),
          },
          max: {
              x: Math.max.apply(null, POINTS.map(function (n) { return n.x; })),
              y: Math.max.apply(null, POINTS.map(function (n) { return n.y; })),
          },
      };
  }

  /**
   * Returns a {x,y} point at a given length
   * of a shape, the shape total length and
   * the shape minimum and maximum {x,y} coordinates.
   */
  function pathLengthFactory(pathInput, distance, options) {
      var _a, _b, _c, _d, _e, _f;
      var path = normalizePath(pathInput);
      var distanceIsNumber = typeof distance === 'number';
      var isM;
      var data = [];
      var pathCommand;
      var x = 0;
      var y = 0;
      var mx = 0;
      var my = 0;
      var seg;
      var MIN = [];
      var MAX = [];
      var length = 0;
      var min = { x: 0, y: 0 };
      var max = min;
      var point = min;
      var POINT = min;
      var LENGTH = 0;
      for (var i = 0, ll = path.length; i < ll; i += 1) {
          seg = path[i];
          pathCommand = seg[0];
          isM = pathCommand === 'M';
          data = !isM ? [x, y].concat(seg.slice(1)) : data;
          // this segment is always ZERO
          /* istanbul ignore else */
          if (isM) {
              // remember mx, my for Z
              mx = seg[1], my = seg[2];
              min = { x: mx, y: my };
              max = min;
              length = 0;
              if (distanceIsNumber && distance < 0.001) {
                  POINT = min;
              }
          }
          else if (pathCommand === 'L') {
              (_a = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _a.length, min = _a.min, max = _a.max, point = _a.point);
          }
          else if (pathCommand === 'A') {
              (_b = segmentArcFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], (distance || 0) - LENGTH, options || {}), length = _b.length, min = _b.min, max = _b.max, point = _b.point);
          }
          else if (pathCommand === 'C') {
              (_c = segmentCubicFactory(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], (distance || 0) - LENGTH, options || {}), length = _c.length, min = _c.min, max = _c.max, point = _c.point);
          }
          else if (pathCommand === 'Q') {
              (_d = segmentQuadFactory(data[0], data[1], data[2], data[3], data[4], data[5], (distance || 0) - LENGTH, options || {}), length = _d.length, min = _d.min, max = _d.max, point = _d.point);
          }
          else if (pathCommand === 'Z') {
              data = [x, y, mx, my];
              (_e = segmentLineFactory(data[0], data[1], data[2], data[3], (distance || 0) - LENGTH), length = _e.length, min = _e.min, max = _e.max, point = _e.point);
          }
          if (distanceIsNumber && LENGTH < distance && LENGTH + length >= distance) {
              POINT = point;
          }
          MAX.push(max);
          MIN.push(min);
          LENGTH += length;
          _f = pathCommand !== 'Z' ? seg.slice(-2) : [mx, my], x = _f[0], y = _f[1];
      }
      // native `getPointAtLength` behavior when the given distance
      // is higher than total length
      if (distanceIsNumber && distance >= LENGTH) {
          POINT = { x: x, y: y };
      }
      return {
          length: LENGTH,
          point: POINT,
          min: {
              x: Math.min.apply(null, MIN.map(function (n) { return n.x; })),
              y: Math.min.apply(null, MIN.map(function (n) { return n.y; })),
          },
          max: {
              x: Math.max.apply(null, MAX.map(function (n) { return n.x; })),
              y: Math.max.apply(null, MAX.map(function (n) { return n.y; })),
          },
      };
  }

  /**
   * Returns the shape total length, or the equivalent to `shape.getTotalLength()`.
   *
   * The `normalizePath` version is lighter, faster, more efficient and more accurate
   * with paths that are not `curveArray`.
   */
  function getTotalLength(pathInput, options) {
      return pathLengthFactory(pathInput, undefined, __assign(__assign({}, options), { bbox: false, length: true })).length;
  }

  function getRotations(a) {
      var segCount = a.length;
      var pointCount = segCount - 1;
      return a.map(function (f, idx) {
          return a.map(function (p, i) {
              var oldSegIdx = idx + i;
              var seg;
              if (i === 0 || (a[oldSegIdx] && a[oldSegIdx][0] === 'M')) {
                  seg = a[oldSegIdx];
                  return ['M'].concat(seg.slice(-2));
              }
              if (oldSegIdx >= segCount)
                  oldSegIdx -= pointCount;
              return a[oldSegIdx];
          });
      });
  }
  function getRotatedCurve(a, b) {
      var segCount = a.length - 1;
      var lineLengths = [];
      var computedIndex = 0;
      var sumLensSqrd = 0;
      var rotations = getRotations(a);
      rotations.forEach(function (r, i) {
          a.slice(1).forEach(function (s, j) {
              // @ts-ignore
              sumLensSqrd += distanceSquareRoot(a[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
          });
          lineLengths[i] = sumLensSqrd;
          sumLensSqrd = 0;
      });
      computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
      return rotations[computedIndex];
  }

  /**
   * Returns the area of a single cubic-bezier segment.
   *
   * http://objectmix.com/graphics/133553-area-closed-bezier-curve.html
   */
  function getCubicSegArea(x1, y1, c1x, c1y, c2x, c2y, x2, y2) {
      // https://stackoverflow.com/a/15845996
      return ((3 *
          ((y2 - y1) * (c1x + c2x) -
              (x2 - x1) * (c1y + c2y) +
              c1y * (x1 - c2x) -
              c1x * (y1 - c2y) +
              y2 * (c2x + x1 / 3) -
              x2 * (c2y + y1 / 3))) /
          20);
  }
  /**
   * Returns the area of a shape.
   * @author Jrg Lehni & Jonathan Puckey
   *
   * @see https://github.com/paperjs/paper.js/blob/develop/src/path/Path.js
   */
  function getPathArea(path) {
      var x = 0;
      var y = 0;
      var len = 0;
      return path2Curve(path)
          .map(function (seg) {
          var _a;
          switch (seg[0]) {
              case 'M':
                  x = seg[1], y = seg[2];
                  return 0;
              default:
                  // @ts-ignore
                  var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x2 = _b[4], y2 = _b[5];
                  len = getCubicSegArea(x, y, c1x, c1y, c2x, c2y, x2, y2);
                  _a = seg.slice(-2), x = _a[0], y = _a[1];
                  return len;
          }
      })
          .reduce(function (a, b) { return a + b; }, 0);
  }
  // export function getPathArea(pathArray: AbsoluteArray) {
  //   let x = 0;
  //   let y = 0;
  //   let mx = 0;
  //   let my = 0;
  //   let len = 0;
  //   return pathArray
  //     .map((seg) => {
  //       switch (seg[0]) {
  //         case 'M':
  //         case 'Z':
  //           mx = seg[0] === 'M' ? seg[1] : mx;
  //           my = seg[0] === 'M' ? seg[2] : my;
  //           x = mx;
  //           y = my;
  //           return 0;
  //         default:
  //           // @ts-ignore
  //           len = getCubicSegArea.apply(0, [x, y].concat(seg.slice(1)));
  //           [x, y] = seg.slice(-2) as [number, number];
  //           return len;
  //       }
  //     })
  //     .reduce((a, b) => a + b, 0);
  // }

  function getDrawDirection(pathArray) {
      return getPathArea(pathArray) >= 0;
  }

  /**
   * Returns [x,y] coordinates of a point at a given length of a shape.
   */
  function getPointAtLength(pathInput, distance, options) {
      return pathLengthFactory(pathInput, distance, __assign(__assign({}, options), { bbox: false, length: true })).point;
  }

  function splitCubic(pts, t) {
      if (t === void 0) { t = 0.5; }
      var p0 = pts.slice(0, 2);
      var p1 = pts.slice(2, 4);
      var p2 = pts.slice(4, 6);
      var p3 = pts.slice(6, 8);
      var p4 = midPoint(p0, p1, t);
      var p5 = midPoint(p1, p2, t);
      var p6 = midPoint(p2, p3, t);
      var p7 = midPoint(p4, p5, t);
      var p8 = midPoint(p5, p6, t);
      var p9 = midPoint(p7, p8, t);
      return [
          // @ts-ignore
          ['C'].concat(p4, p7, p9),
          // @ts-ignore
          ['C'].concat(p8, p6, p3),
      ];
  }
  function getCurveArray(segments) {
      return segments.map(function (segment, i, pathArray) {
          // @ts-ignore
          var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
          // @ts-ignore
          var curveLength = i
              ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length
              : 0;
          var subsegs;
          if (i) {
              // must be [segment,segment]
              subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
          }
          else {
              subsegs = [segment];
          }
          return {
              s: segment,
              ss: subsegs,
              l: curveLength,
          };
      });
  }
  function equalizeSegments(path1, path2, TL) {
      var c1 = getCurveArray(path1);
      var c2 = getCurveArray(path2);
      var L1 = c1.length;
      var L2 = c2.length;
      var l1 = c1.filter(function (x) { return x.l; }).length;
      var l2 = c2.filter(function (x) { return x.l; }).length;
      var m1 = c1.filter(function (x) { return x.l; }).reduce(function (a, _a) {
          var l = _a.l;
          return a + l;
      }, 0) / l1 || 0;
      var m2 = c2.filter(function (x) { return x.l; }).reduce(function (a, _a) {
          var l = _a.l;
          return a + l;
      }, 0) / l2 || 0;
      var tl = TL || Math.max(L1, L2);
      var mm = [m1, m2];
      var dif = [tl - L1, tl - L2];
      var canSplit = 0;
      var result = [c1, c2].map(function (x, i) {
          // @ts-ignore
          return x.l === tl
              ? x.map(function (y) { return y.s; })
              : x
                  .map(function (y, j) {
                  canSplit = j && dif[i] && y.l >= mm[i];
                  dif[i] -= canSplit ? 1 : 0;
                  return canSplit ? y.ss : [y.s];
              })
                  .flat();
      });
      return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
  }

  var isArrayLike = function (value) {
      /**
       * isArrayLike([1, 2, 3]) => true
       * isArrayLike(document.body.children) => true
       * isArrayLike('abc') => true
       * isArrayLike(Function) => false
       */
      return value !== null && typeof value !== 'function' && isFinite(value.length);
  };

  var filter = function (arr, func) {
      if (!isArrayLike(arr)) {
          return arr;
      }
      var result = [];
      for (var index = 0; index < arr.length; index++) {
          var value = arr[index];
          if (func(value, index)) {
              result.push(value);
          }
      }
      return result;
  };

  /**
   * @see https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_isfunction
   */
  var isFunction = (function (value) {
      return typeof value === 'function';
  });

  // isFinite,
  var isNil = function (value) {
      /**
       * isNil(null) => true
       * isNil() => true
       */
      return value === null || value === undefined;
  };

  var toString = {}.toString;
  var isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };

  var isArray = (function (value) {
      return Array.isArray ? Array.isArray(value) : isType(value, 'Array');
  });

  var isObject = (function (value) {
      /**
       * isObject({}) => true
       * isObject([1, 2, 3]) => true
       * isObject(Function) => true
       * isObject(null) => false
       */
      var type = typeof value;
      return (value !== null && type === 'object') || type === 'function';
  });

  function each(elements, func) {
      if (!elements) {
          return;
      }
      var rst;
      if (isArray(elements)) {
          for (var i = 0, len = elements.length; i < len; i++) {
              rst = func(elements[i], i);
              if (rst === false) {
                  break;
              }
          }
      }
      else if (isObject(elements)) {
          for (var k in elements) {
              if (elements.hasOwnProperty(k)) {
                  rst = func(elements[k], k);
                  if (rst === false) {
                      break;
                  }
              }
          }
      }
  }

  var keys = Object.keys
      ? function (obj) { return Object.keys(obj); }
      : function (obj) {
          var result = [];
          each(obj, function (value, key) {
              if (!(isFunction(obj) && key === 'prototype')) {
                  result.push(key);
              }
          });
          return result;
      };

  function isMatch(obj, attrs) {
      var _keys = keys(attrs);
      var length = _keys.length;
      if (isNil(obj))
          return !length;
      for (var i = 0; i < length; i += 1) {
          var key = _keys[i];
          if (attrs[key] !== obj[key] || !(key in obj)) {
              return false;
          }
      }
      return true;
  }

  var isObjectLike = function (value) {
      /**
       * isObjectLike({}) => true
       * isObjectLike([1, 2, 3]) => true
       * isObjectLike(Function) => false
       * isObjectLike(null) => false
       */
      return typeof value === 'object' && value !== null;
  };

  var isPlainObject = function (value) {
      /**
       * isObjectLike(new Foo) => false
       * isObjectLike([1, 2, 3]) => false
       * isObjectLike({ x: 0, y: 0 }) => true
       * isObjectLike(Object.create(null)) => true
       */
      if (!isObjectLike(value) || !isType(value, 'Object')) {
          return false;
      }
      if (Object.getPrototypeOf(value) === null) {
          return true;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
  };

  function find(arr, predicate) {
      if (!isArray(arr))
          return null;
      var _predicate;
      if (isFunction(predicate)) {
          _predicate = predicate;
      }
      if (isPlainObject(predicate)) {
          _predicate = function (a) { return isMatch(a, predicate); };
      }
      if (_predicate) {
          for (var i = 0; i < arr.length; i += 1) {
              if (_predicate(arr[i])) {
                  return arr[i];
              }
          }
      }
      return null;
  }

  function findIndex(arr, predicate, fromIndex) {
      if (fromIndex === void 0) { fromIndex = 0; }
      for (var i = fromIndex; i < arr.length; i++) {
          if (predicate(arr[i], i)) {
              // 
              return i;
          }
      }
      return -1;
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @param {Array} arr The array to flatten.
   * @return {Array} Returns the new flattened array.
   * @example
   *
   * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
   */
  var flatten = function (arr) {
      if (!isArray(arr)) {
          return [];
      }
      var rst = [];
      for (var i = 0; i < arr.length; i++) {
          rst = rst.concat(arr[i]);
      }
      return rst;
  };

  /**
   * @param {Array} arr The array to iterate over.
   * @return {*} Returns the maximum value.
   * @example
   *
   * max([1, 2]);
   * // => 2
   *
   * max([]);
   * // => undefined
   *
   * const data = new Array(1250010).fill(1).map((d,idx) => idx);
   *
   * max(data);
   * // => 1250010
   * // Math.max(...data) will encounter "Maximum call stack size exceeded" error
   */
  var max$1 = (function (arr) {
      if (!isArray(arr)) {
          return undefined;
      }
      return arr.reduce(function (prev, curr) {
          return Math.max(prev, curr);
      }, arr[0]);
  });

  /**
   * @param {Array} arr The array to iterate over.
   * @return {*} Returns the minimum value.
   * @example
   *
   * min([1, 2]);
   * // => 1
   *
   * min([]);
   * // => undefined
   *
   * const data = new Array(1250010).fill(1).map((d,idx) => idx);
   *
   * min(data);
   * // => 1250010
   * // Math.min(...data) will encounter "Maximum call stack size exceeded" error
   */
  var min$1 = (function (arr) {
      if (!isArray(arr)) {
          return undefined;
      }
      return arr.reduce(function (prev, curr) {
          return Math.min(prev, curr);
      }, arr[0]);
  });

  var getRange = function (values) {
      //  NaN min,max 
      var filterValues = values.filter(function (v) { return !isNaN(v); });
      if (!filterValues.length) {
          // 0
          return {
              min: 0,
              max: 0,
          };
      }
      if (isArray(values[0])) {
          var tmp = [];
          for (var i = 0; i < values.length; i++) {
              tmp = tmp.concat(values[i]);
          }
          filterValues = tmp;
      }
      var max = max$1(filterValues);
      var min = min$1(filterValues);
      return {
          min: min,
          max: max,
      };
  };

  var reduce = function (arr, fn, init) {
      if (!isArray(arr) && !isPlainObject(arr)) {
          return arr;
      }
      var result = init;
      each(arr, function (data, i) {
          result = fn(result, data, i);
      });
      return result;
  };

  var isString = (function (str) {
      return isType(str, 'String');
  });

  var valuesOfKey = (function (data, name) {
      var rst = [];
      var tmpMap = {};
      for (var i = 0; i < data.length; i++) {
          var obj = data[i];
          var value = obj[name];
          if (!isNil(value)) {
              // flatten
              if (!isArray(value)) {
                  value = [value];
              }
              for (var j = 0; j < value.length; j++) {
                  var val = value[j];
                  // unique
                  if (!tmpMap[val]) {
                      rst.push(val);
                      tmpMap[val] = true;
                  }
              }
          }
      }
      return rst;
  });

  function head(o) {
      if (isArrayLike(o)) {
          return o[0];
      }
      return undefined;
  }

  function last(o) {
      if (isArrayLike(o)) {
          var arr = o;
          return arr[arr.length - 1];
      }
      return undefined;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function groupBy(data, condition) {
      if (!condition || !isArray(data)) {
          return {};
      }
      var result = {};
      //  
      var predicate = isFunction(condition) ? condition : function (item) { return item[condition]; };
      var key;
      for (var i = 0; i < data.length; i++) {
          var item = data[i];
          key = predicate(item);
          if (hasOwnProperty.call(result, key)) {
              result[key].push(item);
          }
          else {
              result[key] = [item];
          }
      }
      return result;
  }

  /**
   *  map
   * @param data
   * @param condition
   */
  function groupToMap(data, condition) {
      if (!condition) {
          return {
              0: data,
          };
      }
      if (!isFunction(condition)) {
          //  a*b 
          var paramscondition_1 = isArray(condition) ? condition : condition.replace(/\s+/g, '').split('*');
          condition = function (row) {
              var unique = '_'; // Key
              //  key
              for (var i = 0, l = paramscondition_1.length; i < l; i++) {
                  unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
              }
              return unique;
          };
      }
      return groupBy(data, condition);
  }

  var group = (function (data, condition) {
      if (!condition) {
          // 
          return [data];
      }
      var groups = groupToMap(data, condition);
      var array = [];
      for (var i in groups) {
          array.push(groups[i]);
      }
      return array;
  });

  var clamp = function (a, min, max) {
      if (a < min) {
          return min;
      }
      else if (a > max) {
          return max;
      }
      return a;
  };

  /**
   * 
   * @return {Boolean} 
   */
  var isNumber = function (value) {
      return isType(value, 'Number');
  };

  var PRECISION = 0.00001; // numbers less than this is considered as 0
  function isNumberEqual(a, b, precision) {
      if (precision === void 0) { precision = PRECISION; }
      return Math.abs(a - b) < precision;
  }

  var mod = function (n, m) {
      return ((n % m) + m) % m;
  };

  var toString$1 = (function (value) {
      if (isNil(value))
          return '';
      return value.toString();
  });

  var upperFirst = function (value) {
      var str = toString$1(value);
      return str.charAt(0).toUpperCase() + str.substring(1);
  };

  var toString$2 = {}.toString;
  var getType = function (value) {
      return toString$2
          .call(value)
          .replace(/^\[object /, '')
          .replace(/]$/, '');
  };

  /**
   * 
   *
   * @param {Object} value 
   * @return {Boolean}
   */
  var isBoolean = function (value) {
      return isType(value, 'Boolean');
  };

  var isDate = function (value) {
      return isType(value, 'Date');
  };

  var isNull = function (value) {
      return value === null;
  };

  var objectProto = Object.prototype;
  var isPrototype = function (value) {
      var Ctor = value && value.constructor;
      var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;
      return value === proto;
  };

  var isUndefined = function (value) {
      return value === undefined;
  };

  // FIXME: Mutable param should be forbidden in static lang.
  function _mix(dist, obj) {
      for (var key in obj) {
          if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
              dist[key] = obj[key];
          }
      }
  }
  function mix(dist, src1, src2, src3) {
      if (src1)
          _mix(dist, src1);
      if (src2)
          _mix(dist, src2);
      if (src3)
          _mix(dist, src3);
      return dist;
  }

  var clone$2 = function (obj) {
      if (typeof obj !== 'object' || obj === null) {
          return obj;
      }
      var rst;
      if (isArray(obj)) {
          rst = [];
          for (var i = 0, l = obj.length; i < l; i++) {
              if (typeof obj[i] === 'object' && obj[i] != null) {
                  rst[i] = clone$2(obj[i]);
              }
              else {
                  rst[i] = obj[i];
              }
          }
      }
      else {
          rst = {};
          for (var k in obj) {
              if (typeof obj[k] === 'object' && obj[k] != null) {
                  rst[k] = clone$2(obj[k]);
              }
              else {
                  rst[k] = obj[k];
              }
          }
      }
      return rst;
  };

  var MAX_MIX_LEVEL = 5;
  function _deepMix(dist, src, level, maxLevel) {
      level = level || 0;
      maxLevel = maxLevel || MAX_MIX_LEVEL;
      for (var key in src) {
          if (src.hasOwnProperty(key)) {
              var value = src[key];
              if (value !== null && isPlainObject(value)) {
                  if (!isPlainObject(dist[key])) {
                      dist[key] = {};
                  }
                  if (level < maxLevel) {
                      _deepMix(dist[key], value, level + 1, maxLevel);
                  }
                  else {
                      dist[key] = src[key];
                  }
              }
              else if (isArray(value)) {
                  dist[key] = [];
                  dist[key] = dist[key].concat(value);
              }
              else if (value !== undefined) {
                  dist[key] = value;
              }
          }
      }
  }
  // todo 
  var deepMix = function (rst) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
      }
      for (var i = 0; i < args.length; i += 1) {
          _deepMix(rst, args[i]);
      }
      return rst;
  };

  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  function isEmpty(value) {
      /**
       * isEmpty(null) => true
       * isEmpty() => true
       * isEmpty(true) => true
       * isEmpty(1) => true
       * isEmpty([1, 2, 3]) => false
       * isEmpty('abc') => false
       * isEmpty({ a: 1 }) => false
       */
      if (isNil(value)) {
          return true;
      }
      if (isArrayLike(value)) {
          return !value.length;
      }
      var type = getType(value);
      if (type === 'Map' || type === 'Set') {
          return !value.size;
      }
      if (isPrototype(value)) {
          return !Object.keys(value).length;
      }
      for (var key in value) {
          if (hasOwnProperty$1.call(value, key)) {
              return false;
          }
      }
      return true;
  }

  var map = function (arr, func) {
      if (!isArrayLike(arr)) {
          // @ts-ignore
          return arr;
      }
      var result = [];
      for (var index = 0; index < arr.length; index++) {
          var value = arr[index];
          result.push(func(value, index));
      }
      return result;
  };

  var identity$1 = function (v) { return v; };
  var mapValues = (function (object, func) {
      if (func === void 0) { func = identity$1; }
      var r = {};
      if (isObject(object) && !isNil(object)) {
          Object.keys(object).forEach(function (key) {
              // @ts-ignore
              r[key] = func(object[key], key);
          });
      }
      return r;
  });

  /**
   * https://github.com/developit/dlv/blob/master/index.js
   * @param obj
   * @param key
   * @param defaultValue
   */
  var get = (function (obj, key, defaultValue) {
      var p = 0;
      var keyArr = isString(key) ? key.split('.') : key;
      while (obj && p < keyArr.length) {
          obj = obj[keyArr[p++]];
      }
      return obj === undefined || p < keyArr.length ? defaultValue : obj;
  });

  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  var pick = (function (object, keys) {
      if (object === null || !isPlainObject(object)) {
          return {};
      }
      var result = {};
      each(keys, function (key) {
          if (hasOwnProperty$2.call(object, key)) {
              result[key] = object[key];
          }
      });
      return result;
  });

  var omit = (function (obj, keys) {
      return reduce(obj, function (r, curr, key) {
          if (!keys.includes(key)) {
              r[key] = curr;
          }
          return r;
      }, {});
  });

  /**
   * k-v 
   */
  var default_1 = /** @class */ (function () {
      function default_1() {
          this.map = {};
      }
      default_1.prototype.has = function (key) {
          return this.map[key] !== undefined;
      };
      default_1.prototype.get = function (key, def) {
          var v = this.map[key];
          return v === undefined ? def : v;
      };
      default_1.prototype.set = function (key, value) {
          this.map[key] = value;
      };
      default_1.prototype.clear = function () {
          this.map = {};
      };
      default_1.prototype.delete = function (key) {
          delete this.map[key];
      };
      default_1.prototype.size = function () {
          return Object.keys(this.map).length;
      };
      return default_1;
  }());

  var Component = /** @class */function () {
    function Component(props, context, updater) {
      this.isMounted = false;
      // State 
      this.destroyed = false;
      this.props = props;
      this.state = {};
      this.context = context;
      this.updater = updater;
    }
    Component.prototype.willMount = function () {};
    Component.prototype.didMount = function () {};
    Component.prototype.shouldUpdate = function (_nextProps) {
      return true;
    };
    Component.prototype.willReceiveProps = function (_props, _context) {};
    Component.prototype.willUpdate = function () {};
    Component.prototype.didUpdate = function () {};
    Component.prototype.render = function () {
      return null;
    };
    Component.prototype.willUnmount = function () {};
    Component.prototype.didUnmount = function () {};
    Component.prototype.setState = function (partialState, callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueSetState(this, partialState, callback);
    };
    Component.prototype.forceUpdate = function (callback) {
      if (this.destroyed) {
        return;
      }
      this.updater.enqueueForceUpdate(this, {}, callback);
    };
    Component.prototype.setAnimate = function (animate) {
      this.animate = animate;
    };
    Component.prototype.destroy = function () {
      this.destroyed = true;
      this.animator = null;
    };
    return Component;
  }();
  // 
  // @ts-ignore
  Component.prototype.isF2Component = true;

  function cloneElement(element, props) {
    if (!element) return element;
    return __assign(__assign({}, element), {
      props: __assign(__assign({}, element.props), props)
    });
  }
  function map$1(children, fn) {
    if (!children) {
      return fn(children);
    }
    if (isArray(children)) {
      return children.map(function (child) {
        return map$1(child, fn);
      });
    }
    return fn(children);
  }
  function compareArray(nextElements, lastElements, callback) {
    var keyed = {};
    var nextLength = nextElements.length;
    var lastLength = lastElements.length;
    for (var i = 0, len = lastLength; i < len; i++) {
      var element = lastElements[i];
      if (element && !isNil(element.key)) {
        var key = element.key;
        keyed[key] = element;
      }
    }
    var result = [];
    // 
    for (var i = 0, len = nextLength; i < len; i++) {
      var element = nextElements[i];
      if (!element) {
        continue;
      }
      var key = element.key;
      var lastElement = void 0;
      // key
      if (!isNil(element.key)) {
        lastElement = keyed[key];
        if (lastElement) delete keyed[key];
      } else {
        // 
        lastElement = lastElements[i];
      }
      // 
      if (!lastElement) {
        result.push(compare(element, null, callback));
        continue;
      }
      //  lastElement , next 
      if (lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed) {
        result.push(compare(element, null, callback));
        continue;
      }
      //  element 
      lastElement.__processed = true;
      result.push(compare(element, lastElement, callback));
    }
    //  lastElements 
    for (var i = 0, len = lastLength; i < len; i++) {
      var lastElement = lastElements[i];
      if (!lastElement) {
        continue;
      }
      if (!(lastElement === null || lastElement === void 0 ? void 0 : lastElement.__processed)) {
        result.push(compare(null, lastElement, callback));
      } else {
        delete lastElement.__processed;
      }
    }
    return result;
  }
  // 2
  function compare(nextElement, lastElement, callback) {
    // 
    if (!nextElement || !lastElement) {
      return callback(nextElement, lastElement);
    }
    if (isArray(nextElement) || isArray(lastElement)) {
      var nextElementArray = isArray(nextElement) ? nextElement : [nextElement];
      var lastElementArray = isArray(lastElement) ? lastElement : [lastElement];
      return compareArray(nextElementArray, lastElementArray, callback);
    }
    return callback(nextElement, lastElement);
  }
  function toArray(element) {
    if (!element) {
      return element;
    }
    if (!isArray(element)) {
      return [element];
    }
    var newArray = [];
    for (var i = 0, len = element.length; i < len; i++) {
      var item = element[i];
      if (isArray(item)) {
        newArray = newArray.concat(toArray(item));
      } else {
        newArray.push(item);
      }
    }
    return newArray;
  }
  var Children = {
    cloneElement: cloneElement,
    map: map$1,
    toArray: toArray,
    compare: compare
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function (path, base) {
        return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
      }
    }, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var rbush = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
   module.exports = factory() ;
  }(commonjsGlobal, function () {
  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap(arr, left, k);
          if (compare(arr[right], t) > 0) { swap(arr, left, right); }

          while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) { i++; }
              while (compare(arr[j], t) > 0) { j--; }
          }

          if (compare(arr[left], t) === 0) { swap(arr, left, j); }
          else {
              j++;
              swap(arr, j, right);
          }

          if (j <= k) { left = j + 1; }
          if (k <= j) { right = j - 1; }
      }
  }

  function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  var RBush = function RBush(maxEntries) {
      if ( maxEntries === void 0 ) maxEntries = 9;

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
  };

  RBush.prototype.all = function all () {
      return this._all(this.data, []);
  };

  RBush.prototype.search = function search (bbox) {
      var node = this.data;
      var result = [];

      if (!intersects(bbox, node)) { return result; }

      var toBBox = this.toBBox;
      var nodesToSearch = [];

      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf) { result.push(child); }
                  else if (contains(bbox, childBBox)) { this._all(child, result); }
                  else { nodesToSearch.push(child); }
              }
          }
          node = nodesToSearch.pop();
      }

      return result;
  };

  RBush.prototype.collides = function collides (bbox) {
      var node = this.data;

      if (!intersects(bbox, node)) { return false; }

      var nodesToSearch = [];
      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? this.toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) { return true; }
                  nodesToSearch.push(child);
              }
          }
          node = nodesToSearch.pop();
      }

      return false;
  };

  RBush.prototype.load = function load (data) {
      if (!(data && data.length)) { return this; }

      if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
              this.insert(data[i]);
          }
          return this;
      }

      // recursively build the tree with the given data from scratch using OMT algorithm
      var node = this._build(data.slice(), 0, data.length - 1, 0);

      if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;

      } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);

      } else {
          if (this.data.height < node.height) {
              // swap trees if inserted one is bigger
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
          }

          // insert the small tree into the large tree at appropriate level
          this._insert(node, this.data.height - node.height - 1, true);
      }

      return this;
  };

  RBush.prototype.insert = function insert (item) {
      if (item) { this._insert(item, this.data.height - 1); }
      return this;
  };

  RBush.prototype.clear = function clear () {
      this.data = createNode([]);
      return this;
  };

  RBush.prototype.remove = function remove (item, equalsFn) {
      if (!item) { return this; }

      var node = this.data;
      var bbox = this.toBBox(item);
      var path = [];
      var indexes = [];
      var i, parent, goingUp;

      // depth-first iterative tree traversal
      while (node || path.length) {

          if (!node) { // go up
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
          }

          if (node.leaf) { // check current node
              var index = findItem(item, node.children, equalsFn);

              if (index !== -1) {
                  // item found, remove the item and condense tree upwards
                  node.children.splice(index, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
              }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];

          } else if (parent) { // go right
              i++;
              node = parent.children[i];
              goingUp = false;

          } else { node = null; } // nothing found
      }

      return this;
  };

  RBush.prototype.toBBox = function toBBox (item) { return item; };

  RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
  RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

  RBush.prototype.toJSON = function toJSON () { return this.data; };

  RBush.prototype.fromJSON = function fromJSON (data) {
      this.data = data;
      return this;
  };

  RBush.prototype._all = function _all (node, result) {
      var nodesToSearch = [];
      while (node) {
          if (node.leaf) { result.push.apply(result, node.children); }
          else { nodesToSearch.push.apply(nodesToSearch, node.children); }

          node = nodesToSearch.pop();
      }
      return result;
  };

  RBush.prototype._build = function _build (items, left, right, height) {

      var N = right - left + 1;
      var M = this._maxEntries;
      var node;

      if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
      }

      if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M));

          // target number of root entries to maximize storage utilization
          M = Math.ceil(N / Math.pow(M, height - 1));
      }

      node = createNode([]);
      node.leaf = false;
      node.height = height;

      // split the items into M mostly square tiles

      var N2 = Math.ceil(N / M);
      var N1 = N2 * Math.ceil(Math.sqrt(M));

      multiSelect(items, left, right, N1, this.compareMinX);

      for (var i = left; i <= right; i += N1) {

          var right2 = Math.min(i + N1 - 1, right);

          multiSelect(items, i, right2, N2, this.compareMinY);

          for (var j = i; j <= right2; j += N2) {

              var right3 = Math.min(j + N2 - 1, right2);

              // pack each entry recursively
              node.children.push(this._build(items, j, right3, height - 1));
          }
      }

      calcBBox(node, this.toBBox);

      return node;
  };

  RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
      while (true) {
          path.push(node);

          if (node.leaf || path.length - 1 === level) { break; }

          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = (void 0);

          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var area = bboxArea(child);
              var enlargement = enlargedArea(bbox, child) - area;

              // choose entry with the least area enlargement
              if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;

              } else if (enlargement === minEnlargement) {
                  // otherwise choose one with the smallest area
                  if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                  }
              }
          }

          node = targetNode || node.children[0];
      }

      return node;
  };

  RBush.prototype._insert = function _insert (item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];

      // find the best node for accommodating the item, saving all nodes along the path too
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);

      // put the item into the node
      node.children.push(item);
      extend(node, bbox);

      // split on node overflow; propagate upwards if necessary
      while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
          } else { break; }
      }

      // adjust bboxes along the insertion path
      this._adjustParentBBoxes(bbox, insertPath, level);
  };

  // split overflowed node into two
  RBush.prototype._split = function _split (insertPath, level) {
      var node = insertPath[level];
      var M = node.children.length;
      var m = this._minEntries;

      this._chooseSplitAxis(node, m, M);

      var splitIndex = this._chooseSplitIndex(node, m, M);

      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;

      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);

      if (level) { insertPath[level - 1].children.push(newNode); }
      else { this._splitRoot(node, newNode); }
  };

  RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
      // split root node
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
  };

  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
      var index;
      var minOverlap = Infinity;
      var minArea = Infinity;

      for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);

          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);

          // choose distribution with minimum overlap
          if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;

              minArea = area < minArea ? area : minArea;

          } else if (overlap === minOverlap) {
              // otherwise choose distribution with minimum area
              if (area < minArea) {
                  minArea = area;
                  index = i;
              }
          }
      }

      return index || M - m;
  };

  // sorts node children by the best axis for split
  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m, M, compareMinX);
      var yMargin = this._allDistMargin(node, m, M, compareMinY);

      // if total distributions margin value is minimal for x, sort by minX,
      // otherwise it's already sorted by minY
      if (xMargin < yMargin) { node.children.sort(compareMinX); }
  };

  // total margin of all possible split distributions where each node is at least m full
  RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
      node.children.sort(compare);

      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m, toBBox);
      var rightBBox = distBBox(node, M - m, M, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

      for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
      }

      for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
      }

      return margin;
  };

  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
      // adjust bboxes along the given tree path
      for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
      }
  };

  RBush.prototype._condense = function _condense (path) {
      // go through the path, removing empty nodes and updating bboxes
      for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
          if (path[i].children.length === 0) {
              if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);

              } else { this.clear(); }

          } else { calcBBox(path[i], this.toBBox); }
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) { return items.indexOf(item); }

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) { return i; }
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) { destNode = createNode(null); }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX);
      var minY = Math.max(a.minY, b.minY);
      var maxX = Math.min(a.maxX, b.maxX);
      var maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right];

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) { continue; }

          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  return RBush;

  }));
  });

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
      reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
      reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
      reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
      reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
      reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }

  function rgb_formatRgb() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }

  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(")
          + (this.h || 0) + ", "
          + (this.s || 0) * 100 + "%, "
          + (this.l || 0) * 100 + "%"
          + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  function distance$1(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function isNumberEqual$1(v1, v2) {
    return Math.abs(v1 - v2) < 0.001;
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = Math.min.apply(Math, xArr);
    var minY = Math.min.apply(Math, yArr);
    var maxX = Math.max.apply(Math, xArr);
    var maxY = Math.max.apply(Math, yArr);
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function piMod(angle) {
    return (angle + Math.PI * 2) % (Math.PI * 2);
  }

  var line = {
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {object} 
     */
    box: function box(x1, y1, x2, y2) {
      return getBBoxByArray([x1, x2], [y1, y2]);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {number} 
     */
    length: function length(x1, y1, x2, y2) {
      return distance$1(x1, y1, x2, y2);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} t 
     * @return {object}  x, y 
     */
    pointAt: function pointAt(x1, y1, x2, y2, t) {
      return {
        x: (1 - t) * x1 + t * x2,
        y: (1 - t) * y1 + t * y2
      };
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} x   x
     * @param {number} y   y
     * @return {number} 
     */
    pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
      //  x1, y1  p, p1, p2  a
      // p1a = p1p.p1p2/|p1p2| * (p1p )
      var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
      if (cross < 0) {
        return distance$1(x1, y1, x, y);
      }
      var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (cross > lengthSquare) {
        return distance$1(x2, y2, x, y);
      }
      return this.pointToLine(x1, y1, x2, y2, x, y);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} x   x
     * @param {number} y   y
     * @return {number} 
     */
    pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
      var d = [x2 - x1, y2 - y1];
      // 
      if (exactEquals$1(d, [0, 0])) {
        return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      }
      var u = [-d[1], d[0]];
      normalize$3(u, u);
      var a = [x - x1, y - y1];
      return Math.abs(dot$1(a, u));
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {number} 
     */
    tangentAngle: function tangentAngle(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    }
  };

  var EPSILON$1 = 0.0001;
  /**
   * 
   * @param {number[]} xArr       x 
   * @param {number[]} yArr       y 
   * @param {number}   x          x
   * @param {number}   y          y
   * @param {Function} tCallback 
   */
  function nearestPoint(xArr, yArr, x, y, tCallback, length) {
    var t = -1;
    var d = Infinity;
    var v0 = [x, y];
    var segNum = 20;
    if (length && length > 200) {
      segNum = length / 10;
    }
    var increaseRate = 1 / segNum;
    var interval = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
      var d1 = distance$1(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    // 
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count = xArr.length;
      return {
        x: xArr[count - 1],
        y: yArr[count - 1]
      };
    }
    d = Infinity;
    for (var _i = 0; _i < 32; _i++) {
      if (interval < EPSILON$1) {
        break;
      }
      var prev = t - interval;
      var next = t + interval;
      var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
      var _d = distance$1(v0[0], v0[1], _v[0], _v[1]);
      if (prev >= 0 && _d < d) {
        t = prev;
        d = _d;
      } else {
        var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
        var d2 = distance$1(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(void 0, xArr.concat([t])),
      y: tCallback.apply(void 0, yArr.concat([t]))
    };
  }
  //  https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2
  function snapLength(xArr, yArr) {
    var totalLength = 0;
    var count = xArr.length;
    for (var i = 0; i < count; i++) {
      var x = xArr[i];
      var y = yArr[i];
      var nextX = xArr[(i + 1) % count];
      var nextY = yArr[(i + 1) % count];
      totalLength += distance$1(x, y, nextX, nextY);
    }
    return totalLength / 2;
  }

  // 
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  // 
  function extrema(p0, p1, p2) {
    var a = p0 + p2 - 2 * p1;
    if (isNumberEqual$1(a, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function derivativeAt(p0, p1, p2, t) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
  }
  // 
  function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
    // 
    var xt = quadraticAt(x1, x2, x3, t);
    var yt = quadraticAt(y1, y2, y3, t);
    // 
    var controlPoint1 = line.pointAt(x1, y1, x2, y2, t);
    // 
    var controlPoint2 = line.pointAt(x2, y2, x3, y3, t);
    return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
  }
  // 
  function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
    if (iterationCount === 0) {
      return (distance$1(x1, y1, x2, y2) + distance$1(x2, y2, x3, y3) + distance$1(x1, y1, x3, y3)) / 2;
    }
    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
    var left = quadratics[0];
    var right = quadratics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return quadraticLength.apply(void 0, left) + quadraticLength.apply(void 0, right);
  }
  var quadratic = {
    box: function box(x1, y1, x2, y2, x3, y3) {
      var xExtrema = extrema(x1, x2, x3)[0];
      var yExtrema = extrema(y1, y2, y3)[0];
      //  box 
      var xArr = [x1, x3];
      var yArr = [y1, y3];
      if (xExtrema !== undefined) {
        xArr.push(quadraticAt(x1, x2, x3, xExtrema));
      }
      if (yExtrema !== undefined) {
        yArr.push(quadraticAt(y1, y2, y3, yExtrema));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function length(x1, y1, x2, y2, x3, y3) {
      return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
    },
    nearestPoint: function nearestPoint$1(x1, y1, x2, y2, x3, y3, x0, y0) {
      return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
    },
    pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
      return distance$1(point.x, point.y, x0, y0);
    },
    interpolationAt: quadraticAt,
    pointAt: function pointAt(x1, y1, x2, y2, x3, y3, t) {
      return {
        x: quadraticAt(x1, x2, x3, t),
        y: quadraticAt(y1, y2, y3, t)
      };
    },
    divide: function divide(x1, y1, x2, y2, x3, y3, t) {
      return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
    },
    tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, t) {
      var dx = derivativeAt(x1, x2, x3, t);
      var dy = derivativeAt(y1, y2, y3, t);
      var angle = Math.atan2(dy, dx);
      return piMod(angle);
    }
  };

  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t; // t * t * t  Math.pow(t, 3) 
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function derivativeAt$1(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
  }
  function extrema$1(p0, p1, p2, p3) {
    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual$1(a, 0)) {
      if (!isNumberEqual$1(b, 0)) {
        t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isNumberEqual$1(disc, 0)) {
        extremas.push(-b / (2 * a));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a);
        t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  // 
  function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    // 
    var xt = cubicAt(x1, x2, x3, x4, t);
    var yt = cubicAt(y1, y2, y3, y4, t);
    // 
    var c1 = line.pointAt(x1, y1, x2, y2, t);
    var c2 = line.pointAt(x2, y2, x3, y3, t);
    var c3 = line.pointAt(x3, y3, x4, y4, t);
    var c12 = line.pointAt(c1.x, c1.y, c2.x, c2.y, t);
    var c23 = line.pointAt(c2.x, c2.y, c3.x, c3.y, t);
    return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
  }
  // 
  function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
    if (iterationCount === 0) {
      return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
    }
    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
    var left = [].concat(cubics[0], [iterationCount - 1]);
    var right = [].concat(cubics[1], [iterationCount - 1]);
    return cubicLength.apply(void 0, left) + cubicLength.apply(void 0, right);
  }
  var cubic = {
    extrema: extrema$1,
    box: function box(x1, y1, x2, y2, x3, y3, x4, y4) {
      var xArr = [x1, x4];
      var yArr = [y1, y4];
      var xExtrema = extrema$1(x1, x2, x3, x4);
      var yExtrema = extrema$1(y1, y2, y3, y4);
      for (var i = 0; i < xExtrema.length; i++) {
        xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));
      }
      for (var _i = 0; _i < yExtrema.length; _i++) {
        yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[_i]));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function length(x1, y1, x2, y2, x3, y3, x4, y4) {
      //  8 
      return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
    },
    nearestPoint: function nearestPoint$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
      return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);
    },
    pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
      return distance$1(point.x, point.y, x0, y0);
    },
    interpolationAt: cubicAt,
    pointAt: function pointAt(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return {
        x: cubicAt(x1, x2, x3, x4, t),
        y: cubicAt(y1, y2, y3, y4, t)
      };
    },
    divide: function divide(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
    },
    tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      var dx = derivativeAt$1(x1, x2, x3, x4, t);
      var dy = derivativeAt$1(y1, y2, y3, y4, t);
      return piMod(Math.atan2(dy, dx));
    }
  };

  /**
   * @fileoverview 
   *  - https://www.mathsisfun.com/geometry/ellipse-perimeter.html
   *  - https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/
   * @author dxq613@gmail.com
   */
  function copysign(v1, v2) {
    var absv = Math.abs(v1);
    return v2 > 0 ? absv : absv * -1;
  }
  var ellipse = {
    /**
     * 
     * @param {number} x   x
     * @param {number} y   y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @return {object} 
     */
    box: function box(x, y, rx, ry) {
      return {
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      };
    },
    /**
     * 
     * @param {number} x   x
     * @param {number} y   y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @return {number} 
     */
    length: function length(x, y, rx, ry) {
      return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
    },
    /**
     * 
     * @param {number} x   x
     * @param {number} y   y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @param {number} x0   x
     * @param {number} y0   y
     * @return {object} 
     */
    nearestPoint: function nearestPoint(x, y, rx, ry, x0, y0) {
      var a = rx;
      var b = ry;
      // 0
      if (a === 0 || b === 0) {
        return {
          x: x,
          y: y
        };
      }
      //  0 0 
      var relativeX = x0 - x;
      var relativeY = y0 - y;
      var px = Math.abs(relativeX);
      var py = Math.abs(relativeY);
      var squareA = a * a;
      var squareB = b * b;
      // const angle0 = Math.atan2(relativeY, relativeX);
      var t = Math.PI / 4;
      var nearestX = 0; // 
      var nearestY = 0;
      //  4 
      for (var i = 0; i < 4; i++) {
        nearestX = a * Math.cos(t);
        nearestY = b * Math.sin(t);
        var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
        var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
        var rx1 = nearestX - ex;
        var ry1 = nearestY - ey;
        var qx = px - ex;
        var qy = py - ey;
        var r = Math.hypot(ry1, rx1);
        var q = Math.hypot(qy, qx);
        var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
        var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
        t += delta_t;
        t = Math.min(Math.PI / 2, Math.max(0, t));
      }
      return {
        x: x + copysign(nearestX, relativeX),
        y: y + copysign(nearestY, relativeY)
      };
    },
    /**
     * 
     * @param {number} x   x
     * @param {number} y   y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @param {number} x0   x
     * @param {number} y0   y
     * @return {number} 
     */
    pointDistance: function pointDistance(x, y, rx, ry, x0, y0) {
      var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);
      return distance$1(nearestPoint.x, nearestPoint.y, x0, y0);
    },
    /**
     * 
     * @param {number} x  x
     * @param {number} y  y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @param {number} t x 0
     * @return {object} 
     */
    pointAt: function pointAt(x, y, rx, ry, t) {
      var angle = 2 * Math.PI * t; // 
      return {
        x: x + rx * Math.cos(angle),
        y: y + ry * Math.sin(angle)
      };
    },
    /**
     * 
     * @param {number} x  x
     * @param {number} y  y
     * @param {number} rx  x 
     * @param {number} ry  y 
     * @param {number} t  0 - 1 x 0 0-1  null
     * @return {number}  0 - 2PI 
     */
    tangentAngle: function tangentAngle(x, y, rx, ry, t) {
      var angle = 2 * Math.PI * t; // 
      //  x,y  x' = -rx * sin(t); y' = ry * cos(t);
      var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));
      // 
      // const point = this.pointAt(0, 0, rx, ry, t); // 
      // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));
      // if (angle >= 0 && angle <= Math.PI) {
      //   tangentAngle += Math.PI;
      // }
      return piMod(tangentAngle);
    }
  };

  //  x
  function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
    return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);
  }
  //  y
  function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
    return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);
  }
  // x 
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  // y 
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  //  x 
  function xAt(cx, cy, rx, ry, xRotation, angle) {
    return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;
  }
  //  y 
  function yAt(cx, cy, rx, ry, xRotation, angle) {
    return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;
  }
  // 
  function getAngle(rx, ry, x0, y0) {
    var angle = Math.atan2(y0 * rx, x0 * ry);
    //  0 - 2PI 
    return (angle + Math.PI * 2) % (Math.PI * 2);
  }
  // x,y
  function getPoint(rx, ry, angle) {
    return {
      x: rx * Math.cos(angle),
      y: ry * Math.sin(angle)
    };
  }
  // 
  function rotate$2(x, y, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return [x * cos - y * sin, x * sin + y * cos];
  }
  var arc = {
    /**
     * 
     * @param {number} cx          x
     * @param {number} cy          y
     * @param {number} rx         x 
     * @param {number} ry         y 
     * @param {number} xRotation  
     * @param {number} startAngle 
     * @param {number} endAngle   
     * @return {object} 
     */
    box: function box(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
      var xDim = xExtrema(rx, ry, xRotation);
      var minX = Infinity;
      var maxX = -Infinity;
      var xs = [startAngle, endAngle];
      for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
        var xAngle = xDim + i;
        if (startAngle < endAngle) {
          if (startAngle < xAngle && xAngle < endAngle) {
            xs.push(xAngle);
          }
        } else {
          if (endAngle < xAngle && xAngle < startAngle) {
            xs.push(xAngle);
          }
        }
      }
      for (var _i = 0; _i < xs.length; _i++) {
        var x = xAt(cx, cy, rx, ry, xRotation, xs[_i]);
        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
      }
      var yDim = yExtrema(rx, ry, xRotation);
      var minY = Infinity;
      var maxY = -Infinity;
      var ys = [startAngle, endAngle];
      for (var _i2 = -Math.PI * 2; _i2 <= Math.PI * 2; _i2 += Math.PI) {
        var yAngle = yDim + _i2;
        if (startAngle < endAngle) {
          if (startAngle < yAngle && yAngle < endAngle) {
            ys.push(yAngle);
          }
        } else {
          if (endAngle < yAngle && yAngle < startAngle) {
            ys.push(yAngle);
          }
        }
      }
      for (var _i3 = 0; _i3 < ys.length; _i3++) {
        var y = yAt(cx, cy, rx, ry, xRotation, ys[_i3]);
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }
      }
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    /**
     * 
     *  rx, ry, startAngle, endAngle 
     * @param {number} cx          x
     * @param {number} cy          y
     * @param {number} rx         x 
     * @param {number} ry         y 
     * @param {number} xRotation  
     * @param {number} startAngle 
     * @param {number} endAngle   
     */
    length: function length(cx, cy, rx, ry, xRotation, startAngle, endAngle) {},
    /**
     * 
     * @param {number} cx          x
     * @param {number} cy          y
     * @param {number} rx         x 
     * @param {number} ry         y 
     * @param {number} xRotation  
     * @param {number} startAngle 
     * @param {number} endAngle   
     * @param {number} x0          x
     * @param {number} y0          y
     * @return {object} 
     */
    nearestPoint: function nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      //  0,0 
      var relativeVector = rotate$2(x0 - cx, y0 - cy, -xRotation);
      var x1 = relativeVector[0],
        y1 = relativeVector[1];
      // 
      var relativePoint = ellipse.nearestPoint(0, 0, rx, ry, x1, y1);
      // 
      var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);
      // 
      if (angle < startAngle) {
        // 
        relativePoint = getPoint(rx, ry, startAngle);
      } else if (angle > endAngle) {
        // 
        relativePoint = getPoint(rx, ry, endAngle);
      }
      //  xRotation 
      var vector = rotate$2(relativePoint.x, relativePoint.y, xRotation);
      return {
        x: vector[0] + cx,
        y: vector[1] + cy
      };
    },
    pointDistance: function pointDistance(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      var nearestPoint = this.nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0);
      return distance$1(nearestPoint.x, nearestPoint.y, x0, y0);
    },
    pointAt: function pointAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle = (endAngle - startAngle) * t + startAngle;
      return {
        x: xAt(cx, cy, rx, ry, xRotation, angle),
        y: yAt(cx, cy, rx, ry, xRotation, angle)
      };
    },
    tangentAngle: function tangentAngle(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle = (endAngle - startAngle) * t + startAngle;
      var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
      var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
      return piMod(Math.atan2(dy, dx));
    }
  };

  function analyzePoints(points) {
    // 
    var totalLength = 0;
    var segments = [];
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      var length = distance$1(from[0], from[1], to[0], to[1]);
      var seg = {
        from: from,
        to: to,
        length: length
      };
      segments.push(seg);
      totalLength += length;
    }
    return {
      segments: segments,
      totalLength: totalLength
    };
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance$1(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  /**
   * 
   * @param {array} points 
   * @param {number} t  0-1
   * @return {object} 
   */
  function pointAtSegments(points, t) {
    // 
    if (t > 1 || t < 0 || points.length < 2) {
      return null;
    }
    var _analyzePoints = analyzePoints(points),
      segments = _analyzePoints.segments,
      totalLength = _analyzePoints.totalLength;
    // 
    if (totalLength === 0) {
      return {
        x: points[0][0],
        y: points[0][1]
      };
    }
    // 
    var startRatio = 0;
    var point = null;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from,
        to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        var localRatio = (t - startRatio) / currentRatio;
        point = line.pointAt(from[0], from[1], to[0], to[1], localRatio);
        break;
      }
      startRatio += currentRatio;
    }
    return point;
  }
  /**
   * 
   * @param {array} points 
   * @param {number} t  0-1
   */
  function angleAtSegments(points, t) {
    // 
    if (t > 1 || t < 0 || points.length < 2) {
      return 0;
    }
    var _analyzePoints2 = analyzePoints(points),
      segments = _analyzePoints2.segments,
      totalLength = _analyzePoints2.totalLength;
    // 
    var startRatio = 0;
    var angle = 0;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from,
        to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
        break;
      }
      startRatio += currentRatio;
    }
    return angle;
  }
  function distanceAtSegment(points, x, y) {
    var minDistance = Infinity;
    for (var i = 0; i < points.length - 1; i++) {
      var point = points[i];
      var nextPoint = points[i + 1];
      var _distance = line.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
      if (_distance < minDistance) {
        minDistance = _distance;
      }
    }
    return minDistance;
  }

  var polyline = {
    /**
     * 
     * @param {array} points  [x,y] 
     * @return {object} 
     */
    box: function box(points) {
      var xArr = [];
      var yArr = [];
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        xArr.push(point[0]);
        yArr.push(point[1]);
      }
      return getBBoxByArray(xArr, yArr);
    },
    /**
     * 
     * @param {array} points  [x,y] 
     * @return {object} 
     */
    length: function length(points) {
      return lengthOfSegment(points);
    },
    /**
     * 
     * @param {array} points  [x,y] 
     * @param {number} t 
     * @return {object} 
     */
    pointAt: function pointAt(points, t) {
      return pointAtSegments(points, t);
    },
    /**
     * 
     * @param {array} points  [x,y] 
     * @param {number} x  x
     * @param {number} y  y
     * @return {number} 
     */
    pointDistance: function pointDistance(points, x, y) {
      return distanceAtSegment(points, x, y);
    },
    /**
     * 
     * @param {array} points  [x,y] 
     * @param {number} t 
     * @return {object} 
     */
    tangentAngle: function tangentAngle(points, t) {
      return angleAtSegments(points, t);
    }
  };

  var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty
    , prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once)
      , evt = prefix ? prefix + event : event;

    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [emitter._events[evt], listener];

    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = []
      , events
      , name;

    if (this._eventsCount === 0) return names;

    for (name in (events = this._events)) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event
      , handlers = this._events[evt];

    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event
      , listeners = this._events[evt];

    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return false;

    var listeners = this._events[evt]
      , len = arguments.length
      , args
      , i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1: return listeners.fn.call(listeners.context), true;
        case 2: return listeners.fn.call(listeners.context, a1), true;
        case 3: return listeners.fn.call(listeners.context, a1, a2), true;
        case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len -1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length
        , j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1: listeners[i].fn.call(listeners[i].context); break;
          case 2: listeners[i].fn.call(listeners[i].context, a1); break;
          case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
          case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
          default:
            if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
              args[j - 1] = arguments[j];
            }

            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;

    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (
        listeners.fn === fn &&
        (!once || listeners.once) &&
        (!context || listeners.context === context)
      ) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (
          listeners[i].fn !== fn ||
          (once && !listeners[i].once) ||
          (context && listeners[i].context !== context)
        ) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
      else clearEvent(this, evt);
    }

    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
  });

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type
   */
  var PropertySyntax;
  (function (PropertySyntax) {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#coordinate
     */
    PropertySyntax["COORDINATE"] = "<coordinate>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#color
     */
    PropertySyntax["COLOR"] = "<color>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#paint
     */
    PropertySyntax["PAINT"] = "<paint>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#number
     */
    PropertySyntax["NUMBER"] = "<number>";
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/angle
     */
    PropertySyntax["ANGLE"] = "<angle>";
    /**
     * <number> with range 0..1
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#opacity_value
     */
    PropertySyntax["OPACITY_VALUE"] = "<opacity-value>";
    /**
     * <number> with range 0..Infinity
     */
    PropertySyntax["SHADOW_BLUR"] = "<shadow-blur>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#length
     */
    PropertySyntax["LENGTH"] = "<length>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#percentage
     */
    PropertySyntax["PERCENTAGE"] = "<percentage>";
    PropertySyntax["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
    PropertySyntax["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/margin#formal_syntax
     */
    PropertySyntax["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Content_type#list-of-ts
     */
    PropertySyntax["LIST_OF_POINTS"] = "<list-of-points>";
    PropertySyntax["PATH"] = "<path>";
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/filter#formal_syntax
     */
    PropertySyntax["FILTER"] = "<filter>";
    PropertySyntax["Z_INDEX"] = "<z-index>";
    PropertySyntax["OFFSET_DISTANCE"] = "<offset-distance>";
    PropertySyntax["DEFINED_PATH"] = "<defined-path>";
    PropertySyntax["MARKER"] = "<marker>";
    PropertySyntax["TRANSFORM"] = "<transform>";
    PropertySyntax["TRANSFORM_ORIGIN"] = "<transform-origin>";
    PropertySyntax["TEXT"] = "<text>";
    PropertySyntax["TEXT_TRANSFORM"] = "<text-transform>";
  })(PropertySyntax || (PropertySyntax = {}));

  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  // These units are iterated through, so be careful when adding or changing the
  // order.
  var UnitType;
  (function (UnitType) {
    UnitType[UnitType["kUnknown"] = 0] = "kUnknown";
    UnitType[UnitType["kNumber"] = 1] = "kNumber";
    UnitType[UnitType["kPercentage"] = 2] = "kPercentage";
    // Length units
    UnitType[UnitType["kEms"] = 3] = "kEms";
    // kExs,
    UnitType[UnitType["kPixels"] = 4] = "kPixels";
    // kCentimeters,
    // kMillimeters,
    // kInches,
    // kPoints,
    // kPicas,
    // kQuarterMillimeters,
    // https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
    //
    // See also IsViewportPercentageLength.
    // kViewportWidth,
    // kViewportHeight,
    // kViewportInlineSize,
    // kViewportBlockSize,
    // kViewportMin,
    // kViewportMax,
    // kSmallViewportWidth,
    // kSmallViewportHeight,
    // kSmallViewportInlineSize,
    // kSmallViewportBlockSize,
    // kSmallViewportMin,
    // kSmallViewportMax,
    // kLargeViewportWidth,
    // kLargeViewportHeight,
    // kLargeViewportInlineSize,
    // kLargeViewportBlockSize,
    // kLargeViewportMin,
    // kLargeViewportMax,
    // kDynamicViewportWidth,
    // kDynamicViewportHeight,
    // kDynamicViewportInlineSize,
    // kDynamicViewportBlockSize,
    // kDynamicViewportMin,
    // kDynamicViewportMax,
    // https://drafts.csswg.org/css-contain-3/#container-lengths
    //
    // See also IsContainerPercentageLength.
    // kContainerWidth,
    // kContainerHeight,
    // kContainerInlineSize,
    // kContainerBlockSize,
    // kContainerMin,
    // kContainerMax,
    UnitType[UnitType["kRems"] = 5] = "kRems";
    // kChs,
    // kUserUnits, // The SVG term for unitless lengths
    // Angle units
    UnitType[UnitType["kDegrees"] = 6] = "kDegrees";
    UnitType[UnitType["kRadians"] = 7] = "kRadians";
    UnitType[UnitType["kGradians"] = 8] = "kGradians";
    UnitType[UnitType["kTurns"] = 9] = "kTurns";
    // Time units
    UnitType[UnitType["kMilliseconds"] = 10] = "kMilliseconds";
    UnitType[UnitType["kSeconds"] = 11] = "kSeconds";
    // kHertz,
    // kKilohertz,
    // Resolution
    // kDotsPerPixel,
    // kDotsPerInch,
    // kDotsPerCentimeter,
    // Other units
    // kFraction,
    UnitType[UnitType["kInteger"] = 12] = "kInteger";
    // This value is used to handle quirky margins in reflow roots (body, td,
    // and th) like WinIE. The basic idea is that a stylesheet can use the value
    // __qem (for quirky em) instead of em. When the quirky value is used, if
    // you're in quirks mode, the margin will collapse away inside a table cell.
    // This quirk is specified in the HTML spec but our impl is different.
    // TODO: Remove this. crbug.com/443952
    // kQuirkyEms,
  })(UnitType || (UnitType = {}));
  var UnitCategory;
  (function (UnitCategory) {
    UnitCategory[UnitCategory["kUNumber"] = 0] = "kUNumber";
    UnitCategory[UnitCategory["kUPercent"] = 1] = "kUPercent";
    UnitCategory[UnitCategory["kULength"] = 2] = "kULength";
    UnitCategory[UnitCategory["kUAngle"] = 3] = "kUAngle";
    UnitCategory[UnitCategory["kUTime"] = 4] = "kUTime";
    // kUFrequency,
    // kUResolution,
    UnitCategory[UnitCategory["kUOther"] = 5] = "kUOther";
  })(UnitCategory || (UnitCategory = {}));
  var ValueRange;
  (function (ValueRange) {
    ValueRange[ValueRange["kAll"] = 0] = "kAll";
    ValueRange[ValueRange["kNonNegative"] = 1] = "kNonNegative";
    ValueRange[ValueRange["kInteger"] = 2] = "kInteger";
    ValueRange[ValueRange["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
    ValueRange[ValueRange["kPositiveInteger"] = 4] = "kPositiveInteger";
  })(ValueRange || (ValueRange = {}));
  var Nested;
  (function (Nested) {
    Nested[Nested["kYes"] = 0] = "kYes";
    Nested[Nested["kNo"] = 1] = "kNo";
  })(Nested || (Nested = {}));
  var ParenLess;
  (function (ParenLess) {
    ParenLess[ParenLess["kYes"] = 0] = "kYes";
    ParenLess[ParenLess["kNo"] = 1] = "kNo";
  })(ParenLess || (ParenLess = {}));

  // This file specifies the unit strings used in CSSPrimitiveValues.
  var data = [{
    name: 'em',
    unit_type: UnitType.kEms
  },
  // {
  //   name: 'ex',
  //   unit_type: UnitType.kExs,
  // },
  {
    name: 'px',
    unit_type: UnitType.kPixels
  },
  // {
  //   name: "cm",
  //   unit_type: UnitType.kCentimeters,
  // },
  // {
  //   name: "mm",
  //   unit_type: UnitType.kMillimeters,
  // },
  // {
  //   name: "q",
  //   unit_type: UnitType.kQuarterMillimeters,
  // },
  // {
  //   name: "in",
  //   unit_type: UnitType.kInches,
  // },
  // {
  //   name: "pt",
  //   unit_type: UnitType.kPoints,
  // },
  // {
  //   name: "pc",
  //   unit_type: UnitType.kPicas,
  // },
  {
    name: 'deg',
    unit_type: UnitType.kDegrees
  }, {
    name: 'rad',
    unit_type: UnitType.kRadians
  }, {
    name: 'grad',
    unit_type: UnitType.kGradians
  }, {
    name: 'ms',
    unit_type: UnitType.kMilliseconds
  }, {
    name: 's',
    unit_type: UnitType.kSeconds
  },
  // {
  //   name: "hz",
  //   unit_type: UnitType.kHertz,
  // },
  // {
  //   name: "khz",
  //   unit_type: UnitType.kKilohertz,
  // },
  // {
  //   name: "dpi",
  //   unit_type: "kDotsPerInch",
  // },
  // {
  //   name: "dpcm",
  //   unit_type: "kDotsPerCentimeter",
  // },
  // {
  //   name: "dppx",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "x",
  //   unit_type: "kDotsPerPixel",
  // },
  // {
  //   name: "vw",
  //   unit_type: "kViewportWidth",
  // },
  // {
  //   name: "vh",
  //   unit_type: "kViewportHeight",
  // },
  // {
  //   name: "vi",
  //   unit_type: "kViewportInlineSize",
  // },
  // {
  //   name: "vb",
  //   unit_type: "kViewportBlockSize",
  // },
  // {
  //   name: "vmin",
  //   unit_type: UnitType.kViewportMin,
  // },
  // {
  //   name: "vmax",
  //   unit_type: UnitType.kViewportMax,
  // },
  // {
  //   name: "svw",
  //   unit_type: "kSmallViewportWidth",
  // },
  // {
  //   name: "svh",
  //   unit_type: "kSmallViewportHeight",
  // },
  // {
  //   name: "svi",
  //   unit_type: "kSmallViewportInlineSize",
  // },
  // {
  //   name: "svb",
  //   unit_type: "kSmallViewportBlockSize",
  // },
  // {
  //   name: "svmin",
  //   unit_type: "kSmallViewportMin",
  // },
  // {
  //   name: "svmax",
  //   unit_type: "kSmallViewportMax",
  // },
  // {
  //   name: "lvw",
  //   unit_type: "kLargeViewportWidth",
  // },
  // {
  //   name: "lvh",
  //   unit_type: "kLargeViewportHeight",
  // },
  // {
  //   name: "lvi",
  //   unit_type: "kLargeViewportInlineSize",
  // },
  // {
  //   name: "lvb",
  //   unit_type: "kLargeViewportBlockSize",
  // },
  // {
  //   name: "lvmin",
  //   unit_type: UnitType.kLargeViewportMin,
  // },
  // {
  //   name: "lvmax",
  //   unit_type: UnitType.kLargeViewportMax,
  // },
  // {
  //   name: "dvw",
  //   unit_type: UnitType.kDynamicViewportWidth,
  // },
  // {
  //   name: "dvh",
  //   unit_type: UnitType.kDynamicViewportHeight,
  // },
  // {
  //   name: "dvi",
  //   unit_type: UnitType.kDynamicViewportInlineSize,
  // },
  // {
  //   name: "dvb",
  //   unit_type: UnitType.kDynamicViewportBlockSize,
  // },
  // {
  //   name: "dvmin",
  //   unit_type: UnitType.kDynamicViewportMin,
  // },
  // {
  //   name: "dvmax",
  //   unit_type: UnitType.kDynamicViewportMax,
  // },
  // {
  //   name: "cqw",
  //   unit_type: UnitType.kContainerWidth,
  // },
  // {
  //   name: "cqh",
  //   unit_type: UnitType.kContainerHeight,
  // },
  // {
  //   name: "cqi",
  //   unit_type: UnitType.kContainerInlineSize,
  // },
  // {
  //   name: "cqb",
  //   unit_type: UnitType.kContainerBlockSize,
  // },
  // {
  //   name: "cqmin",
  //   unit_type: UnitType.kContainerMin,
  // },
  // {
  //   name: "cqmax",
  //   unit_type: UnitType.kContainerMax,
  // },
  {
    name: 'rem',
    unit_type: UnitType.kRems
  },
  // {
  //   name: 'fr',
  //   unit_type: UnitType.kFraction,
  // },
  {
    name: 'turn',
    unit_type: UnitType.kTurns
  }
  // {
  //   name: 'ch',
  //   unit_type: UnitType.kChs,
  // },
  // {
  //   name: '__qem',
  //   unit_type: UnitType.kQuirkyEms,
  // },
  ];

  var CSSStyleValueType;
  (function (CSSStyleValueType) {
    CSSStyleValueType[CSSStyleValueType["kUnknownType"] = 0] = "kUnknownType";
    CSSStyleValueType[CSSStyleValueType["kUnparsedType"] = 1] = "kUnparsedType";
    CSSStyleValueType[CSSStyleValueType["kKeywordType"] = 2] = "kKeywordType";
    // Start of CSSNumericValue subclasses
    CSSStyleValueType[CSSStyleValueType["kUnitType"] = 3] = "kUnitType";
    CSSStyleValueType[CSSStyleValueType["kSumType"] = 4] = "kSumType";
    CSSStyleValueType[CSSStyleValueType["kProductType"] = 5] = "kProductType";
    CSSStyleValueType[CSSStyleValueType["kNegateType"] = 6] = "kNegateType";
    CSSStyleValueType[CSSStyleValueType["kInvertType"] = 7] = "kInvertType";
    CSSStyleValueType[CSSStyleValueType["kMinType"] = 8] = "kMinType";
    CSSStyleValueType[CSSStyleValueType["kMaxType"] = 9] = "kMaxType";
    CSSStyleValueType[CSSStyleValueType["kClampType"] = 10] = "kClampType";
    // End of CSSNumericValue subclasses
    CSSStyleValueType[CSSStyleValueType["kTransformType"] = 11] = "kTransformType";
    CSSStyleValueType[CSSStyleValueType["kPositionType"] = 12] = "kPositionType";
    CSSStyleValueType[CSSStyleValueType["kURLImageType"] = 13] = "kURLImageType";
    CSSStyleValueType[CSSStyleValueType["kColorType"] = 14] = "kColorType";
    CSSStyleValueType[CSSStyleValueType["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  })(CSSStyleValueType || (CSSStyleValueType = {}));
  // function parseCSSStyleValue(propertyName: string, value: string): CSSStyleValue[] {
  //   // const propertyId = cssPropertyID(propertyName);
  //   // if (propertyId === CSSPropertyID.kInvalid) {
  //   //   return [];
  //   // }
  //   // const customPropertyName = propertyId === CSSPropertyID.kVariable ? propertyName : null;
  //   // return fromString(propertyId, customPropertyName, value);
  //   return [];
  // }
  var stringToUnitType = function stringToUnitType(name) {
    return data.find(function (item) {
      return item.name === name;
    }).unit_type;
  };
  var unitFromName = function unitFromName(name) {
    if (!name) {
      return UnitType.kUnknown;
    }
    if (name === 'number') {
      return UnitType.kNumber;
    }
    if (name === 'percent' || name === '%') {
      return UnitType.kPercentage;
    }
    return stringToUnitType(name);
  };
  var unitTypeToUnitCategory = function unitTypeToUnitCategory(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return UnitCategory.kUNumber;
      case UnitType.kPercentage:
        return UnitCategory.kUPercent;
      case UnitType.kPixels:
        // case UnitType.kCentimeters:
        // case UnitType.kMillimeters:
        // case UnitType.kQuarterMillimeters:
        // case UnitType.kInches:
        // case UnitType.kPoints:
        // case UnitType.kPicas:
        // case UnitType.kUserUnits:
        return UnitCategory.kULength;
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
        return UnitCategory.kUTime;
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kTurns:
        return UnitCategory.kUAngle;
      // case UnitType.kHertz:
      // case UnitType.kKilohertz:
      //   return UnitCategory.kUFrequency;
      // case UnitType.kDotsPerPixel:
      // case UnitType.kDotsPerInch:
      // case UnitType.kDotsPerCentimeter:
      //   return UnitCategory.kUResolution;
      default:
        return UnitCategory.kUOther;
    }
  };
  var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory(category) {
    // The canonical unit type is chosen according to the way
    // CSSPropertyParser.ValidUnit() chooses the default unit in each category
    // (based on unitflags).
    switch (category) {
      case UnitCategory.kUNumber:
        return UnitType.kNumber;
      case UnitCategory.kULength:
        return UnitType.kPixels;
      case UnitCategory.kUPercent:
        return UnitType.kPercentage;
      // return UnitType.kUnknown; // Cannot convert between numbers and percent.
      case UnitCategory.kUTime:
        return UnitType.kSeconds;
      case UnitCategory.kUAngle:
        return UnitType.kDegrees;
      // case UnitCategory.kUFrequency:
      //   return UnitType.kHertz;
      // case UnitCategory.kUResolution:
      //   return UnitType.kDotsPerPixel;
      default:
        return UnitType.kUnknown;
    }
  };
  /**
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/css_primitive_value.cc#353
   */
  var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor(unit_type) {
    var factor = 1.0;
    // FIXME: the switch can be replaced by an array of scale factors.
    switch (unit_type) {
      // These are "canonical" units in their respective categories.
      case UnitType.kPixels:
      // case UnitType.kUserUnits:
      case UnitType.kDegrees:
      case UnitType.kSeconds:
        // case UnitType.kHertz:
        break;
      case UnitType.kMilliseconds:
        factor = 0.001;
        break;
      // case UnitType.kCentimeters:
      //   // factor = kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kDotsPerCentimeter:
      //   // factor = 1 / kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kMillimeters:
      //   // factor = kCssPixelsPerMillimeter;
      //   break;
      // case UnitType.kQuarterMillimeters:
      //   // factor = kCssPixelsPerQuarterMillimeter;
      //   break;
      // case UnitType.kInches:
      //   // factor = kCssPixelsPerInch;
      //   break;
      // case UnitType.kDotsPerInch:
      //   // factor = 1 / kCssPixelsPerInch;
      //   break;
      // case UnitType.kPoints:
      //   // factor = kCssPixelsPerPoint;
      //   break;
      // case UnitType.kPicas:
      //   // factor = kCssPixelsPerPica;
      //   break;
      case UnitType.kRadians:
        factor = 180 / Math.PI;
        break;
      case UnitType.kGradians:
        factor = 0.9;
        break;
      case UnitType.kTurns:
        factor = 360;
        break;
    }
    return factor;
  };
  var unitTypeToString = function unitTypeToString(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        // case UnitType.kUserUnits:
        return '';
      case UnitType.kPercentage:
        return '%';
      case UnitType.kEms:
        // case UnitType.kQuirkyEms:
        return 'em';
      // case UnitType.kExs:
      //   return 'ex';
      case UnitType.kRems:
        return 'rem';
      // case UnitType.kChs:
      //   return 'ch';
      case UnitType.kPixels:
        return 'px';
      // case UnitType.kCentimeters:
      //   return 'cm';
      // case UnitType.kDotsPerPixel:
      //   return 'dppx';
      // case UnitType.kDotsPerInch:
      //   return 'dpi';
      // case UnitType.kDotsPerCentimeter:
      //   return 'dpcm';
      // case UnitType.kMillimeters:
      //   return 'mm';
      // case UnitType.kQuarterMillimeters:
      //   return 'q';
      // case UnitType.kInches:
      //   return 'in';
      // case UnitType.kPoints:
      //   return 'pt';
      // case UnitType.kPicas:
      //   return 'pc';
      case UnitType.kDegrees:
        return 'deg';
      case UnitType.kRadians:
        return 'rad';
      case UnitType.kGradians:
        return 'grad';
      case UnitType.kMilliseconds:
        return 'ms';
      case UnitType.kSeconds:
        return 's';
      // case UnitType.kHertz:
      //   return 'hz';
      // case UnitType.kKilohertz:
      //   return 'khz';
      case UnitType.kTurns:
        return 'turn';
    }
    return '';
  };
  /**
   * CSSStyleValue is the base class for all CSS values accessible from Typed OM.
   * Values that are not yet supported as specific types are also returned as base CSSStyleValues.
   *
   * Spec @see https://drafts.css-houdini.org/css-typed-om/#stylevalue-objects
   * Docs @see https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleValue
   */
  var CSSStyleValue = /*#__PURE__*/function () {
    function CSSStyleValue() {}
    // static parse(propertyName: string, value: string): CSSStyleValue {
    //   return parseCSSStyleValue(propertyName, value)[0];
    // }
    // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
    //   return parseCSSStyleValue(propertyName, value);
    // }
    CSSStyleValue.isAngle = function isAngle(unit) {
      return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
    }
    // static isViewportPercentageLength(type: UnitType) {
    //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
    // }
    // static isContainerPercentageLength(type: UnitType) {
    //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
    // }
    ;
    CSSStyleValue.isLength = function isLength(type) {
      // return (type >= UnitType.kEms && type <= UnitType.kUserUnits) || type == UnitType.kQuirkyEms;
      return type >= UnitType.kEms && type < UnitType.kDegrees;
    };
    CSSStyleValue.isRelativeUnit = function isRelativeUnit(type) {
      return type === UnitType.kPercentage || type === UnitType.kEms ||
      // type === UnitType.kExs ||
      type === UnitType.kRems
      // type === UnitType.kChs ||
      // this.isViewportPercentageLength(type) ||
      // this.isContainerPercentageLength(type)
      ;
    };
    CSSStyleValue.isTime = function isTime(unit) {
      return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
    }
    // protected abstract toCSSValue(): CSSValue;
    ;
    var _proto = CSSStyleValue.prototype;
    _proto.toString = function toString() {
      return this.buildCSSText(Nested.kNo, ParenLess.kNo, '');
    };
    _proto.isNumericValue = function isNumericValue() {
      return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
    };
    return CSSStyleValue;
  }();

  /**
   * CSSColorValue is the base class used for the various CSS color interfaces.
   *
   * @see https://drafts.css-houdini.org/css-typed-om-1/#colorvalue-objects
   */
  var CSSColorValue = /*#__PURE__*/function (_CSSStyleValue) {
    _inheritsLoose(CSSColorValue, _CSSStyleValue);
    function CSSColorValue(colorSpace) {
      var _this;
      _this = _CSSStyleValue.call(this) || this;
      _this.colorSpace = void 0;
      _this.colorSpace = colorSpace;
      return _this;
    }
    var _proto = CSSColorValue.prototype;
    _proto.getType = function getType() {
      return CSSStyleValueType.kColorType;
    }
    // buildCSSText(n: Nested, p: ParenLess, result: string): string {
    //   let text = '';
    //   if (this.colorSpace === 'rgb') {
    //     text = `rgba(${this.channels.join(',')},${this.alpha})`;
    //   }
    //   return (result += text);
    // }
    /**
     * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
     */;
    _proto.to = function to(colorSpace) {
      return this;
    };
    return CSSColorValue;
  }(CSSStyleValue);

  var GradientType;
  (function (GradientType) {
    GradientType[GradientType["Constant"] = 0] = "Constant";
    GradientType[GradientType["LinearGradient"] = 1] = "LinearGradient";
    GradientType[GradientType["RadialGradient"] = 2] = "RadialGradient";
  })(GradientType || (GradientType = {}));
  var CSSGradientValue = /*#__PURE__*/function (_CSSStyleValue) {
    _inheritsLoose(CSSGradientValue, _CSSStyleValue);
    function CSSGradientValue(type, value) {
      var _this;
      _this = _CSSStyleValue.call(this) || this;
      _this.type = void 0;
      _this.value = void 0;
      _this.type = type;
      _this.value = value;
      return _this;
    }
    var _proto = CSSGradientValue.prototype;
    _proto.clone = function clone() {
      return new CSSGradientValue(this.type, this.value);
    };
    _proto.buildCSSText = function buildCSSText(n, p, result) {
      return result;
    };
    _proto.getType = function getType() {
      return CSSStyleValueType.kColorType;
    };
    return CSSGradientValue;
  }(CSSStyleValue);

  /**
   * CSSKeywordValue represents CSS Values that are specified as keywords
   * eg. 'initial'
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSKeywordValue
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_keyword_value.idl
   */
  var CSSKeywordValue = /*#__PURE__*/function (_CSSStyleValue) {
    _inheritsLoose(CSSKeywordValue, _CSSStyleValue);
    function CSSKeywordValue(value) {
      var _this;
      _this = _CSSStyleValue.call(this) || this;
      _this.value = void 0;
      _this.value = value;
      return _this;
    }
    var _proto = CSSKeywordValue.prototype;
    _proto.clone = function clone() {
      return new CSSKeywordValue(this.value);
    };
    _proto.getType = function getType() {
      return CSSStyleValueType.kKeywordType;
    };
    _proto.buildCSSText = function buildCSSText(n, p, result) {
      return result + this.value;
    };
    return CSSKeywordValue;
  }(CSSStyleValue);

  function memoize(func, resolver) {
    if (typeof func !== 'function' || resolver != null && typeof resolver !== 'function') {
      throw new TypeError('Expected a function');
    }
    var memoized = function memoized() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || Map)();
    return memoized;
  }
  memoize.Cache = Map;

  var camelCase = memoize(function (str) {
    if (str === void 0) {
      str = '';
    }
    return str.replace(/-([a-z])/g, function (g) {
      return g[1].toUpperCase();
    });
  });
  var kebabize = function kebabize(str) {
    return str.split('').map(function (letter, idx) {
      return letter.toUpperCase() === letter ? "" + (idx !== 0 ? '-' : '') + letter.toLowerCase() : letter;
    }).join('');
  };

  function DCHECK(bool) {
    if (!bool) {
      throw new Error();
    }
  }
  function isFunction$1(func) {
    return typeof func === 'function';
  }
  function isSymbol(value) {
    // @see https://github.com/lodash/lodash/blob/master/isSymbol.js
    return typeof value === 'symbol';
  }
  var definedProps = function definedProps(obj) {
    return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
      var v = _ref[1];
      return v !== undefined;
    }));
  };
  var FORMAT_ATTR_MAP = {
    d: {
      alias: 'path'
    },
    strokeDasharray: {
      alias: 'lineDash'
    },
    strokeWidth: {
      alias: 'lineWidth'
    },
    textAnchor: {
      alias: 'textAlign'
    },
    src: {
      alias: 'img'
    }
  };
  var formatAttributeName = memoize(function (name) {
    var attributeName = camelCase(name);
    var map = FORMAT_ATTR_MAP[attributeName];
    attributeName = (map === null || map === void 0 ? void 0 : map.alias) || attributeName;
    return attributeName;
  });

  // type CSSNumericBaseType =
  //   | 'length'
  //   | 'angle'
  //   | 'time'
  //   | 'frequency'
  //   | 'resolution'
  //   | 'flex'
  //   | 'percent';
  // https://drafts.css-houdini.org/css-typed-om/#dictdef-cssnumerictype
  // interface CSSNumericType {
  //   length: number;
  //   angle: number;
  //   time: number;
  //   frequency: number;
  //   resolution: number;
  //   flex: number;
  //   percent: number;
  //   percentHint: CSSNumericBaseType;
  // }
  var formatInfinityOrNaN = function formatInfinityOrNaN(number, suffix) {
    if (suffix === void 0) {
      suffix = '';
    }
    var result = '';
    if (!Number.isFinite(number)) {
      if (number > 0) result = 'infinity';else result = '-infinity';
    } else {
      DCHECK(Number.isNaN(number));
      result = 'NaN';
    }
    return result += suffix;
  };
  var toCanonicalUnit = function toCanonicalUnit(unit) {
    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
  };
  /**
   * CSSNumericValue is the base class for numeric and length typed CSS Values.
   * @see https://drafts.css-houdini.org/css-typed-om/#numeric-objects
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSSNumericValue
   * @see https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/css/cssom/css_numeric_value.idl
   */
  /**
   * Represents numeric values that can be expressed as a single number plus a
   * unit (or a naked number or percentage).
   * @see https://drafts.css-houdini.org/css-typed-om/#cssunitvalue
   */
  var CSSUnitValue = /*#__PURE__*/function (_CSSStyleValue) {
    _inheritsLoose(CSSUnitValue, _CSSStyleValue);
    function CSSUnitValue(value, unitOrName) {
      var _this;
      if (unitOrName === void 0) {
        unitOrName = UnitType.kNumber;
      }
      _this = _CSSStyleValue.call(this) || this;
      _this.unit = void 0;
      _this.value = void 0;
      var unit;
      if (typeof unitOrName === 'string') {
        unit = unitFromName(unitOrName);
      } else {
        unit = unitOrName;
      }
      _this.unit = unit;
      _this.value = value;
      return _this;
    }
    var _proto = CSSUnitValue.prototype;
    _proto.clone = function clone() {
      return new CSSUnitValue(this.value, this.unit);
    };
    _proto.equals = function equals(other) {
      var other_unit_value = other;
      return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
    };
    _proto.getType = function getType() {
      return CSSStyleValueType.kUnitType;
    };
    _proto.convertTo = function convertTo(target_unit) {
      if (this.unit === target_unit) {
        return new CSSUnitValue(this.value, this.unit);
      }
      // Instead of defining the scale factors for every unit to every other unit,
      // we simply convert to the canonical unit and back since we already have
      // the scale factors for canonical units.
      var canonical_unit = toCanonicalUnit(this.unit);
      if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
        return null;
      }
      var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
      return new CSSUnitValue(this.value * scale_factor, target_unit);
    };
    _proto.buildCSSText = function buildCSSText(n, p, result) {
      var text;
      switch (this.unit) {
        case UnitType.kUnknown:
          // FIXME
          break;
        case UnitType.kInteger:
          text = Number(this.value).toFixed(0);
          break;
        case UnitType.kNumber:
        case UnitType.kPercentage:
        case UnitType.kEms:
        // case UnitType.kQuirkyEms:
        // case UnitType.kExs:
        case UnitType.kRems:
        // case UnitType.kChs:
        case UnitType.kPixels:
        // case UnitType.kCentimeters:
        // case UnitType.kDotsPerPixel:
        // case UnitType.kDotsPerInch:
        // case UnitType.kDotsPerCentimeter:
        // case UnitType.kMillimeters:
        // case UnitType.kQuarterMillimeters:
        // case UnitType.kInches:
        // case UnitType.kPoints:
        // case UnitType.kPicas:
        // case UnitType.kUserUnits:
        case UnitType.kDegrees:
        case UnitType.kRadians:
        case UnitType.kGradians:
        case UnitType.kMilliseconds:
        case UnitType.kSeconds:
        // case UnitType.kHertz:
        // case UnitType.kKilohertz:
        case UnitType.kTurns:
          // case UnitType.kContainerMax: { // case UnitType.kContainerMin: // case UnitType.kContainerBlockSize: // case UnitType.kContainerInlineSize: // case UnitType.kContainerHeight: // case UnitType.kContainerWidth: // case UnitType.kDynamicViewportMax: // case UnitType.kDynamicViewportMin: // case UnitType.kDynamicViewportBlockSize: // case UnitType.kDynamicViewportInlineSize: // case UnitType.kDynamicViewportHeight: // case UnitType.kDynamicViewportWidth: // case UnitType.kLargeViewportMax: // case UnitType.kLargeViewportMin: // case UnitType.kLargeViewportBlockSize: // case UnitType.kLargeViewportInlineSize: // case UnitType.kLargeViewportHeight: // case UnitType.kLargeViewportWidth: // case UnitType.kSmallViewportMax: // case UnitType.kSmallViewportMin: // case UnitType.kSmallViewportBlockSize: // case UnitType.kSmallViewportInlineSize: // case UnitType.kSmallViewportHeight: // case UnitType.kSmallViewportWidth: // case UnitType.kViewportMax: // case UnitType.kViewportMin: // case UnitType.kViewportBlockSize: // case UnitType.kViewportInlineSize: // case UnitType.kViewportHeight: // case UnitType.kViewportWidth: // case UnitType.kFraction:
          {
            var kMinInteger = -999999;
            var kMaxInteger = 999999;
            var value = this.value;
            var unit = unitTypeToString(this.unit);
            if (value < kMinInteger || value > kMaxInteger) {
              var _unit = unitTypeToString(this.unit);
              if (!Number.isFinite(value) || Number.isNaN(value)) {
                text = formatInfinityOrNaN(value, _unit);
              } else {
                text = value + (_unit || '');
              }
            } else {
              text = "" + value + unit;
            }
          }
      }
      result += text;
      return result;
    };
    return CSSUnitValue;
  }(CSSStyleValue);
  var Opx = new CSSUnitValue(0, 'px');
  var Lpx = new CSSUnitValue(1, 'px');
  var Odeg = new CSSUnitValue(0, 'deg');

  /**
   * The CSSRGB class represents the CSS rgb()/rgba() functions.
   *
   * @see https://drafts.css-houdini.org/css-typed-om-1/#cssrgb
   */
  var CSSRGB = /*#__PURE__*/function (_CSSColorValue) {
    _inheritsLoose(CSSRGB, _CSSColorValue);
    function CSSRGB(r, g, b, alpha,
    /**
     * 'transparent' & 'none' has the same rgba data
     */
    isNone) {
      var _this;
      if (alpha === void 0) {
        alpha = 1;
      }
      if (isNone === void 0) {
        isNone = false;
      }
      _this = _CSSColorValue.call(this, 'rgb') || this;
      _this.r = void 0;
      _this.g = void 0;
      _this.b = void 0;
      _this.alpha = void 0;
      _this.isNone = void 0;
      _this.r = r;
      _this.g = g;
      _this.b = b;
      _this.alpha = alpha;
      _this.isNone = isNone;
      return _this;
    }
    var _proto = CSSRGB.prototype;
    _proto.clone = function clone() {
      return new CSSRGB(this.r, this.g, this.b, this.alpha);
    };
    _proto.buildCSSText = function buildCSSText(n, p, result) {
      return result + ("rgba(" + this.r + "," + this.g + "," + this.b + "," + this.alpha + ")");
    };
    return CSSRGB;
  }(CSSColorValue);

  /**
   * holds useful CSS-related methods.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS
   *
   * * CSS Typed OM @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/factory_functions
   * * register property @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
   * * CSS Layout API
   */
  var CSS = {
    /**
     * <number>
     * @see https://drafts.csswg.org/css-values-4/#number-value
     */
    number: function number(n) {
      return new CSSUnitValue(n);
    },
    /**
     * <percentage>
     * @see https://drafts.csswg.org/css-values-4/#percentage-value
     */
    percent: function percent(n) {
      return new CSSUnitValue(n, '%');
    },
    /**
     * <length>
     */
    px: function px(n) {
      return new CSSUnitValue(n, 'px');
    },
    /**
     * <length>
     */
    em: function em(n) {
      return new CSSUnitValue(n, 'em');
    },
    rem: function rem(n) {
      return new CSSUnitValue(n, 'rem');
    },
    /**
     * <angle>
     */
    deg: function deg(n) {
      return new CSSUnitValue(n, 'deg');
    },
    /**
     * <angle>
     */
    grad: function grad(n) {
      return new CSSUnitValue(n, 'grad');
    },
    /**
     * <angle>
     */
    rad: function rad(n) {
      return new CSSUnitValue(n, 'rad');
    },
    /**
     * <angle>
     */
    turn: function turn(n) {
      return new CSSUnitValue(n, 'turn');
    },
    /**
     * <time>
     */
    s: function s(n) {
      return new CSSUnitValue(n, 's');
    },
    /**
     * <time>
     */
    ms: function ms(n) {
      return new CSSUnitValue(n, 'ms');
    },
    /**
     * CSS Properties & Values API
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
     * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
     */
    registerProperty: function registerProperty(definition) {
      var name = definition.name,
        inherits = definition.inherits,
        interpolable = definition.interpolable,
        initialValue = definition.initialValue,
        syntax = definition.syntax;
      runtime.styleValueRegistry.registerMetadata({
        n: name,
        inh: inherits,
        int: interpolable,
        d: initialValue,
        syntax: syntax
      });
    },
    /**
     * CSS Layout API
     * register layout
     *
     * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
     */
    registerLayout: function registerLayout(name, clazz) {
      runtime.layoutRegistry.registerLayout(name, clazz);
    }
  };

  /**
   * CSSKeywordValue
   */
  var unsetKeywordValue = new CSSKeywordValue('unset');
  var initialKeywordValue = new CSSKeywordValue('initial');
  var inheritKeywordValue = new CSSKeywordValue('inherit');
  var keywordCache = {
    '': unsetKeywordValue,
    unset: unsetKeywordValue,
    initial: initialKeywordValue,
    inherit: inheritKeywordValue
  };
  var getOrCreateKeyword = function getOrCreateKeyword(name) {
    if (!keywordCache[name]) {
      keywordCache[name] = new CSSKeywordValue(name);
    }
    return keywordCache[name];
  };
  /**
   * CSSColor
   */
  var noneColor = new CSSRGB(0, 0, 0, 0, true);
  var transparentColor = new CSSRGB(0, 0, 0, 0);
  var getOrCreateRGBA = memoize(function (r, g, b, a) {
    return new CSSRGB(r, g, b, a);
  }, function (r, g, b, a) {
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  });
  // export const getOrCreateUnitValue = memoize(
  //   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
  //     return new CSSUnitValue(value, unitOrName);
  //   },
  //   (value: number, unitOrName: UnitType | string = UnitType.kNumber) => {
  //     return `${value}${unitOrName}`;
  //   },
  // );
  var getOrCreateUnitValue = function getOrCreateUnitValue(value, unitOrName) {
    if (unitOrName === void 0) {
      unitOrName = UnitType.kNumber;
    }
    return new CSSUnitValue(value, unitOrName);
  };
  var PECENTAGE_50 = new CSSUnitValue(50, '%');

  var canvasMap = {};
  var defaultCanvasIdCounter = 0;
  /**
   * destroy existed canvas with the same id
   */
  function cleanExistedCanvas(container, canvas) {
    if (container) {
      var id = typeof container === 'string' ? container : container.id || defaultCanvasIdCounter++;
      if (canvasMap[id]) {
        canvasMap[id].destroy();
      }
      canvasMap[id] = canvas;
    }
  }
  var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

  function sortByZIndex(o1, o2) {
    var zIndex1 = Number(o1.parsedStyle.zIndex);
    var zIndex2 = Number(o2.parsedStyle.zIndex);
    if (zIndex1 === zIndex2) {
      // return o1.entity.getComponent(Sortable).lastSortedIndex - o2.entity.getComponent(Sortable).lastSortedIndex;
      var parent = o1.parentNode;
      if (parent) {
        var children = parent.childNodes || [];
        return children.indexOf(o1) - children.indexOf(o2);
      }
    }
    return zIndex1 - zIndex2;
  }
  function findClosestClipPathTarget(object) {
    var el = object;
    do {
      var _el$parsedStyle;
      var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
      if (clipPath) return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  function getStyle($el, property) {
    if (isBrowser) {
      return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
    }
  }
  function getWidth($el) {
    var width = getStyle($el, 'width');
    if (width === 'auto') {
      return $el.offsetWidth;
    }
    return parseFloat(width);
  }
  function getHeight($el) {
    var height = getStyle($el, 'height');
    if (height === 'auto') {
      return $el.offsetHeight;
    }
    return parseFloat(height);
  }

  var ERROR_MSG_METHOD_NOT_IMPLEMENTED = 'Method not implemented.';
  var ERROR_MSG_USE_DOCUMENT_ELEMENT = 'Use document.documentElement instead.';
  var ERROR_MSG_APPEND_DESTROYED_ELEMENT = 'Cannot append a destroyed element.';

  // borrow from hammer.js
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: 'pointerdown',
    touchend: 'pointerup',
    touchendoutside: 'pointerupoutside',
    touchmove: 'pointermove',
    touchcancel: 'pointercancel'
  };

  function copyVec3(a, b) {
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    return a;
  }
  function subVec3(o, a, b) {
    o[0] = a[0] - b[0];
    o[1] = a[1] - b[1];
    o[2] = a[2] - b[2];
    return o;
  }
  function addVec3(o, a, b) {
    o[0] = a[0] + b[0];
    o[1] = a[1] + b[1];
    o[2] = a[2] + b[2];
    return o;
  }
  function scaleVec3(o, a, b) {
    o[0] = a[0] * b;
    o[1] = a[1] * b;
    o[2] = a[2] * b;
    return o;
  }
  function maxVec3(o, a, b) {
    o[0] = Math.max(a[0], b[0]);
    o[1] = Math.max(a[1], b[1]);
    o[2] = Math.max(a[2], b[2]);
    return o;
  }
  function minVec3(o, a, b) {
    o[0] = Math.min(a[0], b[0]);
    o[1] = Math.min(a[1], b[1]);
    o[2] = Math.min(a[2], b[2]);
    return o;
  }
  function getAngle$1(angle) {
    if (angle === undefined) {
      return 0;
    } else if (angle > 360 || angle < -360) {
      return angle % 360;
    }
    return angle;
  }
  function createVec3(x, y, z) {
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (Array.isArray(x) && x.length === 3) {
      return clone$1(x);
    }
    if (isNumber(x)) {
      return fromValues$2(x, y, z);
    }
    return fromValues$2(x[0], x[1] || y, x[2] || z);
  }
  function deg2rad(deg) {
    return deg * (Math.PI / 180);
  }
  function rad2deg(rad) {
    return rad * (180 / Math.PI);
  }
  function turn2deg(turn) {
    return 360 * turn;
  }
  function getEulerFromQuat(out, quat) {
    var x = quat[0];
    var y = quat[1];
    var z = quat[2];
    var w = quat[3];
    var x2 = x * x;
    var y2 = y * y;
    var z2 = z * z;
    var w2 = w * w;
    var unit = x2 + y2 + z2 + w2;
    var test = x * w - y * z;
    if (test > 0.499995 * unit) {
      // TODO: Use glmatrix.EPSILON
      // singularity at the north pole
      out[0] = Math.PI / 2;
      out[1] = 2 * Math.atan2(y, x);
      out[2] = 0;
    } else if (test < -0.499995 * unit) {
      //TODO: Use glmatrix.EPSILON
      // singularity at the south pole
      out[0] = -Math.PI / 2;
      out[1] = 2 * Math.atan2(y, x);
      out[2] = 0;
    } else {
      out[0] = Math.asin(2 * (x * z - w * y));
      out[1] = Math.atan2(2 * (x * w + y * z), 1 - 2 * (z2 + w2));
      out[2] = Math.atan2(2 * (x * y + z * w), 1 - 2 * (y2 + z2));
    }
    // TODO: Return them as degrees and not as radians
    return out;
  }
  function getEulerFromMat4(out, m) {
    var x;
    var z;
    var halfPi = Math.PI * 0.5;
    var _mat4$getScaling = getScaling(create$2(), m),
      sx = _mat4$getScaling[0],
      sy = _mat4$getScaling[1],
      sz = _mat4$getScaling[2];
    var y = Math.asin(-m[2] / sx);
    if (y < halfPi) {
      if (y > -halfPi) {
        x = Math.atan2(m[6] / sy, m[10] / sz);
        z = Math.atan2(m[1] / sx, m[0] / sx);
      } else {
        // Not a unique solution
        z = 0;
        x = -Math.atan2(m[4] / sy, m[5] / sy);
      }
    } else {
      // Not a unique solution
      z = 0;
      x = Math.atan2(m[4] / sy, m[5] / sy);
    }
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * @see https://github.com/toji/gl-matrix/issues/329
   * @see https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/rotation_conventions
   */
  function getEuler(out, quat) {
    if (quat.length === 16) {
      return getEulerFromMat4(out, quat);
    } else {
      return getEulerFromQuat(out, quat);
    }
  }
  function fromRotationTranslationScale$1(rotation, x, y, scaleX, scaleY) {
    var cos = Math.cos(rotation);
    var sin = Math.sin(rotation);
    return fromValues(scaleX * cos, scaleY * sin, 0, -scaleX * sin, scaleY * cos, 0, x, y, 1);
  }
  function makePerspective(out, left, right, top, bottom, near, far) {
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    out[0] = x;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y;
    out[6] = 0;
    out[7] = 0;
    out[8] = a;
    out[9] = b;
    out[10] = c;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = d;
    out[15] = 0;
    return out;
  }
  function decompose(mat) {
    var row0x = mat[0];
    var row0y = mat[1];
    var row1x = mat[3];
    var row1y = mat[4];
    // decompose 3x3 matrix
    // @see https://www.w3.org/TR/css-transforms-1/#decomposing-a-2d-matrix
    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
    // If determinant is negative, one axis was flipped.
    var determinant = row0x * row1y - row0y * row1x;
    if (determinant < 0) {
      // Flip axis with minimum unit vector dot product.
      if (row0x < row1y) {
        scalingX = -scalingX;
      } else {
        scalingY = -scalingY;
      }
    }
    // Renormalize matrix to remove scale.
    if (scalingX) {
      row0x *= 1 / scalingX;
      row0y *= 1 / scalingX;
    }
    if (scalingY) {
      row1x *= 1 / scalingY;
      row1y *= 1 / scalingY;
    }
    // Compute rotation and renormalize matrix.
    var rotation = Math.atan2(row0y, row0x);
    var angle = rad2deg(rotation);
    return [mat[6], mat[7], scalingX, scalingY, angle];
  }
  var tmp = create$1();
  var perspectiveMatrix = create$1();
  var tmpVec4 = create$3();
  var row = [create$2(), create$2(), create$2()];
  var pdum3 = create$2();
  /*
  Input:  matrix      ; a 4x4 matrix
  Output: translation ; a 3 component vector
          scale       ; a 3 component vector
          skew        ; skew factors XY,XZ,YZ represented as a 3 component vector
          perspective ; a 4 component vector
          quaternion  ; a 4 component vector
  Returns false if the matrix cannot be decomposed, true if it can


  References:
  https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js
  https://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc
  http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix
  */
  function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {
    //normalize, if not possible then bail out early
    if (!normalize$4(tmp, matrix)) return false;
    // perspectiveMatrix is used to solve for perspective, but it also provides
    // an easy way to test for singularity of the upper 3x3 component.
    copy(perspectiveMatrix, tmp);
    perspectiveMatrix[3] = 0;
    perspectiveMatrix[7] = 0;
    perspectiveMatrix[11] = 0;
    perspectiveMatrix[15] = 1;
    // If the perspectiveMatrix is not invertible, we are also unable to
    // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.
    if (Math.abs(determinant(perspectiveMatrix)) < 1e-8) return false;
    var a03 = tmp[3],
      a13 = tmp[7],
      a23 = tmp[11],
      a30 = tmp[12],
      a31 = tmp[13],
      a32 = tmp[14],
      a33 = tmp[15];
    // First, isolate perspective.
    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
      tmpVec4[0] = a03;
      tmpVec4[1] = a13;
      tmpVec4[2] = a23;
      tmpVec4[3] = a33;
      // Solve the equation by inverting perspectiveMatrix and multiplying
      // rightHandSide by the inverse.
      // resuing the perspectiveMatrix here since it's no longer needed
      var ret = invert(perspectiveMatrix, perspectiveMatrix);
      if (!ret) return false;
      transpose(perspectiveMatrix, perspectiveMatrix);
      //multiply by transposed inverse perspective matrix, into perspective vec4
      transformMat4$1(perspective, tmpVec4, perspectiveMatrix);
    } else {
      //no perspective
      perspective[0] = perspective[1] = perspective[2] = 0;
      perspective[3] = 1;
    }
    // Next take care of translation
    translation[0] = a30;
    translation[1] = a31;
    translation[2] = a32;
    // Now get scale and shear. 'row' is a 3 element array of 3 component vectors
    mat3from4(row, tmp);
    // Compute X scale factor and normalize first row.
    scale[0] = length(row[0]);
    normalize(row[0], row[0]);
    // Compute XY shear factor and make 2nd row orthogonal to 1st.
    skew[0] = dot(row[0], row[1]);
    combine(row[1], row[1], row[0], 1.0, -skew[0]);
    // Now, compute Y scale and normalize 2nd row.
    scale[1] = length(row[1]);
    normalize(row[1], row[1]);
    skew[0] /= scale[1];
    // Compute XZ and YZ shears, orthogonalize 3rd row
    skew[1] = dot(row[0], row[2]);
    combine(row[2], row[2], row[0], 1.0, -skew[1]);
    skew[2] = dot(row[1], row[2]);
    combine(row[2], row[2], row[1], 1.0, -skew[2]);
    // Next, get Z scale and normalize 3rd row.
    scale[2] = length(row[2]);
    normalize(row[2], row[2]);
    skew[1] /= scale[2];
    skew[2] /= scale[2];
    // At this point, the matrix (in rows) is orthonormal.
    // Check for a coordinate system flip.  If the determinant
    // is -1, then negate the matrix and the scaling factors.
    cross(pdum3, row[1], row[2]);
    if (dot(row[0], pdum3) < 0) {
      for (var i = 0; i < 3; i++) {
        scale[i] *= -1;
        row[i][0] *= -1;
        row[i][1] *= -1;
        row[i][2] *= -1;
      }
    }
    // Now, get the rotations out
    quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
    quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
    quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
    quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
    if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
    if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
    if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
    return true;
  }
  function normalize$4(out, mat) {
    var m44 = mat[15];
    // Cannot normalize.
    if (m44 === 0) return false;
    var scale = 1 / m44;
    for (var i = 0; i < 16; i++) out[i] = mat[i] * scale;
    return true;
  }
  //gets upper-left of a 4x4 matrix into a 3x3 of vectors
  function mat3from4(out, mat4x4) {
    out[0][0] = mat4x4[0];
    out[0][1] = mat4x4[1];
    out[0][2] = mat4x4[2];
    out[1][0] = mat4x4[4];
    out[1][1] = mat4x4[5];
    out[1][2] = mat4x4[6];
    out[2][0] = mat4x4[8];
    out[2][1] = mat4x4[9];
    out[2][2] = mat4x4[10];
  }
  function combine(out, a, b, scale1, scale2) {
    out[0] = a[0] * scale1 + b[0] * scale2;
    out[1] = a[1] * scale1 + b[1] * scale2;
    out[2] = a[2] * scale1 + b[2] * scale2;
  }
  var tmpMat4 = create$1();
  function parsedTransformToMat4(transform, object) {
    if (transform && transform.length) {
      var defX = 0;
      var defY = 0;
      if (object) {
        defX = object.parsedStyle.defX || 0;
        defY = object.parsedStyle.defY || 0;
        // reset transform
        object.resetLocalTransform();
        object.setLocalPosition(defX, defY);
      } else {
        object = new DisplayObject({});
      }
      transform.forEach(function (parsed) {
        var t = parsed.t,
          d = parsed.d;
        if (t === 'scale') {
          // scale(1) scale(1, 1)
          var newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [1, 1];
          object.scaleLocal(newScale[0], newScale[1], 1);
        } else if (t === 'scalex') {
          var _newScale = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [1];
          object.scaleLocal(_newScale[0], 1, 1);
        } else if (t === 'scaley') {
          var _newScale2 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [1];
          object.scaleLocal(1, _newScale2[0], 1);
        } else if (t === 'scalez') {
          var _newScale3 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [1];
          object.scaleLocal(1, 1, _newScale3[0]);
        } else if (t === 'scale3d') {
          var _newScale4 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [1, 1, 1];
          object.scaleLocal(_newScale4[0], _newScale4[1], _newScale4[2]);
        } else if (t === 'translate') {
          var newTranslation = d || [Opx, Opx];
          object.translateLocal(newTranslation[0].value, newTranslation[1].value, 0);
        } else if (t === 'translatex') {
          var _newTranslation = d || [Opx];
          object.translateLocal(_newTranslation[0].value, 0, 0);
        } else if (t === 'translatey') {
          var _newTranslation2 = d || [Opx];
          object.translateLocal(0, _newTranslation2[0].value, 0);
        } else if (t === 'translatez') {
          var _newTranslation3 = d || [Opx];
          object.translateLocal(0, 0, _newTranslation3[0].value);
        } else if (t === 'translate3d') {
          var _newTranslation4 = d || [Opx, Opx, Opx];
          object.translateLocal(_newTranslation4[0].value, _newTranslation4[1].value, _newTranslation4[2].value);
        } else if (t === 'rotate') {
          var newAngles = d || [Odeg];
          object.rotateLocal(0, 0, convertAngleUnit(newAngles[0]));
        } else if (t === 'rotatex') {
          var _newAngles = d || [Odeg];
          object.rotateLocal(convertAngleUnit(_newAngles[0]), 0, 0);
        } else if (t === 'rotatey') {
          var _newAngles2 = d || [Odeg];
          object.rotateLocal(0, convertAngleUnit(_newAngles2[0]), 0);
        } else if (t === 'rotatez') {
          var _newAngles3 = d || [Odeg];
          object.rotateLocal(0, 0, convertAngleUnit(_newAngles3[0]));
        } else if (t === 'rotate3d') ; else if (t === 'skew') {
          var newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [0, 0];
          object.setLocalSkew(deg2rad(newSkew[0]), deg2rad(newSkew[1]));
        } else if (t === 'skewx') {
          var _newSkew = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [0];
          object.setLocalSkew(deg2rad(_newSkew[0]), object.getLocalSkew()[1]);
        } else if (t === 'skewy') {
          var _newSkew2 = (d === null || d === void 0 ? void 0 : d.map(function (s) {
            return s.value;
          })) || [0];
          object.setLocalSkew(object.getLocalSkew()[0], deg2rad(_newSkew2[0]));
        } else if (t === 'matrix') {
          var _d$map = d.map(function (s) {
              return s.value;
            }),
            a = _d$map[0],
            b = _d$map[1],
            c = _d$map[2],
            dd = _d$map[3],
            tx = _d$map[4],
            ty = _d$map[5];
          object.setLocalTransform(set(tmpMat4, a, b, 0, 0, c, dd, 0, 0, 0, 0, 1, 0, tx + defX, ty + defY, 0, 1));
        } else if (t === 'matrix3d') {
          // @ts-ignore
          set.apply(mat4, [tmpMat4].concat(d.map(function (s) {
            return s.value;
          })));
          tmpMat4[12] += defX;
          tmpMat4[13] += defY;
          object.setLocalTransform(tmpMat4);
        }
      });
    }
    return object.getLocalTransform();
  }

  /**
   * borrow from gradient-parser, but we delete some browser compatible prefix such as `-webkit-`
   * @see https://github.com/rafaelcaricio/gradient-parser
   */
  function colorStopToString(colorStop) {
    var type = colorStop.type,
      value = colorStop.value;
    if (type === 'hex') {
      return "#" + value;
    } else if (type === 'literal') {
      return value;
    } else if (type === 'rgb') {
      return "rgb(" + value.join(',') + ")";
    } else {
      return "rgba(" + value.join(',') + ")";
    }
  }
  var parseGradient = function () {
    var tokens = {
      linearGradient: /^(linear\-gradient)/i,
      repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
      /**
       * @see https://projects.verou.me/conic-gradient/
       */
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /^\#([0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^rgb/i,
      rgbaColor: /^rgba/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    var input = '';
    function error(msg) {
      throw new Error(input + ': ' + msg);
    }
    function getAST() {
      var ast = matchListDefinitions();
      if (input.length > 0) {
        error('Invalid input not EOF');
      }
      return ast;
    }
    function matchListDefinitions() {
      return matchListing(matchDefinition);
    }
    function matchDefinition() {
      return matchGradient('linear-gradient', tokens.linearGradient, matchLinearOrientation) || matchGradient('repeating-linear-gradient', tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient('radial-gradient', tokens.radialGradient, matchListRadialOrientations) || matchGradient('repeating-radial-gradient', tokens.repeatingRadialGradient, matchListRadialOrientations) || matchGradient('conic-gradient', tokens.conicGradient, matchListRadialOrientations);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
      return matchCall(pattern, function (captures) {
        var orientation = orientationMatcher();
        if (orientation) {
          if (!scan(tokens.comma)) {
            error('Missing comma before color stops');
          }
        }
        return {
          type: gradientType,
          orientation: orientation,
          colorStops: matchListing(matchColorStop)
        };
      });
    }
    function matchCall(pattern, callback) {
      var captures = scan(pattern);
      if (captures) {
        if (!scan(tokens.startCall)) {
          error('Missing (');
        }
        var result = callback(captures);
        if (!scan(tokens.endCall)) {
          error('Missing )');
        }
        return result;
      }
    }
    function matchLinearOrientation() {
      return matchSideOrCorner() || matchAngle();
    }
    function matchSideOrCorner() {
      return match('directional', tokens.sideOrCorner, 1);
    }
    function matchAngle() {
      return match('angular', tokens.angleValue, 1);
    }
    function matchListRadialOrientations() {
      var radialOrientations,
        radialOrientation = matchRadialOrientation(),
        lookaheadCache;
      if (radialOrientation) {
        radialOrientations = [];
        radialOrientations.push(radialOrientation);
        lookaheadCache = input;
        if (scan(tokens.comma)) {
          radialOrientation = matchRadialOrientation();
          if (radialOrientation) {
            radialOrientations.push(radialOrientation);
          } else {
            input = lookaheadCache;
          }
        }
      }
      return radialOrientations;
    }
    function matchRadialOrientation() {
      var radialType = matchCircle() || matchEllipse();
      if (radialType) {
        // @ts-ignore
        radialType.at = matchAtPosition();
      } else {
        var extent = matchExtentKeyword();
        if (extent) {
          radialType = extent;
          var positionAt = matchAtPosition();
          if (positionAt) {
            // @ts-ignore
            radialType.at = positionAt;
          }
        } else {
          var defaultPosition = matchPositioning();
          if (defaultPosition) {
            radialType = {
              type: 'default-radial',
              // @ts-ignore
              at: defaultPosition
            };
          }
        }
      }
      return radialType;
    }
    function matchCircle() {
      var circle = match('shape', /^(circle)/i, 0);
      if (circle) {
        // @ts-ignore
        circle.style = matchLength() || matchExtentKeyword();
      }
      return circle;
    }
    function matchEllipse() {
      var ellipse = match('shape', /^(ellipse)/i, 0);
      if (ellipse) {
        // @ts-ignore
        ellipse.style = matchDistance() || matchExtentKeyword();
      }
      return ellipse;
    }
    function matchExtentKeyword() {
      return match('extent-keyword', tokens.extentKeywords, 1);
    }
    function matchAtPosition() {
      if (match('position', /^at/, 0)) {
        var positioning = matchPositioning();
        if (!positioning) {
          error('Missing positioning value');
        }
        return positioning;
      }
    }
    function matchPositioning() {
      var location = matchCoordinates();
      if (location.x || location.y) {
        return {
          type: 'position',
          value: location
        };
      }
    }
    function matchCoordinates() {
      return {
        x: matchDistance(),
        y: matchDistance()
      };
    }
    function matchListing(matcher) {
      var captures = matcher();
      var result = [];
      if (captures) {
        result.push(captures);
        while (scan(tokens.comma)) {
          captures = matcher();
          if (captures) {
            result.push(captures);
          } else {
            error('One extra comma');
          }
        }
      }
      return result;
    }
    function matchColorStop() {
      var color = matchColor();
      if (!color) {
        error('Expected color definition');
      }
      color.length = matchDistance();
      return color;
    }
    function matchColor() {
      return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
    }
    function matchLiteralColor() {
      return match('literal', tokens.literalColor, 0);
    }
    function matchHexColor() {
      return match('hex', tokens.hexColor, 1);
    }
    function matchRGBColor() {
      return matchCall(tokens.rgbColor, function () {
        return {
          type: 'rgb',
          value: matchListing(matchNumber)
        };
      });
    }
    function matchRGBAColor() {
      return matchCall(tokens.rgbaColor, function () {
        return {
          type: 'rgba',
          value: matchListing(matchNumber)
        };
      });
    }
    function matchNumber() {
      return scan(tokens.number)[1];
    }
    function matchDistance() {
      return match('%', tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
    }
    function matchPositionKeyword() {
      return match('position-keyword', tokens.positionKeywords, 1);
    }
    function matchLength() {
      return match('px', tokens.pixelValue, 1) || match('em', tokens.emValue, 1);
    }
    function match(type, pattern, captureIndex) {
      var captures = scan(pattern);
      if (captures) {
        return {
          type: type,
          value: captures[captureIndex]
        };
      }
    }
    function scan(regexp) {
      var blankCaptures = /^[\n\r\t\s]+/.exec(input);
      if (blankCaptures) {
        consume(blankCaptures[0].length);
      }
      var captures = regexp.exec(input);
      if (captures) {
        consume(captures[0].length);
      }
      return captures;
    }
    function consume(size) {
      input = input.substring(size);
    }
    return function (code) {
      input = code;
      return getAST();
    };
  }();
  function computeLinearGradient(width, height, angle) {
    var rad = deg2rad(angle.value);
    var rx = 0;
    var ry = 0;
    var rcx = rx + width / 2;
    var rcy = ry + height / 2;
    // get the length of gradient line
    // @see https://observablehq.com/@danburzo/css-gradient-line
    var length = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));
    var x1 = rcx - Math.cos(rad) * length / 2;
    var y1 = rcy - Math.sin(rad) * length / 2;
    var x2 = rcx + Math.cos(rad) * length / 2;
    var y2 = rcy + Math.sin(rad) * length / 2;
    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    };
  }
  function computeRadialGradient(width, height, cx, cy, size) {
    // 'px'
    var x = cx.value;
    var y = cy.value;
    // TODO: 'em'
    // '%'
    if (cx.unit === UnitType.kPercentage) {
      x = cx.value / 100 * width;
    }
    if (cy.unit === UnitType.kPercentage) {
      y = cy.value / 100 * height;
    }
    // default to farthest-side
    var r = Math.max(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
    if (size) {
      if (size instanceof CSSUnitValue) {
        r = size.value;
      } else if (size instanceof CSSKeywordValue) {
        // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients#example_closest-side_for_circles
        if (size.value === 'closest-side') {
          r = Math.min(x, width - x, y, height - y);
        } else if (size.value === 'farthest-side') {
          r = Math.max(x, width - x, y, height - y);
        } else if (size.value === 'closest-corner') {
          r = Math.min(distanceSquareRoot([0, 0], [x, y]), distanceSquareRoot([0, height], [x, y]), distanceSquareRoot([width, height], [x, y]), distanceSquareRoot([width, 0], [x, y]));
        }
      }
    }
    return {
      x: x,
      y: y,
      r: r
    };
  }

  var Shape;
  (function (Shape) {
    Shape["GROUP"] = "g";
    Shape["CIRCLE"] = "circle";
    Shape["ELLIPSE"] = "ellipse";
    Shape["IMAGE"] = "image";
    Shape["RECT"] = "rect";
    Shape["LINE"] = "line";
    Shape["POLYLINE"] = "polyline";
    Shape["POLYGON"] = "polygon";
    Shape["TEXT"] = "text";
    Shape["PATH"] = "path";
    Shape["HTML"] = "html";
    Shape["MESH"] = "mesh";
  })(Shape || (Shape = {}));

  function getOrCalculatePathTotalLength(path) {
    if (path.parsedStyle.path.totalLength === 0) {
      path.parsedStyle.path.totalLength = getTotalLength(path.parsedStyle.path.absolutePath);
    }
    return path.parsedStyle.path.totalLength;
  }
  function hasArcOrBezier(path) {
    var hasArc = false;
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
        hasArc = true;
        break;
      }
    }
    return hasArc;
  }
  function extractPolygons(pathArray) {
    var polygons = [];
    var polylines = [];
    var points = []; //  'M'
    for (var i = 0; i < pathArray.length; i++) {
      var params = pathArray[i];
      var cmd = params[0];
      if (cmd === 'M') {
        //  'M' 
        if (points.length) {
          //  'Z'
          polylines.push(points);
          points = []; // 
        }

        points.push([params[1], params[2]]);
      } else if (cmd === 'Z') {
        if (points.length) {
          // 
          polygons.push(points);
          points = []; // 
        }
        //  'Z'
      } else {
        points.push([params[1], params[2]]);
      }
    }
    //  points  polygons  polyline
    //  M Z 
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons: polygons,
      polylines: polylines
    };
  }
  function isSamePoint(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
  }
  function getPathBBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint;
      var box = void 0;
      switch (segment.command) {
        case 'Q':
          box = quadratic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case 'C':
          box = cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case 'A':
          var arcParams = segment.arcParams;
          box = arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box) {
        segment.box = box;
        xArr.push(box.x, box.x + box.width);
        yArr.push(box.y, box.y + box.height);
      }
      if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    // bbox calculation should ignore NaN for path attribute
    // ref: https://github.com/antvis/g/issues/210
    // ref: https://github.com/antvis/G2/issues/3109
    xArr = xArr.filter(function (item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    yArr = yArr.filter(function (item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    var minX = min$1(xArr);
    var minY = min$1(yArr);
    var maxX = max$1(xArr);
    var maxY = max$1(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
      var _segment = segmentsWithAngle[_i];
      var _currentPoint = _segment.currentPoint;
      var extra = void 0;
      if (_currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (_currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (_currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (_currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxY = maxY + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint,
      currentPoint = segment.currentPoint,
      nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    //  currentPoint 
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    //  0  PI 
    // :  0  0 
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    // 
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    // 
    // 
    var extra = {
      // 
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      // 
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  // 
  function toSymmetry(point, center) {
    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
  }
  var angleBetween$1 = function angleBetween(v0, v1) {
    var p = v0.x * v1.x + v0.y * v1.y;
    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
    var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
    var angle = sign * Math.acos(p / n);
    return angle;
  };
  /**
   * @see https://github.com/rveciana/svg-path-properties/blob/b6bd9a322966f6ef7a311872d80c56e3718de861/src/arc.ts#L121
   */
  var pointOnEllipticalArc = function pointOnEllipticalArc(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
    // In accordance to: http://www.w3.org/TR/SVG/implnote.html#ArcOutOfRangeParameters
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    xAxisRotation = mod(xAxisRotation, 360);
    var xAxisRotationRadians = deg2rad(xAxisRotation);
    // If the endpoints are identical, then this is equivalent to omitting the elliptical arc segment entirely.
    if (p0.x === p1.x && p0.y === p1.y) {
      return {
        x: p0.x,
        y: p0.y,
        ellipticalArcAngle: 0
      }; // Check if angle is correct
    }
    // If rx = 0 or ry = 0 then this arc is treated as a straight line segment joining the endpoints.
    if (rx === 0 || ry === 0) {
      //return this.pointOnLine(p0, p1, t);
      return {
        x: 0,
        y: 0,
        ellipticalArcAngle: 0
      }; // Check if angle is correct
    }
    // Following "Conversion from endpoint to center parameterization"
    // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter
    // Step #1: Compute transformedPoint
    var dx = (p0.x - p1.x) / 2;
    var dy = (p0.y - p1.y) / 2;
    var transformedPoint = {
      x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
      y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
    };
    // Ensure radii are large enough
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx = Math.sqrt(radiiCheck) * rx;
      ry = Math.sqrt(radiiCheck) * ry;
    }
    // Step #2: Compute transformedCenter
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    // Make sure this never drops below zero because of precision
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    // Step #3: Compute center
    var center = {
      x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
      y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
    };
    // Step #4: Compute start/sweep angles
    // Start angle of the elliptical arc prior to the stretch and rotate operations.
    // Difference between the start and end angles
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween$1({
      x: 1,
      y: 0
    }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween$1(startVector, endVector);
    if (!sweepFlag && sweepAngle > 0) {
      sweepAngle -= 2 * Math.PI;
    } else if (sweepFlag && sweepAngle < 0) {
      sweepAngle += 2 * Math.PI;
    }
    // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)
    sweepAngle %= 2 * Math.PI;
    // From http://www.w3.org/TR/SVG/implnote.html#ArcParameterizationAlternatives
    var angle = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * Math.cos(angle);
    var ellipseComponentY = ry * Math.sin(angle);
    var point = {
      x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center.x,
      y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center.y,
      ellipticalArcStartAngle: startAngle,
      ellipticalArcEndAngle: startAngle + sweepAngle,
      ellipticalArcAngle: angle,
      ellipticalArcCenter: center,
      resultantRx: rx,
      resultantRy: ry
    };
    return point;
  };
  function path2Segments(path) {
    var segments = [];
    var currentPoint = null; // 
    var nextParams = null; //  path 
    var startMovePoint = null; //  M 
    var lastStartMovePointIndex = 0; //  M 
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      nextParams = path[i + 1];
      var command = params[0];
      // 
      var segment = {
        command: command,
        prePoint: currentPoint,
        params: params,
        startTangent: null,
        endTangent: null,
        currentPoint: null,
        nextPoint: null,
        arcParams: null,
        box: null,
        cubicParams: null
      };
      switch (command) {
        case 'M':
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case 'A':
          var arcParams = getArcParams(currentPoint, params);
          segment.arcParams = arcParams;
          break;
      }
      if (command === 'Z') {
        //  Z  M 
        currentPoint = startMovePoint;
        //  Z M  M 
        nextParams = path[lastStartMovePointIndex + 1];
      } else {
        var len = params.length;
        currentPoint = [params[len - 2], params[len - 1]];
      }
      if (nextParams && nextParams[0] === 'Z') {
        //  Z M 
        nextParams = path[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          //  Z M 
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment.currentPoint = currentPoint;
      //  M  M 
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment.nextPoint = nextPoint;
      // Add startTangent and endTangent
      var prePoint = segment.prePoint;
      if (['L', 'H', 'V'].includes(command)) {
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      } else if (command === 'Q') {
        // 
        var cp = [params[1], params[2]];
        //  currentPoint
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === 'T') {
        var preSegment = segments[i - 1];
        var _cp = toSymmetry(preSegment.currentPoint, prePoint);
        if (preSegment.command === 'Q') {
          segment.command = 'Q';
          segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
          segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
        } else {
          // @ts-ignore
          segment.command = 'TL';
          segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
          segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
      } else if (command === 'C') {
        // 
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        // horizontal line, eg. ['C', 100, 100, 100, 100, 200, 200]
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === 'S') {
        var _preSegment = segments[i - 1];
        var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
        var _cp3 = [params[1], params[2]];
        if (_preSegment.command === 'C') {
          segment.command = 'C'; //  S  C 
          segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        } else {
          // @ts-ignore
          segment.command = 'SQ'; //  S  SQ 
          segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        }
      } else if (command === 'A') {
        var _getTangentAtRatio = getTangentAtRatio(segment, 0),
          dx1 = _getTangentAtRatio.x,
          dy1 = _getTangentAtRatio.y;
        var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false),
          dx2 = _getTangentAtRatio2.x,
          dy2 = _getTangentAtRatio2.y;
        segment.startTangent = [dx1, dy1];
        segment.endTangent = [dx2, dy2];
      }
      segments.push(segment);
    }
    return segments;
  }
  /**
   * Use length instead of ratio
   */
  function getTangentAtRatio(segment, ratio, sign) {
    if (sign === void 0) {
      sign = true;
    }
    var _segment$arcParams = segment.arcParams,
      _segment$arcParams$rx = _segment$arcParams.rx,
      rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx,
      _segment$arcParams$ry = _segment$arcParams.ry,
      ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry,
      xRotation = _segment$arcParams.xRotation,
      arcFlag = _segment$arcParams.arcFlag,
      sweepFlag = _segment$arcParams.sweepFlag;
    var p1 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, ratio);
    var p2 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, sign ? ratio + 0.005 : ratio - 0.005);
    var xDist = p2.x - p1.x;
    var yDist = p2.y - p1.y;
    var dist = Math.sqrt(xDist * xDist + yDist * yDist);
    return {
      x: -xDist / dist,
      y: -yDist / dist
    };
  }
  // 
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  // u.v/|u||v|
  function vRatio(u, v) {
    //  0  0 1
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  // 
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod(deg2rad(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    // 
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    // 
    var x2 = params[6];
    var y2 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    //  0  (0, 0) 
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    // 
    var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    // 
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    // 
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    //  x 
    var theta = vAngle([1, 0], u);
    // 
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx: cx,
      cy: cy,
      //  0 
      rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation: xRotation,
      arcFlag: arcFlag,
      sweepFlag: sweepFlag
    };
  }
  function commandsToPathString(commands, object, transform) {
    var _object$parsedStyle = object.parsedStyle,
      _object$parsedStyle$d = _object$parsedStyle.defX,
      defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d,
      _object$parsedStyle$d2 = _object$parsedStyle.defY,
      defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
    return commands.reduce(function (prev, cur) {
      var path = '';
      if (cur[0] === 'M' || cur[0] === 'L') {
        var p = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
        if (transform) {
          transformMat4(p, p, transform);
        }
        path = "" + cur[0] + p[0] + "," + p[1];
      } else if (cur[0] === 'Z') {
        path = cur[0];
      } else if (cur[0] === 'C') {
        var p1 = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
        var p2 = fromValues$2(cur[3] - defX, cur[4] - defY, 0);
        var p3 = fromValues$2(cur[5] - defX, cur[6] - defY, 0);
        if (transform) {
          transformMat4(p1, p1, transform);
          transformMat4(p2, p2, transform);
          transformMat4(p3, p3, transform);
        }
        path = "" + cur[0] + p1[0] + "," + p1[1] + "," + p2[0] + "," + p2[1] + "," + p3[0] + "," + p3[1];
      } else if (cur[0] === 'A') {
        var c = fromValues$2(cur[6] - defX, cur[7] - defY, 0);
        if (transform) {
          transformMat4(c, c, transform);
        }
        path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "," + cur[5] + "," + c[0] + "," + c[1];
      } else if (cur[0] === 'Q') {
        var _p = fromValues$2(cur[1] - defX, cur[2] - defY, 0);
        var _p2 = fromValues$2(cur[3] - defX, cur[4] - defY, 0);
        if (transform) {
          transformMat4(_p, _p, transform);
          transformMat4(_p2, _p2, transform);
        }
        path = "" + cur[0] + cur[1] + "," + cur[2] + "," + cur[3] + "," + cur[4] + "}";
      }
      return prev += path;
    }, '');
  }
  function lineToCommands(x1, y1, x2, y2) {
    return [['M', x1, y1], ['L', x2, y2]];
  }
  function ellipseToCommands(rx, ry, cx, cy) {
    var factor = (-1 + Math.sqrt(2)) / 3 * 4;
    var dx = rx * factor;
    var dy = ry * factor;
    var left = cx - rx;
    var right = cx + rx;
    var top = cy - ry;
    var bottom = cy + ry;
    return [['M', left, cy], ['C', left, cy - dy, cx - dx, top, cx, top], ['C', cx + dx, top, right, cy - dy, right, cy], ['C', right, cy + dy, cx + dx, bottom, cx, bottom], ['C', cx - dx, bottom, left, cy + dy, left, cy], ['Z']];
  }
  function polygonToCommands(points, closed) {
    var result = points.map(function (point, i) {
      return [i === 0 ? 'M' : 'L', point[0], point[1]];
    });
    if (closed) {
      result.push(['Z']);
    }
    return result;
  }
  function rectToCommands(width, height, x, y, radius) {
    // @see https://gist.github.com/danielpquinn/dd966af424030d47e476
    if (radius) {
      var tlr = radius[0],
        trr = radius[1],
        brr = radius[2],
        blr = radius[3];
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      // sweep-flag @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#arcs
      var sweepFlag = signX + signY !== 0 ? 1 : 0;
      return [['M', signX * tlr + x, y], ['L', width - signX * trr + x, y], trr ? ['A', trr, trr, 0, 0, sweepFlag, width + x, signY * trr + y] : null, ['L', width + x, height - signY * brr + y], brr ? ['A', brr, brr, 0, 0, sweepFlag, width + x - signX * brr, height + y] : null, ['L', x + signX * blr, height + y], blr ? ['A', blr, blr, 0, 0, sweepFlag, x, height + y - signY * blr] : null, ['L', x, signY * tlr + y], tlr ? ['A', tlr, tlr, 0, 0, sweepFlag, signX * tlr + x, y] : null, ['Z']].filter(function (command) {
        return command;
      });
    }
    return [['M', x, y], ['L', x + width, y], ['L', x + width, y + height], ['L', x, y + height], ['Z']];
  }
  /**
   * convert object to path, should account for:
   * * transform & origin
   * * anchor
   * * lineWidth
   */
  function convertToPath(object, transform) {
    if (transform === void 0) {
      transform = object.getLocalTransform();
    }
    var commands = [];
    switch (object.nodeName) {
      case Shape.LINE:
        var _object$parsedStyle2 = object.parsedStyle,
          x1 = _object$parsedStyle2.x1,
          y1 = _object$parsedStyle2.y1,
          x2 = _object$parsedStyle2.x2,
          y2 = _object$parsedStyle2.y2;
        commands = lineToCommands(x1, y1, x2, y2);
        break;
      case Shape.CIRCLE:
        {
          var _object$parsedStyle3 = object.parsedStyle,
            r = _object$parsedStyle3.r,
            cx = _object$parsedStyle3.cx,
            cy = _object$parsedStyle3.cy;
          commands = ellipseToCommands(r, r, cx, cy);
          break;
        }
      case Shape.ELLIPSE:
        {
          var _object$parsedStyle4 = object.parsedStyle,
            rx = _object$parsedStyle4.rx,
            ry = _object$parsedStyle4.ry,
            _cx = _object$parsedStyle4.cx,
            _cy = _object$parsedStyle4.cy;
          commands = ellipseToCommands(rx, ry, _cx, _cy);
          break;
        }
      case Shape.POLYLINE:
      case Shape.POLYGON:
        var points = object.parsedStyle.points;
        commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
        break;
      case Shape.RECT:
        var _object$parsedStyle5 = object.parsedStyle,
          width = _object$parsedStyle5.width,
          height = _object$parsedStyle5.height,
          x = _object$parsedStyle5.x,
          y = _object$parsedStyle5.y,
          radius = _object$parsedStyle5.radius;
        var hasRadius = radius && radius.some(function (r) {
          return r !== 0;
        });
        commands = rectToCommands(width, height, x, y, hasRadius && radius.map(function (r) {
          return clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
        }));
        break;
      case Shape.PATH:
        var absolutePath = object.parsedStyle.path.absolutePath;
        commands = [].concat(absolutePath);
        break;
    }
    if (commands.length) {
      return commandsToPathString(commands, object, transform);
    }
  }

  function isFillOrStrokeAffected(pointerEvents, fill, stroke) {
    // account for pointerEvents
    // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
    var hasFill = false;
    var hasStroke = false;
    var isFillOtherThanNone = !!fill && !fill.isNone;
    var isStrokeOtherThanNone = !!stroke && !stroke.isNone;
    if (pointerEvents === 'visiblepainted' || pointerEvents === 'painted' || pointerEvents === 'auto') {
      hasFill = isFillOtherThanNone;
      hasStroke = isStrokeOtherThanNone;
    } else if (pointerEvents === 'visiblefill' || pointerEvents === 'fill') {
      hasFill = true;
    } else if (pointerEvents === 'visiblestroke' || pointerEvents === 'stroke') {
      hasStroke = true;
    } else if (pointerEvents === 'visible' || pointerEvents === 'all') {
      // The values of the fill and stroke do not affect event processing.
      hasFill = true;
      hasStroke = true;
    }
    return [hasFill, hasStroke];
  }

  // @ts-nocheck
  // interface HookInterceptor<T, R, AdditionalOptions = UnsetAdditionalOptions> {
  //   name?: string;
  //   tap?: (tap: FullTap & IfSet<AdditionalOptions>) => void;
  //   call?: (...args: any[]) => void;
  //   loop?: (...args: any[]) => void;
  //   error?: (err: Error) => void;
  //   result?: (result: R) => void;
  //   done?: () => void;
  //   register?: (tap: FullTap & IfSet<AdditionalOptions>) => FullTap & IfSet<AdditionalOptions>;
  // }
  // type ArgumentNames<T extends any[]> = FixedSizeArray<T['length'], string>;
  // export declare class AsyncHook<T, R, AdditionalOptions = UnsetAdditionalOptions> extends Hook<
  //   T,
  //   R,
  //   AdditionalOptions
  // > {
  //   tapAsync(
  //     options: string | (Tap & IfSet<AdditionalOptions>),
  //     fn: (...args: Append<AsArray<T>, InnerCallback<Error, R>>) => void,
  //   ): void;
  //   tapPromise(
  //     options: string | (Tap & IfSet<AdditionalOptions>),
  //     fn: (...args: AsArray<T>) => Promise<R>,
  //   ): void;
  // }
  var CALL_DELEGATE = function CALL_DELEGATE() {
    this.call = this._createCall('sync');
    return this.call.apply(this, arguments);
  };
  var CALL_ASYNC_DELEGATE = function CALL_ASYNC_DELEGATE() {
    this.callAsync = this._createCall('async');
    return this.callAsync.apply(this, arguments);
  };
  var PROMISE_DELEGATE = function PROMISE_DELEGATE() {
    this.promise = this._createCall('promise');
    return this.promise.apply(this, arguments);
  };
  var Hook = /*#__PURE__*/function () {
    function Hook(args, name) {
      if (args === void 0) {
        args = [];
      }
      if (name === void 0) {
        name = undefined;
      }
      this.name = void 0;
      this.taps = void 0;
      this.promise = void 0;
      this._promise = void 0;
      this._args = args;
      this.name = name;
      this.taps = [];
      this.interceptors = [];
      this._call = CALL_DELEGATE;
      this.call = CALL_DELEGATE;
      this._callAsync = CALL_ASYNC_DELEGATE;
      this.callAsync = CALL_ASYNC_DELEGATE;
      this._promise = PROMISE_DELEGATE;
      this.promise = PROMISE_DELEGATE;
      this._x = undefined;
      // this.compile = this.compile;
      // this.tap = this.tap;
      // this.tapAsync = this.tapAsync;
      // this.tapPromise = this.tapPromise;
    }
    var _proto = Hook.prototype;
    _proto.compile = function compile(options) {
      throw new Error('Abstract: should be overridden');
    };
    _proto._createCall = function _createCall(type) {
      return this.compile({
        taps: this.taps,
        interceptors: this.interceptors,
        args: this._args,
        type: type
      });
    };
    _proto._tap = function _tap(type, options, fn) {
      if (typeof options === 'string') {
        options = {
          name: options.trim()
        };
      } else if (typeof options !== 'object' || options === null) {
        throw new Error('Invalid tap options');
      }
      if (typeof options.name !== 'string' || options.name === '') {
        throw new Error('Missing name for tap');
      }
      // if (typeof options.context !== "undefined") {
      // 	deprecateContext();
      // }
      options = Object.assign({
        type: type,
        fn: fn
      }, options);
      options = this._runRegisterInterceptors(options);
      this._insert(options);
    };
    _proto.tap = function tap(options, fn) {
      this._tap('sync', options, fn);
    };
    _proto.tapAsync = function tapAsync(options, fn) {
      this._tap('async', options, fn);
    };
    _proto.tapPromise = function tapPromise(options, fn) {
      this._tap('promise', options, fn);
    };
    _proto._runRegisterInterceptors = function _runRegisterInterceptors(options) {
      for (var _iterator = _createForOfIteratorHelperLoose(this.interceptors), _step; !(_step = _iterator()).done;) {
        var interceptor = _step.value;
        if (interceptor.register) {
          var newOptions = interceptor.register(options);
          if (newOptions !== undefined) {
            options = newOptions;
          }
        }
      }
      return options;
    };
    _proto.withOptions = function withOptions(options) {
      var _this = this;
      var mergeOptions = function mergeOptions(opt) {
        return Object.assign({}, options, typeof opt === 'string' ? {
          name: opt
        } : opt);
      };
      return {
        name: this.name,
        tap: function tap(opt, fn) {
          return _this.tap(mergeOptions(opt), fn);
        },
        tapAsync: function tapAsync(opt, fn) {
          return _this.tapAsync(mergeOptions(opt), fn);
        },
        tapPromise: function tapPromise(opt, fn) {
          return _this.tapPromise(mergeOptions(opt), fn);
        },
        // intercept: (interceptor) => this.intercept(interceptor),
        isUsed: function isUsed() {
          return _this.isUsed();
        },
        withOptions: function withOptions(opt) {
          return _this.withOptions(mergeOptions(opt));
        }
      };
    };
    _proto.isUsed = function isUsed() {
      return this.taps.length > 0 || this.interceptors.length > 0;
    }
    // intercept(interceptor: HookInterceptor<T, R, AdditionalOptions>) {
    //   this._resetCompilation();
    //   this.interceptors.push(Object.assign({}, interceptor));
    //   if (interceptor.register) {
    //     for (let i = 0; i < this.taps.length; i++) {
    //       this.taps[i] = interceptor.register(this.taps[i]);
    //     }
    //   }
    // }
    ;
    _proto._resetCompilation = function _resetCompilation() {
      this.call = this._call;
      this.callAsync = this._callAsync;
      this.promise = this._promise;
    };
    _proto._insert = function _insert(item) {
      this._resetCompilation();
      var before;
      if (typeof item.before === 'string') {
        before = new Set([item.before]);
      } else if (Array.isArray(item.before)) {
        before = new Set(item.before);
      }
      var stage = 0;
      if (typeof item.stage === 'number') {
        stage = item.stage;
      }
      var i = this.taps.length;
      while (i > 0) {
        i--;
        var x = this.taps[i];
        this.taps[i + 1] = x;
        var xStage = x.stage || 0;
        if (before) {
          if (before.has(x.name)) {
            before.delete(x.name);
            continue;
          }
          if (before.size > 0) {
            continue;
          }
        }
        if (xStage > stage) {
          continue;
        }
        i++;
        break;
      }
      this.taps[i] = item;
    };
    return Hook;
  }();
  // Object.setPrototypeOf(Hook.prototype, null);

  // @ts-nocheck
  var HookCodeFactory = /*#__PURE__*/function () {
    function HookCodeFactory(config) {
      this.config = config;
      this.options = undefined;
      this._args = undefined;
    }
    var _proto = HookCodeFactory.prototype;
    _proto.create = function create(options) {
      this.init(options);
      var fn;
      switch (this.options.type) {
        case 'sync':
          fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
            onError: function onError(err) {
              return "throw " + err + ";\n";
            },
            onResult: function onResult(result) {
              return "return " + result + ";\n";
            },
            resultReturns: true,
            onDone: function onDone() {
              return '';
            },
            rethrowIfPossible: true
          }));
          break;
        case 'async':
          fn = new Function(this.args({
            after: '_callback'
          }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
            onError: function onError(err) {
              return "_callback(" + err + ");\n";
            },
            onResult: function onResult(result) {
              return "_callback(null, " + result + ");\n";
            },
            onDone: function onDone() {
              return '_callback();\n';
            }
          }));
          break;
        case 'promise':
          var errorHelperUsed = false;
          var content = this.contentWithInterceptors({
            onError: function onError(err) {
              errorHelperUsed = true;
              return "_error(" + err + ");\n";
            },
            onResult: function onResult(result) {
              return "_resolve(" + result + ");\n";
            },
            onDone: function onDone() {
              return '_resolve();\n';
            }
          });
          var code = '';
          code += '"use strict";\n';
          code += this.header();
          code += 'return new Promise((function(_resolve, _reject) {\n';
          if (errorHelperUsed) {
            code += 'var _sync = true;\n';
            code += 'function _error(_err) {\n';
            code += 'if(_sync)\n';
            code += '_resolve(Promise.resolve().then((function() { throw _err; })));\n';
            code += 'else\n';
            code += '_reject(_err);\n';
            code += '};\n';
          }
          code += content;
          if (errorHelperUsed) {
            code += '_sync = false;\n';
          }
          code += '}));\n';
          fn = new Function(this.args(), code);
          break;
      }
      this.deinit();
      return fn;
    };
    _proto.setup = function setup(instance, options) {
      instance._x = options.taps.map(function (t) {
        return t.fn;
      });
    }
    /**
     * @param {{ type: "sync" | "promise" | "async", taps: Array<Tap>, interceptors: Array<Interceptor> }} options
     */;
    _proto.init = function init(options) {
      this.options = options;
      this._args = options.args.slice();
    };
    _proto.deinit = function deinit() {
      this.options = undefined;
      this._args = undefined;
    };
    _proto.contentWithInterceptors = function contentWithInterceptors(options) {
      var _this = this;
      if (this.options.interceptors.length > 0) {
        var onError = options.onError;
        var onResult = options.onResult;
        var onDone = options.onDone;
        var code = '';
        for (var i = 0; i < this.options.interceptors.length; i++) {
          var interceptor = this.options.interceptors[i];
          if (interceptor.call) {
            code += this.getInterceptor(i) + ".call(" + this.args({
              before: interceptor.context ? '_context' : undefined
            }) + ");\n";
          }
        }
        code += this.content(Object.assign(options, {
          onError: onError && function (err) {
            var code = '';
            for (var _i = 0; _i < _this.options.interceptors.length; _i++) {
              var _interceptor = _this.options.interceptors[_i];
              if (_interceptor.error) {
                code += _this.getInterceptor(_i) + ".error(" + err + ");\n";
              }
            }
            code += onError(err);
            return code;
          },
          onResult: onResult && function (result) {
            var code = '';
            for (var _i2 = 0; _i2 < _this.options.interceptors.length; _i2++) {
              var _interceptor2 = _this.options.interceptors[_i2];
              if (_interceptor2.result) {
                code += _this.getInterceptor(_i2) + ".result(" + result + ");\n";
              }
            }
            code += onResult(result);
            return code;
          },
          onDone: onDone && function () {
            var code = '';
            for (var _i3 = 0; _i3 < _this.options.interceptors.length; _i3++) {
              var _interceptor3 = _this.options.interceptors[_i3];
              if (_interceptor3.done) {
                code += _this.getInterceptor(_i3) + ".done();\n";
              }
            }
            code += onDone();
            return code;
          }
        }));
        return code;
      } else {
        return this.content(options);
      }
    };
    _proto.header = function header() {
      var code = '';
      if (this.needContext()) {
        code += 'var _context = {};\n';
      } else {
        code += 'var _context;\n';
      }
      code += 'var _x = this._x;\n';
      if (this.options.interceptors.length > 0) {
        code += 'var _taps = this.taps;\n';
        code += 'var _interceptors = this.interceptors;\n';
      }
      return code;
    };
    _proto.needContext = function needContext() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.options.taps), _step; !(_step = _iterator()).done;) {
        var tap = _step.value;
        if (tap.context) return true;
      }
      return false;
    };
    _proto.callTap = function callTap(tapIndex, _ref) {
      var onError = _ref.onError,
        onResult = _ref.onResult,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      var code = '';
      var hasTapCached = false;
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.tap) {
          if (!hasTapCached) {
            code += "var _tap" + tapIndex + " = " + this.getTap(tapIndex) + ";\n";
            hasTapCached = true;
          }
          code += this.getInterceptor(i) + ".tap(" + (interceptor.context ? '_context, ' : '') + "_tap" + tapIndex + ");\n";
        }
      }
      code += "var _fn" + tapIndex + " = " + this.getTapFn(tapIndex) + ";\n";
      var tap = this.options.taps[tapIndex];
      switch (tap.type) {
        case 'sync':
          if (!rethrowIfPossible) {
            code += "var _hasError" + tapIndex + " = false;\n";
            code += 'try {\n';
          }
          if (onResult) {
            code += "var _result" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
              before: tap.context ? '_context' : undefined
            }) + ");\n";
          } else {
            code += "_fn" + tapIndex + "(" + this.args({
              before: tap.context ? '_context' : undefined
            }) + ");\n";
          }
          if (!rethrowIfPossible) {
            code += '} catch(_err) {\n';
            code += "_hasError" + tapIndex + " = true;\n";
            code += onError('_err');
            code += '}\n';
            code += "if(!_hasError" + tapIndex + ") {\n";
          }
          if (onResult) {
            code += onResult("_result" + tapIndex);
          }
          if (onDone) {
            code += onDone();
          }
          if (!rethrowIfPossible) {
            code += '}\n';
          }
          break;
        case 'async':
          var cbCode = '';
          if (onResult) cbCode += "(function(_err" + tapIndex + ", _result" + tapIndex + ") {\n";else cbCode += "(function(_err" + tapIndex + ") {\n";
          cbCode += "if(_err" + tapIndex + ") {\n";
          cbCode += onError("_err" + tapIndex);
          cbCode += '} else {\n';
          if (onResult) {
            cbCode += onResult("_result" + tapIndex);
          }
          if (onDone) {
            cbCode += onDone();
          }
          cbCode += '}\n';
          cbCode += '})';
          code += "_fn" + tapIndex + "(" + this.args({
            before: tap.context ? '_context' : undefined,
            after: cbCode
          }) + ");\n";
          break;
        case 'promise':
          code += "var _hasResult" + tapIndex + " = false;\n";
          code += "var _promise" + tapIndex + " = _fn" + tapIndex + "(" + this.args({
            before: tap.context ? '_context' : undefined
          }) + ");\n";
          code += "if (!_promise" + tapIndex + " || !_promise" + tapIndex + ".then)\n";
          code += "  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise" + tapIndex + " + ')');\n";
          code += "_promise" + tapIndex + ".then((function(_result" + tapIndex + ") {\n";
          code += "_hasResult" + tapIndex + " = true;\n";
          if (onResult) {
            code += onResult("_result" + tapIndex);
          }
          if (onDone) {
            code += onDone();
          }
          code += "}), function(_err" + tapIndex + ") {\n";
          code += "if(_hasResult" + tapIndex + ") throw _err" + tapIndex + ";\n";
          code += onError("_err" + tapIndex);
          code += '});\n';
          break;
      }
      return code;
    };
    _proto.callTapsSeries = function callTapsSeries(_ref2) {
      var _this2 = this;
      var _onError = _ref2.onError,
        onResult = _ref2.onResult,
        resultReturns = _ref2.resultReturns,
        onDone = _ref2.onDone,
        doneReturns = _ref2.doneReturns,
        rethrowIfPossible = _ref2.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var firstAsync = this.options.taps.findIndex(function (t) {
        return t.type !== 'sync';
      });
      var somethingReturns = resultReturns || doneReturns;
      var code = '';
      var current = onDone;
      var unrollCounter = 0;
      var _loop = function _loop() {
        var i = j;
        var unroll = current !== onDone && (_this2.options.taps[i].type !== 'sync' || unrollCounter++ > 20);
        if (unroll) {
          unrollCounter = 0;
          code += "function _next" + i + "() {\n";
          code += current();
          code += "}\n";
          current = function current() {
            return (somethingReturns ? 'return ' : '') + "_next" + i + "();\n";
          };
        }
        var done = current;
        var doneBreak = function doneBreak(skipDone) {
          if (skipDone) return '';
          return onDone();
        };
        var content = _this2.callTap(i, {
          onError: function onError(error) {
            return _onError(i, error, done, doneBreak);
          },
          onResult: onResult && function (result) {
            return onResult(i, result, done, doneBreak);
          },
          onDone: !onResult && done,
          rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
        });
        current = function current() {
          return content;
        };
      };
      for (var j = this.options.taps.length - 1; j >= 0; j--) {
        _loop();
      }
      code += current();
      return code;
    };
    _proto.callTapsLooping = function callTapsLooping(_ref3) {
      var onError = _ref3.onError,
        onDone = _ref3.onDone,
        rethrowIfPossible = _ref3.rethrowIfPossible;
      if (this.options.taps.length === 0) return onDone();
      var syncOnly = this.options.taps.every(function (t) {
        return t.type === 'sync';
      });
      var code = '';
      if (!syncOnly) {
        code += 'var _looper = (function() {\n';
        code += 'var _loopAsync = false;\n';
      }
      code += 'var _loop;\n';
      code += 'do {\n';
      code += '_loop = false;\n';
      for (var i = 0; i < this.options.interceptors.length; i++) {
        var interceptor = this.options.interceptors[i];
        if (interceptor.loop) {
          code += this.getInterceptor(i) + ".loop(" + this.args({
            before: interceptor.context ? '_context' : undefined
          }) + ");\n";
        }
      }
      code += this.callTapsSeries({
        onError: onError,
        onResult: function onResult(i, result, next, doneBreak) {
          var code = '';
          code += "if(" + result + " !== undefined) {\n";
          code += '_loop = true;\n';
          if (!syncOnly) code += 'if(_loopAsync) _looper();\n';
          code += doneBreak(true);
          code += "} else {\n";
          code += next();
          code += "}\n";
          return code;
        },
        onDone: onDone && function () {
          var code = '';
          code += 'if(!_loop) {\n';
          code += onDone();
          code += '}\n';
          return code;
        },
        rethrowIfPossible: rethrowIfPossible && syncOnly
      });
      code += '} while(_loop);\n';
      if (!syncOnly) {
        code += '_loopAsync = true;\n';
        code += '});\n';
        code += '_looper();\n';
      }
      return code;
    };
    _proto.callTapsParallel = function callTapsParallel(_ref4) {
      var _this3 = this;
      var _onError2 = _ref4.onError,
        onResult = _ref4.onResult,
        onDone = _ref4.onDone,
        rethrowIfPossible = _ref4.rethrowIfPossible,
        _ref4$onTap = _ref4.onTap,
        onTap = _ref4$onTap === void 0 ? function (i, run) {
          return run();
        } : _ref4$onTap;
      if (this.options.taps.length <= 1) {
        return this.callTapsSeries({
          onError: _onError2,
          onResult: onResult,
          onDone: onDone,
          rethrowIfPossible: rethrowIfPossible
        });
      }
      var code = '';
      code += 'do {\n';
      code += "var _counter = " + this.options.taps.length + ";\n";
      if (onDone) {
        code += 'var _done = (function() {\n';
        code += onDone();
        code += '});\n';
      }
      var _loop2 = function _loop2(i) {
        var done = function done() {
          if (onDone) return 'if(--_counter === 0) _done();\n';else return '--_counter;';
        };
        var doneBreak = function doneBreak(skipDone) {
          if (skipDone || !onDone) return '_counter = 0;\n';else return '_counter = 0;\n_done();\n';
        };
        code += 'if(_counter <= 0) break;\n';
        code += onTap(i, function () {
          return _this3.callTap(i, {
            onError: function onError(error) {
              var code = '';
              code += 'if(_counter > 0) {\n';
              code += _onError2(i, error, done, doneBreak);
              code += '}\n';
              return code;
            },
            onResult: onResult && function (result) {
              var code = '';
              code += 'if(_counter > 0) {\n';
              code += onResult(i, result, done, doneBreak);
              code += '}\n';
              return code;
            },
            onDone: !onResult && function () {
              return done();
            },
            rethrowIfPossible: rethrowIfPossible
          });
        }, done, doneBreak);
      };
      for (var i = 0; i < this.options.taps.length; i++) {
        _loop2(i);
      }
      code += '} while(false);\n';
      return code;
    };
    _proto.args = function args(_temp) {
      var _ref5 = _temp === void 0 ? {} : _temp,
        before = _ref5.before,
        after = _ref5.after;
      var allArgs = this._args;
      if (before) allArgs = [before].concat(allArgs);
      if (after) allArgs = allArgs.concat(after);
      if (allArgs.length === 0) {
        return '';
      } else {
        return allArgs.join(', ');
      }
    };
    _proto.getTapFn = function getTapFn(idx) {
      return "_x[" + idx + "]";
    };
    _proto.getTap = function getTap(idx) {
      return "_taps[" + idx + "]";
    };
    _proto.getInterceptor = function getInterceptor(idx) {
      return "_interceptors[" + idx + "]";
    };
    return HookCodeFactory;
  }();

  var AsyncParallelHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
    _inheritsLoose(AsyncParallelHookCodeFactory, _HookCodeFactory);
    function AsyncParallelHookCodeFactory() {
      return _HookCodeFactory.apply(this, arguments) || this;
    }
    var _proto = AsyncParallelHookCodeFactory.prototype;
    _proto.content = function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone;
      return this.callTapsParallel({
        onError: function onError(i, err, done, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onDone: onDone
      });
    };
    return AsyncParallelHookCodeFactory;
  }(HookCodeFactory);
  var factory = new AsyncParallelHookCodeFactory();
  var COMPILE = function COMPILE(options) {
    factory.setup(this, options);
    return factory.create(options);
  };
  var AsyncParallelHook = /*#__PURE__*/function (_Hook) {
    _inheritsLoose(AsyncParallelHook, _Hook);
    function AsyncParallelHook(args, name) {
      var _this;
      if (args === void 0) {
        args = [];
      }
      if (name === void 0) {
        name = undefined;
      }
      _this = _Hook.call(this, args, name) || this;
      _this.compile = COMPILE;
      _this._call = undefined;
      _this.call = undefined;
      return _this;
    }
    return AsyncParallelHook;
  }(Hook);
  // export function AsyncParallelHook(args = [], name = undefined) {
  //   const hook = new Hook(args, name);
  //   hook.constructor = AsyncParallelHook;
  //   hook.compile = COMPILE;
  //   hook._call = undefined;
  //   hook.call = undefined;
  //   return hook;
  // }
  // AsyncParallelHook.prototype = null;

  var AsyncSeriesWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
    _inheritsLoose(AsyncSeriesWaterfallHookCodeFactory, _HookCodeFactory);
    function AsyncSeriesWaterfallHookCodeFactory() {
      return _HookCodeFactory.apply(this, arguments) || this;
    }
    var _proto = AsyncSeriesWaterfallHookCodeFactory.prototype;
    _proto.content = function content(_ref) {
      var _this = this;
      var _onError = _ref.onError,
        onResult = _ref.onResult,
        onDone = _ref.onDone;
      return this.callTapsSeries({
        onError: function onError(i, err, next, doneBreak) {
          return _onError(err) + doneBreak(true);
        },
        onResult: function onResult(i, result, next) {
          var code = '';
          code += "if(" + result + " !== undefined) {\n";
          code += _this._args[0] + " = " + result + ";\n";
          code += "}\n";
          code += next();
          return code;
        },
        onDone: function onDone() {
          return onResult(_this._args[0]);
        }
      });
    };
    return AsyncSeriesWaterfallHookCodeFactory;
  }(HookCodeFactory);
  var factory$1 = new AsyncSeriesWaterfallHookCodeFactory();
  var COMPILE$1 = function COMPILE(options) {
    factory$1.setup(this, options);
    return factory$1.create(options);
  };
  // export function AsyncSeriesWaterfallHook(args = [], name = undefined) {
  //   if (args.length < 1) throw new Error('Waterfall hooks must have at least one argument');
  //   const hook = new Hook(args, name);
  //   hook.constructor = AsyncSeriesWaterfallHook;
  //   hook.compile = COMPILE;
  //   hook._call = undefined;
  //   hook.call = undefined;
  //   return hook;
  // }
  // AsyncSeriesWaterfallHook.prototype = null;
  var AsyncSeriesWaterfallHook = /*#__PURE__*/function (_Hook) {
    _inheritsLoose(AsyncSeriesWaterfallHook, _Hook);
    function AsyncSeriesWaterfallHook(args, name) {
      var _this2;
      if (args === void 0) {
        args = [];
      }
      if (name === void 0) {
        name = undefined;
      }
      _this2 = _Hook.call(this, args, name) || this;
      _this2.compile = COMPILE$1;
      _this2._call = undefined;
      _this2.call = undefined;
      return _this2;
    }
    return AsyncSeriesWaterfallHook;
  }(Hook);

  var SyncHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
    _inheritsLoose(SyncHookCodeFactory, _HookCodeFactory);
    function SyncHookCodeFactory() {
      return _HookCodeFactory.apply(this, arguments) || this;
    }
    var _proto = SyncHookCodeFactory.prototype;
    _proto.content = function content(_ref) {
      var _onError = _ref.onError,
        onDone = _ref.onDone,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsSeries({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onDone: onDone,
        rethrowIfPossible: rethrowIfPossible
      });
    };
    return SyncHookCodeFactory;
  }(HookCodeFactory);
  var factory$2 = new SyncHookCodeFactory();
  var TAP_ASYNC = function TAP_ASYNC() {
    throw new Error('tapAsync is not supported on a SyncHook');
  };
  var TAP_PROMISE = function TAP_PROMISE() {
    throw new Error('tapPromise is not supported on a SyncHook');
  };
  var COMPILE$2 = function COMPILE(options) {
    factory$2.setup(this, options);
    return factory$2.create(options);
  };
  var SyncHook = /*#__PURE__*/function (_Hook) {
    _inheritsLoose(SyncHook, _Hook);
    function SyncHook(args, name) {
      var _this;
      if (args === void 0) {
        args = [];
      }
      if (name === void 0) {
        name = undefined;
      }
      _this = _Hook.call(this, args, name) || this;
      _this.tapAsync = TAP_ASYNC;
      _this.tapPromise = TAP_PROMISE;
      _this.compile = COMPILE$2;
      return _this;
    }
    return SyncHook;
  }(Hook);
  // export function SyncHook(args = [], name = undefined) {
  //   const hook = new Hook(args, name);
  //   hook.constructor = SyncHook;
  //   hook.tapAsync = TAP_ASYNC;
  //   hook.tapPromise = TAP_PROMISE;
  //   hook.compile = COMPILE;
  //   return hook;
  // }
  // SyncHook.prototype = null;

  var SyncWaterfallHookCodeFactory = /*#__PURE__*/function (_HookCodeFactory) {
    _inheritsLoose(SyncWaterfallHookCodeFactory, _HookCodeFactory);
    function SyncWaterfallHookCodeFactory() {
      return _HookCodeFactory.apply(this, arguments) || this;
    }
    var _proto = SyncWaterfallHookCodeFactory.prototype;
    _proto.content = function content(_ref) {
      var _this = this;
      var _onError = _ref.onError,
        onResult = _ref.onResult,
        resultReturns = _ref.resultReturns,
        rethrowIfPossible = _ref.rethrowIfPossible;
      return this.callTapsSeries({
        onError: function onError(i, err) {
          return _onError(err);
        },
        onResult: function onResult(i, result, next) {
          var code = '';
          code += "if(" + result + " !== undefined) {\n";
          code += _this._args[0] + " = " + result + ";\n";
          code += "}\n";
          code += next();
          return code;
        },
        onDone: function onDone() {
          return onResult(_this._args[0]);
        },
        doneReturns: resultReturns,
        rethrowIfPossible: rethrowIfPossible
      });
    };
    return SyncWaterfallHookCodeFactory;
  }(HookCodeFactory);
  var factory$3 = new SyncWaterfallHookCodeFactory();
  var TAP_ASYNC$1 = function TAP_ASYNC() {
    throw new Error('tapAsync is not supported on a SyncWaterfallHook');
  };
  var TAP_PROMISE$1 = function TAP_PROMISE() {
    throw new Error('tapPromise is not supported on a SyncWaterfallHook');
  };
  var COMPILE$3 = function COMPILE(options) {
    factory$3.setup(this, options);
    return factory$3.create(options);
  };
  var SyncWaterfallHook = /*#__PURE__*/function (_SyncHook) {
    _inheritsLoose(SyncWaterfallHook, _SyncHook);
    function SyncWaterfallHook(args, name) {
      var _this2;
      if (args === void 0) {
        args = [];
      }
      if (name === void 0) {
        name = undefined;
      }
      _this2 = _SyncHook.call(this, args, name) || this;
      _this2.tapAsync = TAP_ASYNC$1;
      _this2.tapPromise = TAP_PROMISE$1;
      _this2.compile = COMPILE$3;
      return _this2;
    }
    return SyncWaterfallHook;
  }(SyncHook);
  // export function SyncWaterfallHook(args = [], name = undefined) {
  //   if (args.length < 1) throw new Error('Waterfall hooks must have at least one argument');
  //   const hook = new Hook(args, name);
  //   hook.constructor = SyncWaterfallHook;
  //   hook.tapAsync = TAP_ASYNC;
  //   hook.tapPromise = TAP_PROMISE;
  //   hook.compile = COMPILE;
  //   return hook;
  // }
  // SyncWaterfallHook.prototype = null;

  var genericFontFamilies = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
  var stringRegExp = /([\"\'])[^\'\"]+\1/;
  function toFontString(attributes) {
    var fontSize = attributes.fontSize,
      fontFamily = attributes.fontFamily,
      fontStyle = attributes.fontStyle,
      fontVariant = attributes.fontVariant,
      fontWeight = attributes.fontWeight;
    // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
    // const fontSizeString: string = isNumber(fontSize) ? `${fontSize}px` : fontSize.toString();
    var fontSizeString = isNumber(fontSize) && fontSize + "px" || '16px';
    // Clean-up fontFamily property by quoting each font name
    // this will support font names with spaces
    var fontFamilies = fontFamily.split(',');
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      // Trim any extra white-space
      var _fontFamily = fontFamilies[i].trim();
      // Check if font already contains strings
      if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
        _fontFamily = "\"" + _fontFamily + "\"";
      }
      fontFamilies[i] = _fontFamily;
    }
    return fontStyle + " " + fontVariant + " " + fontWeight + " " + fontSizeString + " " + fontFamilies.join(',');
  }

  /**
   * Thanks for following contributor of codes
   * https://gist.github.com/1866474
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
   * https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/requestAnimationFrame/polyfill.js
   **/
  var uId = 1;
  var uniqueId = function uniqueId() {
    return uId++;
  };
  // We use `self` instead of `window` for `WebWorker` support.
  var root = typeof self === 'object' && self.self == self ? self :
  // @ts-ignore
  typeof global === 'object' && global.global == global ?
  // @ts-ignore
  global : {};
  var nowOffset = Date.now();
  // use performance api if exist, otherwise use Date.now.
  // Date.now polyfill required.
  var pnow = function pnow() {
    if (root.performance && typeof root.performance.now === 'function') {
      return root.performance.now();
    }
    // fallback
    return Date.now() - nowOffset;
  };
  var reservedCBs = {};
  var lastTime = Date.now();
  var polyfillRaf = function polyfillRaf(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }
    var currentTime = Date.now();
    var gap = currentTime - lastTime;
    var delay = gap > 16 ? 0 : 16 - gap;
    var id = uniqueId();
    reservedCBs[id] = callback;
    // keys(reservedCBs).length > 1   setTimeout   .
    //  callback     reservedCBs   return
    if (Object.keys(reservedCBs).length > 1) return id;
    setTimeout(function () {
      lastTime = currentTime;
      var copied = reservedCBs;
      reservedCBs = {};
      Object.keys(copied).forEach(function (key) {
        return copied[key](pnow());
      });
    }, delay);
    return id;
  };
  var polyfillCaf = function polyfillCaf(id) {
    delete reservedCBs[id];
  };
  var vendorPrefixes = ['', 'webkit', 'moz', 'ms', 'o'];
  var getRequestAnimationFrame = function getRequestAnimationFrame(vp) {
    if (typeof vp !== 'string') return polyfillRaf;
    if (vp === '') return root['requestAnimationFrame'];
    return root[vp + 'RequestAnimationFrame'];
  };
  var getCancelAnimationFrame = function getCancelAnimationFrame(vp) {
    if (typeof vp !== 'string') return polyfillCaf;
    if (vp === '') return root['cancelAnimationFrame'];
    return root[vp + 'CancelAnimationFrame'] || root[vp + 'CancelRequestAnimationFrame'];
  };
  var find$1 = function find(arr, predicate) {
    var i = 0;
    while (arr[i] !== void 0) {
      if (predicate(arr[i])) return arr[i];
      i = i + 1;
    }
  };
  var vp = find$1(vendorPrefixes, function (vp) {
    return !!getRequestAnimationFrame(vp);
  });
  var raf = getRequestAnimationFrame(vp);
  var caf = getCancelAnimationFrame(vp);
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;

  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function spaceColorStops(colorStops) {
    var _colorStops$length;
    var length = colorStops.length;
    colorStops[length - 1].length = (_colorStops$length = colorStops[length - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
      type: '%',
      value: '100'
    };
    if (length > 1) {
      var _colorStops$0$length;
      colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
        type: '%',
        value: '0'
      };
    }
    var previousIndex = 0;
    var previousOffset = Number(colorStops[0].length.value);
    for (var i = 1; i < length; i++) {
      var _colorStops$i$length;
      // support '%' & 'px'
      var offset = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
      if (!isNil(offset) && !isNil(previousOffset)) {
        for (var j = 1; j < i - previousIndex; j++) colorStops[previousIndex + j].length = {
          type: '%',
          value: "" + (previousOffset + (Number(offset) - previousOffset) * j / (i - previousIndex))
        };
        previousIndex = i;
        previousOffset = Number(offset);
      }
    }
  }
  // The position of the gradient line's starting point.
  // different from CSS side(to top) @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#values
  var SideOrCornerToDegMap = {
    left: 270 - 90,
    top: 0 - 90,
    bottom: 180 - 90,
    right: 90 - 90,
    'left top': 315 - 90,
    'top left': 315 - 90,
    'left bottom': 225 - 90,
    'bottom left': 225 - 90,
    'right top': 45 - 90,
    'top right': 45 - 90,
    'right bottom': 135 - 90,
    'bottom right': 135 - 90
  };
  var angleToDeg = memoize(function (orientation) {
    var angle;
    if (orientation.type === 'angular') {
      angle = Number(orientation.value);
    } else {
      angle = SideOrCornerToDegMap[orientation.value] || 0;
    }
    return getOrCreateUnitValue(angle, 'deg');
  });
  var positonToCSSUnitValue = memoize(function (position) {
    var cx = 50;
    var cy = 50;
    var unitX = '%';
    var unitY = '%';
    if ((position === null || position === void 0 ? void 0 : position.type) === 'position') {
      var _position$value = position.value,
        x = _position$value.x,
        y = _position$value.y;
      if ((x === null || x === void 0 ? void 0 : x.type) === 'position-keyword') {
        if (x.value === 'left') {
          cx = 0;
        } else if (x.value === 'center') {
          cx = 50;
        } else if (x.value === 'right') {
          cx = 100;
        } else if (x.value === 'top') {
          cy = 0;
        } else if (x.value === 'bottom') {
          cy = 100;
        }
      }
      if ((y === null || y === void 0 ? void 0 : y.type) === 'position-keyword') {
        if (y.value === 'left') {
          cx = 0;
        } else if (y.value === 'center') {
          cy = 50;
        } else if (y.value === 'right') {
          cx = 100;
        } else if (y.value === 'top') {
          cy = 0;
        } else if (y.value === 'bottom') {
          cy = 100;
        }
      }
      if ((x === null || x === void 0 ? void 0 : x.type) === 'px' || (x === null || x === void 0 ? void 0 : x.type) === '%' || (x === null || x === void 0 ? void 0 : x.type) === 'em') {
        unitX = x === null || x === void 0 ? void 0 : x.type;
        cx = Number(x.value);
      }
      if ((y === null || y === void 0 ? void 0 : y.type) === 'px' || (y === null || y === void 0 ? void 0 : y.type) === '%' || (y === null || y === void 0 ? void 0 : y.type) === 'em') {
        unitY = y === null || y === void 0 ? void 0 : y.type;
        cy = Number(y.value);
      }
    }
    return {
      cx: getOrCreateUnitValue(cx, unitX),
      cy: getOrCreateUnitValue(cy, unitY)
    };
  });
  var parseGradient$1 = memoize(function (colorStr) {
    if (colorStr.indexOf('linear') > -1 || colorStr.indexOf('radial') > -1) {
      var ast = parseGradient(colorStr);
      return ast.map(function (_ref) {
        var type = _ref.type,
          orientation = _ref.orientation,
          colorStops = _ref.colorStops;
        spaceColorStops(colorStops);
        var steps = colorStops.map(function (colorStop) {
          // TODO: only support % for now, should calc percentage of axis length when using px/em
          return {
            offset: getOrCreateUnitValue(Number(colorStop.length.value), '%'),
            color: colorStopToString(colorStop)
          };
        });
        if (type === 'linear-gradient') {
          return new CSSGradientValue(GradientType.LinearGradient, {
            angle: orientation ? angleToDeg(orientation) : Odeg,
            steps: steps
          });
        } else if (type === 'radial-gradient') {
          if (!orientation) {
            orientation = [{
              type: 'shape',
              value: 'circle'
            }];
          }
          if (orientation[0].type === 'shape' && orientation[0].value === 'circle') {
            var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at),
              cx = _positonToCSSUnitValu.cx,
              cy = _positonToCSSUnitValu.cy;
            var size;
            if (orientation[0].style) {
              var _orientation$0$style = orientation[0].style,
                _type = _orientation$0$style.type,
                value = _orientation$0$style.value;
              if (_type === 'extent-keyword') {
                size = getOrCreateKeyword(value);
              } else {
                size = getOrCreateUnitValue(value, _type);
              }
            }
            return new CSSGradientValue(GradientType.RadialGradient, {
              cx: cx,
              cy: cy,
              size: size,
              steps: steps
            });
          }
          // TODO: support ellipse shape
          // TODO: repeating-linear-gradient & repeating-radial-gradient
          // } else if (type === 'repeating-linear-gradient') {
          // } else if (type === 'repeating-radial-gradient') {
        }
      });
    }
    // legacy format, should be deprecated later
    var type = colorStr[0];
    if (colorStr[1] === '(' || colorStr[2] === '(') {
      if (type === 'l') {
        var arr = regexLG.exec(colorStr);
        if (arr) {
          var _arr$2$match;
          var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function (stop) {
            return stop.split(':');
          })) || [];
          return [new CSSGradientValue(GradientType.LinearGradient, {
            angle: getOrCreateUnitValue(parseFloat(arr[1]), 'deg'),
            steps: steps.map(function (_ref2) {
              var offset = _ref2[0],
                color = _ref2[1];
              return {
                offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
                color: color
              };
            })
          })];
        }
      } else if (type === 'r') {
        var parsedRadialGradient = parseRadialGradient(colorStr);
        if (parsedRadialGradient) {
          if (isString(parsedRadialGradient)) {
            colorStr = parsedRadialGradient;
          } else {
            return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
          }
        }
      } else if (type === 'p') {
        return parsePattern(colorStr);
      }
    }
  });
  function parseRadialGradient(gradientStr) {
    var arr = regexRG.exec(gradientStr);
    if (arr) {
      var _arr$4$match;
      var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function (stop) {
        return stop.split(':');
      })) || [];
      return {
        cx: getOrCreateUnitValue(50, '%'),
        cy: getOrCreateUnitValue(50, '%'),
        steps: steps.map(function (_ref3) {
          var offset = _ref3[0],
            color = _ref3[1];
          return {
            offset: getOrCreateUnitValue(Number(offset) * 100, '%'),
            color: color
          };
        })
      };
    }
    return null;
  }
  function parsePattern(patternStr) {
    var arr = regexPR.exec(patternStr);
    if (arr) {
      var repetition = arr[1];
      var src = arr[2];
      switch (repetition) {
        case 'a':
          repetition = 'repeat';
          break;
        case 'x':
          repetition = 'repeat-x';
          break;
        case 'y':
          repetition = 'repeat-y';
          break;
        case 'n':
          repetition = 'no-repeat';
          break;
        default:
          repetition = 'no-repeat';
      }
      return {
        image: src,
        // @ts-ignore
        repetition: repetition
      };
    }
    return null;
  }
  function isPattern(object) {
    return object && !!object.image;
  }
  function isCSSRGB(object) {
    return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
  }
  /**
   * @see https://github.com/WebKit/WebKit/blob/main/Source/WebCore/css/parser/CSSParser.cpp#L97
   */
  var parseColor = memoize(function (colorStr) {
    if (isPattern(colorStr)) {
      return _extends({
        repetition: 'repeat'
      }, colorStr);
    }
    if (isNil(colorStr)) {
      colorStr = '';
    }
    if (colorStr === 'transparent') {
      // transparent black
      return transparentColor;
    } else if (colorStr === 'currentColor') {
      // @see https://github.com/adobe-webplatform/Snap.svg/issues/526
      colorStr = 'black';
    }
    // support CSS gradient syntax
    var g = parseGradient$1(colorStr);
    if (g) {
      return g;
    }
    // constants
    var color$1 = color(colorStr);
    var rgba = [0, 0, 0, 0];
    if (color$1 !== null) {
      rgba[0] = color$1.r || 0;
      rgba[1] = color$1.g || 0;
      rgba[2] = color$1.b || 0;
      rgba[3] = color$1.opacity;
    }
    // return new CSSRGB(...rgba);
    return getOrCreateRGBA.apply(void 0, rgba);
  });
  function mergeColors(left, right) {
    // only support constant value, exclude gradient & pattern
    if (!isCSSRGB(left) || !isCSSRGB(right)) {
      return;
    }
    return [[Number(left.r), Number(left.g), Number(left.b), Number(left.alpha)], [Number(right.r), Number(right.g), Number(right.b), Number(right.alpha)], function (color) {
      var rgba = color.slice();
      if (rgba[3]) {
        for (var i = 0; i < 3; i++) rgba[i] = Math.round(clamp(rgba[i], 0, 255));
      }
      rgba[3] = clamp(rgba[3], 0, 1);
      return "rgba(" + rgba.join(',') + ")";
    }];
  }

  function parseDimension(unitRegExp, string) {
    if (isNil(string)) {
      return getOrCreateUnitValue(0, 'px');
    }
    string = ("" + string).trim().toLowerCase();
    if (isFinite(Number(string))) {
      if ('px'.search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), 'px');
      } else if ('deg'.search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), 'deg');
      }
    }
    var matchedUnits = [];
    string = string.replace(unitRegExp, function (match) {
      matchedUnits.push(match);
      return 'U' + match;
    });
    var taggedUnitRegExp = 'U(' + unitRegExp.source + ')';
    return matchedUnits.map(function (unit) {
      return getOrCreateUnitValue(Number(string.replace(new RegExp('U' + unit, 'g'), '').replace(new RegExp(taggedUnitRegExp, 'g'), '*0')), unit);
    })[0];
  }
  /**
   * <length>
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length
   * length with only absolute unit, eg. 1px
   */
  var parseLength = memoize(function (css) {
    return parseDimension(new RegExp('px', 'g'), css);
  });
  /**
   * <percentage>
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage
   */
  var parserPercentage = memoize(function (css) {
    return parseDimension(new RegExp('%', 'g'), css);
  });
  /**
   * length with absolute or relative unit,
   * eg. 1px, 0.7em, 50%, calc(100% - 200px);
   *
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/length-percentage
   */
  // export const parseLengthOrPercentage = memoize((css: string): CSSUnitValue => {
  //   if (isNumber(css) || isFinite(Number(css))) {
  //     return getOrCreateUnitValue(Number(css), 'px');
  //   }
  //   return parseDimension(new RegExp('px|%|em|rem', 'g'), css) as CSSUnitValue;
  // });
  var parseLengthOrPercentage = function parseLengthOrPercentage(css) {
    if (isNumber(css) || isFinite(Number(css))) {
      // Number(css) is NaN
      return getOrCreateUnitValue(Number(css) || 0, 'px');
      // return Number(css);
    }

    return parseDimension(new RegExp('px|%|em|rem', 'g'), css);
  };
  var parseAngle = memoize(function (css) {
    return parseDimension(new RegExp('deg|rad|grad|turn', 'g'), css);
  });
  /**
   * merge CSSUnitValue
   *
   * @example
   * 10px + 20px = 30px
   * 10deg + 10rad
   * 10% + 20% = 30%
   */
  function mergeDimensions(left, right, target, nonNegative, index) {
    if (index === void 0) {
      index = 0;
    }
    var unit = '';
    var leftValue = left.value || 0;
    var rightValue = right.value || 0;
    var canonicalUnit = toCanonicalUnit(left.unit);
    var leftCanonicalUnitValue = left.convertTo(canonicalUnit);
    var rightCanonicalUnitValue = right.convertTo(canonicalUnit);
    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
      leftValue = leftCanonicalUnitValue.value;
      rightValue = rightCanonicalUnitValue.value;
      unit = unitTypeToString(left.unit);
    } else {
      // format '%' to 'px'
      if (CSSUnitValue.isLength(left.unit) || CSSUnitValue.isLength(right.unit)) {
        leftValue = convertPercentUnit(left, index, target);
        rightValue = convertPercentUnit(right, index, target);
        unit = 'px';
      }
    }
    // // format 'rad' 'turn' to 'deg'
    // if (CSSUnitValue.isAngle(left.unit) || CSSUnitValue.isAngle(right.unit)) {
    //   leftValue = convertAngleUnit(left);
    //   rightValue = convertAngleUnit(right);
    //   unit = 'deg';
    // }
    return [leftValue, rightValue, function (value) {
      if (nonNegative) {
        value = Math.max(value, 0);
      }
      return value + unit;
    }];
  }
  function convertAngleUnit(value) {
    var deg = 0;
    if (value.unit === UnitType.kDegrees) {
      deg = value.value;
    } else if (value.unit === UnitType.kRadians) {
      deg = rad2deg(Number(value.value));
    } else if (value.unit === UnitType.kTurns) {
      deg = turn2deg(Number(value.value));
    }
    return deg;
  }
  function parseDimensionArrayFormat(string, size) {
    var parsed;
    if (Array.isArray(string)) {
      // [1, '2px', 3]
      parsed = string.map(function (segment) {
        return Number(segment);
      });
    } else if (isString(string)) {
      parsed = string.split(' ').map(function (segment) {
        return Number(segment);
      });
    } else if (isNumber(string)) {
      parsed = [string];
    }
    if (size === 2) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0]];
      } else {
        return [parsed[0], parsed[1]];
      }
    } else {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0], parsed[0], parsed[0]];
      } else if (parsed.length === 2) {
        return [parsed[0], parsed[1], parsed[0], parsed[1]];
      } else if (parsed.length === 3) {
        return [parsed[0], parsed[1], parsed[2], parsed[1]];
      } else {
        return [parsed[0], parsed[1], parsed[2], parsed[3]];
      }
    }
  }
  function parseDimensionArray(string) {
    if (isString(string)) {
      // "1px 2px 3px"
      return string.split(' ').map(function (segment) {
        return parseLengthOrPercentage(segment);
      });
    } else {
      // [1, '2px', 3]
      return string.map(function (segment) {
        return parseLengthOrPercentage(segment.toString());
      });
    }
  }
  // export function mergeDimensionList(
  //   left: CSSUnitValue[],
  //   right: CSSUnitValue[],
  //   target: IElement | null,
  // ): [number[], number[], (list: number[]) => string] | undefined {
  //   if (left.length !== right.length) {
  //     return;
  //   }
  //   const unit = left[0].unit;
  //   return [
  //     left.map((l) => l.value),
  //     right.map((l) => l.value),
  //     (values: number[]) => {
  //       return values.map((n) => new CSSUnitValue(n, unit)).join(' ');
  //     },
  //   ];
  // }
  function convertPercentUnit(valueWithUnit, vec3Index, target) {
    if (valueWithUnit.value === 0) {
      return 0;
    }
    if (valueWithUnit.unit === UnitType.kPixels) {
      return Number(valueWithUnit.value);
    } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
      var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() :
      // : target.getGeometryBounds();
      target.geometry.contentBounds;
      return valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
    }
    return 0;
  }

  var parseParam = function parseParam(css) {
    return parseDimension(/deg|rad|grad|turn|px|%/g, css);
  };
  var supportedFilters = ['blur', 'brightness', 'drop-shadow', 'contrast', 'grayscale', 'sepia', 'saturate', 'hue-rotate', 'invert'];
  function parseFilter(filterStr) {
    if (filterStr === void 0) {
      filterStr = '';
    }
    filterStr = filterStr.toLowerCase().trim();
    if (filterStr === 'none') {
      return [];
    }
    var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
    var result = [];
    var match;
    var prevLastIndex = 0;
    while (match = filterRegExp.exec(filterStr)) {
      if (match.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match.index + match[0].length;
      if (supportedFilters.indexOf(match[1]) > -1) {
        result.push({
          name: match[1],
          params: match[2].split(' ').map(function (p) {
            return parseParam(p) || parseColor(p);
          })
        });
      }
      if (filterRegExp.lastIndex === filterStr.length) {
        return result;
      }
    }
    return [];
  }

  function numberToString(x) {
    // scale(0.00000001) -> scale(0)
    // return x.toFixed(6).replace(/0+$/, '').replace(/\.$/, '');
    return x.toString();
  }
  /**
   * parse string or number to CSSUnitValue(numeric)
   *
   * eg.
   * * 0 -> CSSUnitValue(0)
   * * '2' -> CSSUnitValue(2)
   */
  var parseNumber = memoize(function (string) {
    if (typeof string === 'number') {
      return getOrCreateUnitValue(string);
    }
    if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
      return getOrCreateUnitValue(Number(string));
    } else {
      return getOrCreateUnitValue(0);
    }
  });
  /**
   * separate string to array
   * eg.
   * * [0.5, 0.5] -> [CSSUnitValue, CSSUnitValue]
   */
  var parseNumberList = memoize(function (string) {
    if (isString(string)) {
      return string.split(' ').map(parseNumber);
    } else {
      return string.map(parseNumber);
    }
  });
  function mergeNumbers(left, right) {
    return [left, right, numberToString];
  }
  function clampedMergeNumbers(min, max) {
    return function (left, right) {
      return [left, right, function (x) {
        return numberToString(clamp(x, min, max));
      }];
    };
  }
  function mergeNumberLists(left, right) {
    if (left.length !== right.length) {
      return;
    }
    return [left, right, function (numberList) {
      return numberList;
    }];
  }

  var internalParsePath = function internalParsePath(path) {
    // empty path
    if (path === '' || Array.isArray(path) && path.length === 0) {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
    }
    var absolutePath;
    try {
      absolutePath = normalizePath(path);
    } catch (e) {
      absolutePath = normalizePath('');
      console.error("[g]: Invalid SVG Path definition: " + path);
    }
    var hasArc = hasArcOrBezier(absolutePath);
    var _extractPolygons = extractPolygons(absolutePath),
      polygons = _extractPolygons.polygons,
      polylines = _extractPolygons.polylines;
    // for later use
    var segments = path2Segments(absolutePath);
    // Only calculate bbox here since we don't need length now.
    var _getPathBBox = getPathBBox(segments, 0),
      x = _getPathBBox.x,
      y = _getPathBBox.y,
      width = _getPathBBox.width,
      height = _getPathBBox.height;
    return {
      absolutePath: absolutePath,
      hasArc: hasArc,
      segments: segments,
      polygons: polygons,
      polylines: polylines,
      // curve,
      // Delay the calculation of length.
      totalLength: 0,
      rect: {
        x: Number.isFinite(x) ? x : 0,
        y: Number.isFinite(y) ? y : 0,
        width: Number.isFinite(width) ? width : 0,
        height: Number.isFinite(height) ? height : 0
      }
    };
  };
  var memoizedParsePath = memoize(internalParsePath);
  function parsePath(path, object) {
    var result = isString(path) ? memoizedParsePath(path) : internalParsePath(path);
    if (object) {
      object.parsedStyle.defX = result.rect.x;
      object.parsedStyle.defY = result.rect.y;
    }
    return result;
  }
  function mergePaths(left, right, object) {
    var curve1 = left.curve;
    var curve2 = right.curve;
    if (!curve1 || curve1.length === 0) {
      // convert to curves to do morphing & picking later
      // @see http://thednp.github.io/kute.js/svgCubicMorph.html
      curve1 = path2Curve(left.absolutePath, false);
      left.curve = curve1;
    }
    if (!curve2 || curve2.length === 0) {
      curve2 = path2Curve(right.absolutePath, false);
      right.curve = curve2;
    }
    var curves = [curve1, curve2];
    if (curve1.length !== curve2.length) {
      curves = equalizeSegments(curve1, curve2);
    }
    var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
    return [curve0, getRotatedCurve(curves[1], curve0), function (pathArray) {
      // need converting to path string?
      return pathArray;
    }];
  }

  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/points
   *
   * @example
   * points="100,10 250,150 200,110"
   */
  function parsePoints(pointsOrStr, object) {
    var points;
    if (isString(pointsOrStr)) {
      points = pointsOrStr.split(' ').map(function (pointStr) {
        var _pointStr$split = pointStr.split(','),
          x = _pointStr$split[0],
          y = _pointStr$split[1];
        return [Number(x), Number(y)];
      });
    } else {
      points = pointsOrStr;
    }
    var segments = [];
    var tempLength = 0;
    var segmentT;
    var segmentL;
    var totalLength = polyline.length(points);
    points.forEach(function (p, i) {
      if (points[i + 1]) {
        segmentT = [0, 0];
        segmentT[0] = tempLength / totalLength;
        segmentL = line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        segments.push(segmentT);
      }
    });
    var minX = Math.min.apply(Math, points.map(function (point) {
      return point[0];
    }));
    var minY = Math.min.apply(Math, points.map(function (point) {
      return point[1];
    }));
    if (object) {
      object.parsedStyle.defX = minX;
      object.parsedStyle.defY = minY;
    }
    return {
      points: points,
      totalLength: totalLength,
      segments: segments
    };
  }
  function mergePoints(left, right) {
    return [left.points, right.points, function (points) {
      return points;
    }];
  }

  var _ = null;
  function cast(pattern) {
    return function (contents) {
      var i = 0;
      return pattern.map(function (x) {
        return x === _ ? contents[i++] : x;
      });
    };
  }
  function id(x) {
    return x;
  }
  // type: [argTypes, convertTo3D, convertTo2D]
  // In the argument types string, lowercase characters represent optional arguments
  var transformFunctions = {
    // @ts-ignore
    matrix: ['NNNNNN', [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
    matrix3d: ['NNNNNNNNNNNNNNNN', id],
    rotate: ['A'],
    rotatex: ['A'],
    rotatey: ['A'],
    rotatez: ['A'],
    rotate3d: ['NNNA'],
    perspective: ['L'],
    scale: ['Nn', cast([_, _, new CSSUnitValue(1)]), id],
    scalex: ['N', cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
    scaley: ['N', cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
    scalez: ['N', cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
    scale3d: ['NNN', id],
    skew: ['Aa', null, id],
    skewx: ['A', null, cast([_, Odeg])],
    skewy: ['A', null, cast([Odeg, _])],
    translate: ['Tt', cast([_, _, Opx]), id],
    translatex: ['T', cast([_, Opx, Opx]), cast([_, Opx])],
    translatey: ['T', cast([Opx, _, Opx]), cast([Opx, _])],
    translatez: ['L', cast([Opx, Opx, _])],
    translate3d: ['TTL', id]
  };
  /**
   * none
   * scale(1) scale(1, 2)
   * scaleX(1)
   */
  function parseTransform(string) {
    string = (string || 'none').toLowerCase().trim();
    if (string === 'none') {
      return [];
    }
    var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
    var result = [];
    var match;
    var prevLastIndex = 0;
    while (match = transformRegExp.exec(string)) {
      if (match.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match.index + match[0].length;
      var functionName = match[1]; // scale
      var functionData = transformFunctions[functionName]; // scale(1, 2)
      if (!functionData) {
        // invalid, eg. scale()
        return [];
      }
      var args = match[2].split(','); // 1,2
      var argTypes = functionData[0]; // Nn
      if (argTypes.length < args.length) {
        // scale(N, n)
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          // @ts-ignore
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          // @ts-ignore
          parsedArg = {
            A: function A(s) {
              return s.trim() === '0' ? Odeg : parseAngle(s);
            },
            N: parseNumber,
            T: parseLengthOrPercentage,
            L: parseLength
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === undefined) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({
        t: functionName,
        d: parsedArgs
      }); // { t: scale, d: [1, 2] }
      if (transformRegExp.lastIndex === string.length) {
        return result;
      }
    }
    return [];
  }
  function convertItemToMatrix(item) {
    var x;
    var y;
    var z;
    var angle;
    switch (item.t) {
      case 'rotatex':
        angle = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, 0, Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1];
      case 'rotatey':
        angle = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle), 0, -Math.sin(angle), 0, 0, 1, 0, 0, Math.sin(angle), 0, Math.cos(angle), 0, 0, 0, 0, 1];
      case 'rotate':
      case 'rotatez':
        angle = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle), Math.sin(angle), 0, 0, -Math.sin(angle), Math.cos(angle), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'rotate3d':
        x = item.d[0].value;
        y = item.d[1].value;
        z = item.d[2].value;
        angle = deg2rad(convertAngleUnit(item.d[3]));
        var sqrLength = x * x + y * y + z * z;
        if (sqrLength === 0) {
          x = 1;
          y = 0;
          z = 0;
        } else if (sqrLength !== 1) {
          var length = Math.sqrt(sqrLength);
          x /= length;
          y /= length;
          z /= length;
        }
        var s = Math.sin(angle / 2);
        var sc = s * Math.cos(angle / 2);
        var sq = s * s;
        return [1 - 2 * (y * y + z * z) * sq, 2 * (x * y * sq + z * sc), 2 * (x * z * sq - y * sc), 0, 2 * (x * y * sq - z * sc), 1 - 2 * (x * x + z * z) * sq, 2 * (y * z * sq + x * sc), 0, 2 * (x * z * sq + y * sc), 2 * (y * z * sq - x * sc), 1 - 2 * (x * x + y * y) * sq, 0, 0, 0, 0, 1];
      case 'scale':
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'scalex':
        return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'scaley':
        return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'scalez':
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
      case 'scale3d':
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
      case 'skew':
        var xAngle = deg2rad(convertAngleUnit(item.d[0]));
        var yAngle = deg2rad(convertAngleUnit(item.d[1]));
        return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'skewx':
        angle = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, Math.tan(angle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'skewy':
        angle = deg2rad(convertAngleUnit(item.d[0]));
        return [1, Math.tan(angle), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case 'translate':
        // TODO: pass target
        x = convertPercentUnit(item.d[0], 0, null) || 0;
        y = convertPercentUnit(item.d[1], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, 0, 1];
      case 'translatex':
        x = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
      case 'translatey':
        y = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
      case 'translatez':
        z = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
      case 'translate3d':
        x = convertPercentUnit(item.d[0], 0, null) || 0;
        y = convertPercentUnit(item.d[1], 0, null) || 0;
        z = convertPercentUnit(item.d[2], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
      case 'perspective':
        var t = convertPercentUnit(item.d[0], 0, null) || 0;
        var p = t ? -1 / t : 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p, 0, 0, 0, 1];
      case 'matrix':
        return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
      case 'matrix3d':
        return item.d.map(function (d) {
          return d.value;
        });
    }
  }
  function multiplyMatrices(a, b) {
    return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
  }
  function convertToMatrix(transformList) {
    if (transformList.length === 0) {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
  }
  function makeMatrixDecomposition(transformList) {
    var translate = [0, 0, 0];
    var scale = [1, 1, 1];
    var skew = [0, 0, 0];
    var perspective = [0, 0, 0, 1];
    var quaternion = [0, 0, 0, 1];
    // @ts-ignore
    decomposeMat4(convertToMatrix(transformList), translate, scale, skew, perspective, quaternion);
    return [[translate, scale, skew, quaternion, perspective]];
  }
  var composeMatrix = function () {
    function multiply(a, b) {
      var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
      for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
          for (var k = 0; k < 4; k++) {
            result[i][j] += b[i][k] * a[k][j];
          }
        }
      }
      return result;
    }
    function is2D(m) {
      return m[0][2] == 0 && m[0][3] == 0 && m[1][2] == 0 && m[1][3] == 0 && m[2][0] == 0 && m[2][1] == 0 && m[2][2] == 1 && m[2][3] == 0 && m[3][2] == 0 && m[3][3] == 1;
    }
    function composeMatrix(translate, scale, skew, quat, perspective) {
      var matrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      for (var i = 0; i < 4; i++) {
        matrix[i][3] = perspective[i];
      }
      for (var _i = 0; _i < 3; _i++) {
        for (var j = 0; j < 3; j++) {
          matrix[3][_i] += translate[j] * matrix[j][_i];
        }
      }
      var x = quat[0],
        y = quat[1],
        z = quat[2],
        w = quat[3];
      var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      rotMatrix[0][0] = 1 - 2 * (y * y + z * z);
      rotMatrix[0][1] = 2 * (x * y - z * w);
      rotMatrix[0][2] = 2 * (x * z + y * w);
      rotMatrix[1][0] = 2 * (x * y + z * w);
      rotMatrix[1][1] = 1 - 2 * (x * x + z * z);
      rotMatrix[1][2] = 2 * (y * z - x * w);
      rotMatrix[2][0] = 2 * (x * z - y * w);
      rotMatrix[2][1] = 2 * (y * z + x * w);
      rotMatrix[2][2] = 1 - 2 * (x * x + y * y);
      matrix = multiply(matrix, rotMatrix);
      var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      if (skew[2]) {
        temp[2][1] = skew[2];
        matrix = multiply(matrix, temp);
      }
      if (skew[1]) {
        temp[2][1] = 0;
        temp[2][0] = skew[0];
        matrix = multiply(matrix, temp);
      }
      if (skew[0]) {
        temp[2][0] = 0;
        temp[1][0] = skew[0];
        matrix = multiply(matrix, temp);
      }
      for (var _i2 = 0; _i2 < 3; _i2++) {
        for (var _j = 0; _j < 3; _j++) {
          matrix[_i2][_j] *= scale[_i2];
        }
      }
      if (is2D(matrix)) {
        return [matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1], matrix[3][0], matrix[3][1]];
      }
      return matrix[0].concat(matrix[1], matrix[2], matrix[3]);
    }
    return composeMatrix;
  }();
  function numberToLongString(x) {
    return x.toFixed(6).replace('.000000', '');
  }
  function mergeMatrices(left, right) {
    var leftArgs;
    var rightArgs;
    // @ts-ignore
    if (left.decompositionPair !== right) {
      // @ts-ignore
      left.decompositionPair = right;
      // @ts-ignore
      leftArgs = makeMatrixDecomposition(left);
    }
    // @ts-ignore
    if (right.decompositionPair !== left) {
      // @ts-ignore
      right.decompositionPair = left;
      // @ts-ignore
      rightArgs = makeMatrixDecomposition(right);
    }
    if (leftArgs[0] === null || rightArgs[0] === null) return [
    // @ts-ignore
    [false],
    // @ts-ignore
    [true],
    // @ts-ignore
    function (x) {
      return x ? right[0].d : left[0].d;
    }];
    leftArgs[0].push(0);
    rightArgs[0].push(1);
    return [leftArgs, rightArgs,
    // @ts-ignore
    function (list) {
      // @ts-ignore
      var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
      var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
      var stringifiedArgs = mat.map(numberToLongString).join(',');
      return stringifiedArgs;
    }];
  }
  function dot$2(v1, v2) {
    var result = 0;
    for (var i = 0; i < v1.length; i++) {
      result += v1[i] * v2[i];
    }
    return result;
  }
  function quat(fromQ, toQ, f) {
    var product = dot$2(fromQ, toQ);
    product = clamp(product, -1.0, 1.0);
    var quat = [];
    if (product === 1.0) {
      quat = fromQ;
    } else {
      var theta = Math.acos(product);
      var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
      for (var i = 0; i < 4; i++) {
        quat.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
      }
    }
    return quat;
  }
  // scalex/y/z -> scale
  function typeTo2D(type) {
    return type.replace(/[xy]/, '');
  }
  // scalex/y/z -> scale3d
  function typeTo3D(type) {
    return type.replace(/(x|y|z|3d)?$/, '3d');
  }
  var isMatrixOrPerspective = function isMatrixOrPerspective(lt, rt) {
    return lt === 'perspective' && rt === 'perspective' || (lt === 'matrix' || lt === 'matrix3d') && (rt === 'matrix' || rt === 'matrix3d');
  };
  function mergeTransforms(left, right, target) {
    var flipResults = false;
    // padding empty transform, eg. merge 'scale(10)' with 'none' -> scale(1)
    if (!left.length || !right.length) {
      if (!left.length) {
        flipResults = true;
        left = right;
        right = [];
      }
      var _loop = function _loop() {
        var _left$i = left[i],
          type = _left$i.t,
          args = _left$i.d;
        // none -> scale(1)/translateX(0)
        var defaultValue = type.substring(0, 5) === 'scale' ? 1 : 0;
        right.push({
          t: type,
          d: args.map(function (arg) {
            if (typeof arg === 'number') {
              return getOrCreateUnitValue(defaultValue);
            }
            return getOrCreateUnitValue(defaultValue, arg.unit);
            //   {
            //     unit: arg.unit,
            //     value: defaultValue,
            //   };
          })
        });
      };
      for (var i = 0; i < left.length; i++) {
        _loop();
      }
    }
    var leftResult = [];
    var rightResult = [];
    var types = [];
    // merge matrix() with matrix3d()
    if (left.length !== right.length) {
      var merged = mergeMatrices(left, right);
      // @ts-ignore
      leftResult = [merged[0]];
      // @ts-ignore
      rightResult = [merged[1]];
      types = [['matrix', [merged[2]]]];
    } else {
      for (var _i3 = 0; _i3 < left.length; _i3++) {
        var leftType = left[_i3].t;
        var rightType = right[_i3].t;
        var leftArgs = left[_i3].d;
        var rightArgs = right[_i3].d;
        var leftFunctionData = transformFunctions[leftType];
        var rightFunctionData = transformFunctions[rightType];
        var type = void 0;
        if (isMatrixOrPerspective(leftType, rightType)) {
          var _merged = mergeMatrices([left[_i3]], [right[_i3]]);
          // @ts-ignore
          leftResult.push(_merged[0]);
          // @ts-ignore
          rightResult.push(_merged[1]);
          types.push(['matrix', [_merged[2]]]);
          continue;
        } else if (leftType === rightType) {
          type = leftType;
        } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
          type = typeTo2D(leftType);
          // @ts-ignore
          leftArgs = leftFunctionData[2](leftArgs);
          // @ts-ignore
          rightArgs = rightFunctionData[2](rightArgs);
        } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
          type = typeTo3D(leftType);
          // @ts-ignore
          leftArgs = leftFunctionData[1](leftArgs);
          // @ts-ignore
          rightArgs = rightFunctionData[1](rightArgs);
        } else {
          var _merged2 = mergeMatrices(left, right);
          // @ts-ignore
          leftResult = [_merged2[0]];
          // @ts-ignore
          rightResult = [_merged2[1]];
          types = [['matrix', [_merged2[2]]]];
          break;
        }
        var leftArgsCopy = [];
        var rightArgsCopy = [];
        var stringConversions = [];
        for (var j = 0; j < leftArgs.length; j++) {
          // const merge = leftArgs[j].unit === UnitType.kNumber ? mergeDimensions : mergeDimensions;
          var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
          leftArgsCopy[j] = _merged3[0];
          rightArgsCopy[j] = _merged3[1];
          stringConversions.push(_merged3[2]);
        }
        leftResult.push(leftArgsCopy);
        rightResult.push(rightArgsCopy);
        types.push([type, stringConversions]);
      }
    }
    if (flipResults) {
      var tmp = leftResult;
      leftResult = rightResult;
      rightResult = tmp;
    }
    return [leftResult, rightResult, function (list) {
      return list.map(function (args, i) {
        var stringifiedArgs = args.map(function (arg, j) {
          return types[i][1][j](arg);
        }).join(',');
        if (types[i][0] === 'matrix' && stringifiedArgs.split(',').length === 16) {
          types[i][0] = 'matrix3d';
        }
        if (types[i][0] === 'matrix3d' && stringifiedArgs.split(',').length === 6) {
          types[i][0] = 'matrix';
        }
        return types[i][0] + '(' + stringifiedArgs + ')';
      }).join(' ');
    }];
  }

  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
   * eg. 'center' 'top left' '50px 50px'
   */
  var parseTransformOrigin = memoize(function (value) {
    if (isString(value)) {
      if (value === 'text-anchor') {
        return [getOrCreateUnitValue(0, 'px'), getOrCreateUnitValue(0, 'px')];
      }
      var values = value.split(' ');
      if (values.length === 1) {
        if (values[0] === 'top' || values[0] === 'bottom') {
          // 'top' -> 'center top'
          values[1] = values[0];
          values[0] = 'center';
        } else {
          // '50px' -> '50px center'
          values[1] = 'center';
        }
      }
      if (values.length !== 2) {
        return null;
      }
      // eg. center bottom
      return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
    } else {
      return [getOrCreateUnitValue(value[0] || 0, 'px'), getOrCreateUnitValue(value[1] || 0, 'px')];
    }
  });
  function convertKeyword2Percent(keyword) {
    if (keyword === 'center') {
      return '50%';
    } else if (keyword === 'left' || keyword === 'top') {
      return '0';
    } else if (keyword === 'right' || keyword === 'bottom') {
      return '100%';
    }
    return keyword;
  }

  var CSSPropertyAngle = /*#__PURE__*/function () {
    function CSSPropertyAngle() {
      this.parser = parseAngle;
      this.parserWithCSSDisabled = null;
      this.mixer = mergeNumbers;
    }
    var _proto = CSSPropertyAngle.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed, object) {
      return convertAngleUnit(parsed);
    };
    return CSSPropertyAngle;
  }();

  /**
   * clipPath / textPath / offsetPath
   */
  var CSSPropertyClipPath = /*#__PURE__*/function () {
    function CSSPropertyClipPath() {}
    var _proto = CSSPropertyClipPath.prototype;
    _proto.calculator = function calculator(name, oldPath, newPath, object) {
      // unset
      if (newPath instanceof CSSKeywordValue) {
        newPath = null;
      }
      runtime.sceneGraphService.updateDisplayObjectDependency(name, oldPath, newPath, object);
      if (name === 'clipPath') {
        // should affect children
        object.forEach(function (leaf) {
          if (leaf.childNodes.length === 0) {
            runtime.sceneGraphService.dirtifyToRoot(leaf);
          }
        });
      }
      return newPath;
    };
    return CSSPropertyClipPath;
  }();

  var CSSPropertyColor = /*#__PURE__*/function () {
    function CSSPropertyColor() {
      this.parser = parseColor;
      this.parserWithCSSDisabled = parseColor;
      this.mixer = mergeColors;
    }
    var _proto = CSSPropertyColor.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        // 'unset' 'none'
        return parsed.value === 'none' ? noneColor : transparentColor;
      }
      return parsed;
    };
    return CSSPropertyColor;
  }();

  var CSSPropertyFilter = /*#__PURE__*/function () {
    function CSSPropertyFilter() {
      this.parser = parseFilter;
    }
    var _proto = CSSPropertyFilter.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed) {
      // unset or none
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    };
    return CSSPropertyFilter;
  }();

  function getFontSize(object) {
    var fontSize = object.parsedStyle.fontSize;
    return isNil(fontSize) ? null : fontSize;
  }
  /**
   * <length> & <percentage>
   */
  var CSSPropertyLengthOrPercentage = /*#__PURE__*/function () {
    function CSSPropertyLengthOrPercentage() {
      this.parser = parseLengthOrPercentage;
      this.parserWithCSSDisabled = null;
      this.mixer = mergeNumbers;
    }
    var _proto = CSSPropertyLengthOrPercentage.prototype;
    /**
     * according to parent's bounds
     *
     * @example
     * CSS.percent(50) -> CSS.px(0.5 * parent.width)
     */
    _proto.calculator = function calculator(name, oldParsed, computed, object, registry) {
      if (isNumber(computed)) {
        return computed;
      }
      if (CSSUnitValue.isRelativeUnit(computed.unit)) {
        if (computed.unit === UnitType.kPercentage) {
          // TODO: merge dimensions
          return 0;
        } else if (computed.unit === UnitType.kEms) {
          if (object.parentNode) {
            var fontSize = getFontSize(object.parentNode);
            if (fontSize) {
              fontSize *= computed.value;
              return fontSize;
            } else {
              registry.addUnresolveProperty(object, name);
            }
          } else {
            registry.addUnresolveProperty(object, name);
          }
          return 0;
        } else if (computed.unit === UnitType.kRems) {
          var _object$ownerDocument;
          if (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.documentElement) {
            var _fontSize = getFontSize(object.ownerDocument.documentElement);
            if (_fontSize) {
              _fontSize *= computed.value;
              return _fontSize;
            } else {
              registry.addUnresolveProperty(object, name);
            }
          } else {
            registry.addUnresolveProperty(object, name);
          }
          return 0;
        }
      } else {
        // remove listener if exists
        // registry.unregisterParentGeometryBoundsChangedHandler(object, name);
        // return absolute value
        return computed.value;
      }
    };
    return CSSPropertyLengthOrPercentage;
  }();

  /**
   * format to Tuple2<CSSUnitValue>
   *
   * @example
   * rect.style.lineDash = 10;
   * rect.style.lineDash = [10, 10];
   * rect.style.lineDash = '10 10';
   */
  var CSSPropertyLengthOrPercentage12 = /*#__PURE__*/function () {
    function CSSPropertyLengthOrPercentage12() {
      this.mixer = mergeNumberLists;
    }
    var _proto = CSSPropertyLengthOrPercentage12.prototype;
    _proto.parser = function parser(radius) {
      var parsed = parseDimensionArray(isNumber(radius) ? [radius] : radius);
      var formatted;
      if (parsed.length === 1) {
        formatted = [parsed[0], parsed[0]];
      } else {
        formatted = [parsed[0], parsed[1]];
      }
      return formatted;
    };
    _proto.calculator = function calculator(name, oldParsed, computed) {
      return computed.map(function (c) {
        return c.value;
      });
    };
    return CSSPropertyLengthOrPercentage12;
  }();

  /**
   * used in rounded rect
   *
   * @example
   * rect.style.radius = 10;
   * rect.style.radius = '10 10';
   * rect.style.radius = '10 10 10 10';
   */
  var CSSPropertyLengthOrPercentage14 = /*#__PURE__*/function () {
    function CSSPropertyLengthOrPercentage14() {
      this.mixer = mergeNumberLists;
    }
    var _proto = CSSPropertyLengthOrPercentage14.prototype;
    _proto.parser = function parser(radius) {
      var parsed = parseDimensionArray(isNumber(radius) ? [radius] : radius);
      var formatted;
      // format to Tuple<CSSUnitValue>
      if (parsed.length === 1) {
        formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
      } else if (parsed.length === 2) {
        formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
      } else if (parsed.length === 3) {
        formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
      } else {
        formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
      }
      return formatted;
    };
    _proto.calculator = function calculator(name, oldParsed, computed) {
      return computed.map(function (c) {
        return c.value;
      });
    };
    return CSSPropertyLengthOrPercentage14;
  }();

  /**
   * local position
   */
  var CSSPropertyLocalPosition = /*#__PURE__*/function (_CSSPropertyLengthOrP) {
    _inheritsLoose(CSSPropertyLocalPosition, _CSSPropertyLengthOrP);
    function CSSPropertyLocalPosition() {
      return _CSSPropertyLengthOrP.apply(this, arguments) || this;
    }
    var _proto = CSSPropertyLocalPosition.prototype;
    /**
     * update local position
     */
    _proto.postProcessor = function postProcessor(object, attributes) {
      var x;
      var y;
      var z;
      switch (object.nodeName) {
        case Shape.CIRCLE:
        case Shape.ELLIPSE:
          var _object$parsedStyle = object.parsedStyle,
            cx = _object$parsedStyle.cx,
            cy = _object$parsedStyle.cy;
          if (!isNil(cx)) {
            x = cx;
          }
          if (!isNil(cy)) {
            y = cy;
          }
          break;
        case Shape.LINE:
          var _object$parsedStyle2 = object.parsedStyle,
            x1 = _object$parsedStyle2.x1,
            x2 = _object$parsedStyle2.x2,
            y1 = _object$parsedStyle2.y1,
            y2 = _object$parsedStyle2.y2;
          var minX = Math.min(x1, x2);
          var minY = Math.min(y1, y2);
          x = minX;
          y = minY;
          z = 0;
          break;
        case Shape.RECT:
        case Shape.IMAGE:
        case Shape.GROUP:
        case Shape.HTML:
        case Shape.TEXT:
        case Shape.MESH:
          if (!isNil(object.parsedStyle.x)) {
            x = object.parsedStyle.x;
          }
          if (!isNil(object.parsedStyle.y)) {
            y = object.parsedStyle.y;
          }
          break;
      }
      if (object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE && object.nodeName !== Shape.POLYGON) {
        object.parsedStyle.defX = x || 0;
        object.parsedStyle.defY = y || 0;
      }
      var needResetLocalPosition = !isNil(x) || !isNil(y) || !isNil(z);
      // only if `transform` won't be processed later
      if (needResetLocalPosition && attributes.indexOf('transform') === -1) {
        // account for current transform if needed
        var transform = object.parsedStyle.transform;
        if (transform && transform.length) {
          parsedTransformToMat4(transform, object);
        } else {
          var _object$getLocalPosit = object.getLocalPosition(),
            ox = _object$getLocalPosit[0],
            oy = _object$getLocalPosit[1],
            oz = _object$getLocalPosit[2];
          object.setLocalPosition(isNil(x) ? ox : x, isNil(y) ? oy : y, isNil(z) ? oz : z);
        }
      }
    };
    return CSSPropertyLocalPosition;
  }(CSSPropertyLengthOrPercentage);

  var CSSPropertyMarker = /*#__PURE__*/function () {
    function CSSPropertyMarker() {}
    var _proto = CSSPropertyMarker.prototype;
    _proto.calculator = function calculator(name, oldMarker, newMarker, object) {
      var _newMarker;
      // unset
      if (newMarker instanceof CSSKeywordValue) {
        newMarker = null;
      }
      var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
      if (cloned) {
        // FIXME: SVG should not inherit parent's style, add a flag here
        cloned.style.isMarker = true;
      }
      return cloned;
    };
    return CSSPropertyMarker;
  }();

  var CSSPropertyNumber = /*#__PURE__*/function () {
    function CSSPropertyNumber() {
      this.mixer = mergeNumbers;
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
    }
    var _proto = CSSPropertyNumber.prototype;
    _proto.calculator = function calculator(name, oldParsed, computed) {
      return computed.value;
    };
    return CSSPropertyNumber;
  }();

  var CSSPropertyOffsetDistance = /*#__PURE__*/function () {
    function CSSPropertyOffsetDistance() {
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
      this.mixer = clampedMergeNumbers(0, 1);
    }
    var _proto = CSSPropertyOffsetDistance.prototype;
    _proto.calculator = function calculator(name, oldParsed, computed) {
      return computed.value;
    };
    _proto.postProcessor = function postProcessor(object) {
      var _object$parsedStyle = object.parsedStyle,
        offsetPath = _object$parsedStyle.offsetPath,
        offsetDistance = _object$parsedStyle.offsetDistance;
      if (!offsetPath) {
        return;
      }
      var nodeName = offsetPath.nodeName;
      if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
        // set position in world space
        var point = offsetPath.getPoint(offsetDistance);
        if (point) {
          object.parsedStyle.defX = point.x;
          object.parsedStyle.defY = point.y;
          object.setLocalPosition(point.x, point.y);
        }
      }
    };
    return CSSPropertyOffsetDistance;
  }();

  /**
   * opacity
   */
  var CSSPropertyOpacity = /*#__PURE__*/function () {
    function CSSPropertyOpacity() {
      this.parser = parseNumber;
      this.parserWithCSSDisabled = null;
      this.mixer = clampedMergeNumbers(0, 1);
    }
    var _proto = CSSPropertyOpacity.prototype;
    _proto.calculator = function calculator(name, oldParsed, computed) {
      return computed.value;
    };
    return CSSPropertyOpacity;
  }();

  /**
   * Axis-Aligned Bounding Box
   *  Frustum Culling p-vertex  n-vertex
   * @see https://github.com/antvis/GWebGPUEngine/issues/3
   */
  var AABB = /*#__PURE__*/function () {
    function AABB() {
      this.center = [0, 0, 0];
      this.halfExtents = [0, 0, 0];
      this.min = [0, 0, 0];
      this.max = [0, 0, 0];
    }
    AABB.isEmpty = function isEmpty(aabb) {
      return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
    };
    var _proto = AABB.prototype;
    // center: vec3 = vec3.create();
    // halfExtents: vec3 = vec3.create();
    // min: vec3 = vec3.create();
    // max: vec3 = vec3.create();
    _proto.update = function update(center, halfExtents) {
      copyVec3(this.center, center);
      copyVec3(this.halfExtents, halfExtents);
      subVec3(this.min, this.center, this.halfExtents);
      addVec3(this.max, this.center, this.halfExtents);
      // vec3.copy(this.center, center);
      // vec3.copy(this.halfExtents, halfExtents);
      // vec3.sub(this.min, this.center, this.halfExtents);
      // vec3.add(this.max, this.center, this.halfExtents);
    };
    _proto.setMinMax = function setMinMax(min, max) {
      // vec3.add(this.center, max, min);
      // vec3.scale(this.center, this.center, 0.5);
      // vec3.sub(this.halfExtents, max, min);
      // vec3.scale(this.halfExtents, this.halfExtents, 0.5);
      // vec3.copy(this.min, min);
      // vec3.copy(this.max, max);
      addVec3(this.center, max, min);
      scaleVec3(this.center, this.center, 0.5);
      subVec3(this.halfExtents, max, min);
      scaleVec3(this.halfExtents, this.halfExtents, 0.5);
      copyVec3(this.min, min);
      copyVec3(this.max, max);
    };
    _proto.getMin = function getMin() {
      return this.min;
    };
    _proto.getMax = function getMax() {
      return this.max;
    };
    _proto.add = function add(aabb) {
      if (AABB.isEmpty(aabb)) {
        return;
      }
      if (AABB.isEmpty(this)) {
        this.setMinMax(aabb.getMin(), aabb.getMax());
        return;
      }
      var tc = this.center;
      var tcx = tc[0];
      var tcy = tc[1];
      var tcz = tc[2];
      var th = this.halfExtents;
      var thx = th[0];
      var thy = th[1];
      var thz = th[2];
      var tminx = tcx - thx;
      var tmaxx = tcx + thx;
      var tminy = tcy - thy;
      var tmaxy = tcy + thy;
      var tminz = tcz - thz;
      var tmaxz = tcz + thz;
      var oc = aabb.center;
      var ocx = oc[0];
      var ocy = oc[1];
      var ocz = oc[2];
      var oh = aabb.halfExtents;
      var ohx = oh[0];
      var ohy = oh[1];
      var ohz = oh[2];
      var ominx = ocx - ohx;
      var omaxx = ocx + ohx;
      var ominy = ocy - ohy;
      var omaxy = ocy + ohy;
      var ominz = ocz - ohz;
      var omaxz = ocz + ohz;
      if (ominx < tminx) {
        tminx = ominx;
      }
      if (omaxx > tmaxx) {
        tmaxx = omaxx;
      }
      if (ominy < tminy) {
        tminy = ominy;
      }
      if (omaxy > tmaxy) {
        tmaxy = omaxy;
      }
      if (ominz < tminz) {
        tminz = ominz;
      }
      if (omaxz > tmaxz) {
        tmaxz = omaxz;
      }
      tc[0] = (tminx + tmaxx) * 0.5;
      tc[1] = (tminy + tmaxy) * 0.5;
      tc[2] = (tminz + tmaxz) * 0.5;
      th[0] = (tmaxx - tminx) * 0.5;
      th[1] = (tmaxy - tminy) * 0.5;
      th[2] = (tmaxz - tminz) * 0.5;
      this.min[0] = tminx;
      this.min[1] = tminy;
      this.min[2] = tminz;
      this.max[0] = tmaxx;
      this.max[1] = tmaxy;
      this.max[2] = tmaxz;
    };
    _proto.setFromTransformedAABB = function setFromTransformedAABB(aabb, m) {
      var bc = this.center;
      var br = this.halfExtents;
      var ac = aabb.center;
      var ar = aabb.halfExtents;
      var mx0 = m[0];
      var mx1 = m[4];
      var mx2 = m[8];
      var my0 = m[1];
      var my1 = m[5];
      var my2 = m[9];
      var mz0 = m[2];
      var mz1 = m[6];
      var mz2 = m[10];
      var mx0a = Math.abs(mx0);
      var mx1a = Math.abs(mx1);
      var mx2a = Math.abs(mx2);
      var my0a = Math.abs(my0);
      var my1a = Math.abs(my1);
      var my2a = Math.abs(my2);
      var mz0a = Math.abs(mz0);
      var mz1a = Math.abs(mz1);
      var mz2a = Math.abs(mz2);
      bc[0] = m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
      bc[1] = m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
      bc[2] = m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
      // vec3.set(
      //   bc,
      //   m[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2],
      //   m[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2],
      //   m[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2],
      // );
      br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
      br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
      br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
      // vec3.set(
      //   br,
      //   mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2],
      //   my0a * ar[0] + my1a * ar[1] + my2a * ar[2],
      //   mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2],
      // );
      // this.min = vec3.sub(this.min, bc, br);
      // this.max = vec3.add(this.max, bc, br);
      subVec3(this.min, bc, br);
      addVec3(this.max, bc, br);
    };
    _proto.intersects = function intersects(aabb) {
      var aMax = this.getMax();
      var aMin = this.getMin();
      var bMax = aabb.getMax();
      var bMin = aabb.getMin();
      return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
    };
    _proto.intersection = function intersection(aabb) {
      if (!this.intersects(aabb)) {
        return null;
      }
      var intersection = new AABB();
      // const min = vec3.max(vec3.create(), this.getMin(), aabb.getMin());
      // const max = vec3.min(vec3.create(), this.getMax(), aabb.getMax());
      var min = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
      var max = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
      intersection.setMinMax(min, max);
      return intersection;
    }
    // containsPoint(point: vec3) {
    //   const min = this.getMin();
    //   const max = this.getMax();
    //   return !(
    //     point[0] < min[0] ||
    //     point[0] > max[0] ||
    //     point[1] < min[1] ||
    //     point[1] > max[1] ||
    //     point[2] < min[2] ||
    //     point[2] > max[2]
    //   );
    // }
    /**
     * get n-vertex
     * @param plane plane of CullingVolume
     */;
    _proto.getNegativeFarPoint = function getNegativeFarPoint(plane) {
      if (plane.pnVertexFlag === 0x111) {
        return copyVec3([0, 0, 0], this.min);
        // return vec3.copy(vec3.create(), this.min);
      } else if (plane.pnVertexFlag === 0x110) {
        return [this.min[0], this.min[1], this.max[2]];
        // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
      } else if (plane.pnVertexFlag === 0x101) {
        return [this.min[0], this.max[1], this.min[2]];
        // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
      } else if (plane.pnVertexFlag === 0x100) {
        return [this.min[0], this.max[1], this.max[2]];
        // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
      } else if (plane.pnVertexFlag === 0x011) {
        return [this.max[0], this.min[1], this.min[2]];
        // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
      } else if (plane.pnVertexFlag === 0x010) {
        return [this.max[0], this.min[1], this.max[2]];
        // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
      } else if (plane.pnVertexFlag === 0x001) {
        return [this.max[0], this.max[1], this.min[2]];
        // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
      } else {
        return [this.max[0], this.max[1], this.max[2]];
        // return vec3.fromValues(this.max[0], this.max[1], this.max[2]);
      }
    }
    /**
     * get p-vertex
     * @param plane plane of CullingVolume
     */;
    _proto.getPositiveFarPoint = function getPositiveFarPoint(plane) {
      if (plane.pnVertexFlag === 0x111) {
        return copyVec3([0, 0, 0], this.max);
        // return vec3.copy(vec3.create(), this.max);
      } else if (plane.pnVertexFlag === 0x110) {
        return [this.max[0], this.max[1], this.min[2]];
        // return vec3.fromValues(this.max[0], this.max[1], this.min[2]);
      } else if (plane.pnVertexFlag === 0x101) {
        return [this.max[0], this.min[1], this.max[2]];
        // return vec3.fromValues(this.max[0], this.min[1], this.max[2]);
      } else if (plane.pnVertexFlag === 0x100) {
        return [this.max[0], this.min[1], this.min[2]];
        // return vec3.fromValues(this.max[0], this.min[1], this.min[2]);
      } else if (plane.pnVertexFlag === 0x011) {
        return [this.min[0], this.max[1], this.max[2]];
        // return vec3.fromValues(this.min[0], this.max[1], this.max[2]);
      } else if (plane.pnVertexFlag === 0x010) {
        return [this.min[0], this.max[1], this.min[2]];
        // return vec3.fromValues(this.min[0], this.max[1], this.min[2]);
      } else if (plane.pnVertexFlag === 0x001) {
        return [this.min[0], this.min[1], this.max[2]];
        // return vec3.fromValues(this.min[0], this.min[1], this.max[2]);
      } else {
        return [this.min[0], this.min[1], this.min[2]];
        // return vec3.fromValues(this.min[0], this.min[1], this.min[2]);
      }
    };
    return AABB;
  }();

  var Plane = /*#__PURE__*/function () {
    /**
     * lookup table for p-vertex & n-vertex when doing frustum culling
     */

    function Plane(distance, normal) {
      this.distance = void 0;
      this.normal = void 0;
      this.pnVertexFlag = void 0;
      this.distance = distance || 0;
      this.normal = normal || fromValues$2(0, 1, 0);
      this.updatePNVertexFlag();
    }
    var _proto = Plane.prototype;
    _proto.updatePNVertexFlag = function updatePNVertexFlag() {
      this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
    };
    _proto.distanceToPoint = function distanceToPoint(point) {
      return dot(point, this.normal) - this.distance;
    };
    _proto.normalize = function normalize() {
      var invLen = 1 / len(this.normal);
      scale$1(this.normal, this.normal, invLen);
      this.distance *= invLen;
    };
    _proto.intersectsLine = function intersectsLine(start, end, point) {
      var d0 = this.distanceToPoint(start);
      var d1 = this.distanceToPoint(end);
      var t = d0 / (d0 - d1);
      var intersects = t >= 0 && t <= 1;
      if (intersects && point) {
        lerp(point, start, end, t);
      }
      return intersects;
    };
    return Plane;
  }();

  var Mask;
  (function (Mask) {
    Mask[Mask["OUTSIDE"] = 4294967295] = "OUTSIDE";
    Mask[Mask["INSIDE"] = 0] = "INSIDE";
    Mask[Mask["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  })(Mask || (Mask = {}));
  var Frustum = /*#__PURE__*/function () {
    function Frustum(planes) {
      this.planes = [];
      if (planes) {
        this.planes = planes;
      } else {
        for (var i = 0; i < 6; i++) {
          this.planes.push(new Plane());
        }
      }
    }
    /**
     * extract 6 planes from projectionMatrix
     * @see http://www8.cs.umu.se/kurser/5DV051/HT12/lab/plane_extraction.pdf
     */
    var _proto = Frustum.prototype;
    _proto.extractFromVPMatrix = function extractFromVPMatrix(projectionMatrix) {
      // @ts-ignore
      var m0 = projectionMatrix[0],
        m1 = projectionMatrix[1],
        m2 = projectionMatrix[2],
        m3 = projectionMatrix[3],
        m4 = projectionMatrix[4],
        m5 = projectionMatrix[5],
        m6 = projectionMatrix[6],
        m7 = projectionMatrix[7],
        m8 = projectionMatrix[8],
        m9 = projectionMatrix[9],
        m10 = projectionMatrix[10],
        m11 = projectionMatrix[11],
        m12 = projectionMatrix[12],
        m13 = projectionMatrix[13],
        m14 = projectionMatrix[14],
        m15 = projectionMatrix[15];
      // right
      set$1(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
      this.planes[0].distance = m15 - m12;
      // left
      set$1(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
      this.planes[1].distance = m15 + m12;
      // bottom
      set$1(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
      this.planes[2].distance = m15 + m13;
      // top
      set$1(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
      this.planes[3].distance = m15 - m13;
      // far
      set$1(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
      this.planes[4].distance = m15 - m14;
      // near
      set$1(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
      this.planes[5].distance = m15 + m14;
      this.planes.forEach(function (plane) {
        plane.normalize();
        plane.updatePNVertexFlag();
      });
    };
    return Frustum;
  }();

  var Point = /*#__PURE__*/function () {
    function Point(x, y) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      this.x = 0;
      this.y = 0;
      this.x = x;
      this.y = y;
    }
    var _proto = Point.prototype;
    _proto.clone = function clone() {
      return new Point(this.x, this.y);
    };
    _proto.copyFrom = function copyFrom(p) {
      this.x = p.x;
      this.y = p.y;
    };
    return Point;
  }();

  var Rectangle = /*#__PURE__*/function () {
    function Rectangle(x, y, width, height) {
      this.x = void 0;
      this.y = void 0;
      this.width = void 0;
      this.height = void 0;
      this.left = void 0;
      this.right = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.left = x;
      this.right = x + width;
      this.top = y;
      this.bottom = y + height;
    }
    var _proto = Rectangle.prototype;
    _proto.toJSON = function toJSON() {};
    return Rectangle;
  }();

  var CSSPropertyPath = /*#__PURE__*/function () {
    function CSSPropertyPath() {
      /**
       * path2Curve
       */
      this.parser = parsePath;
      this.parserWithCSSDisabled = parsePath;
      this.mixer = mergePaths;
    }
    var _proto = CSSPropertyPath.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed) {
      // unset
      if (parsed instanceof CSSKeywordValue && parsed.value === 'unset') {
        return {
          absolutePath: [],
          hasArc: false,
          segments: [],
          polygons: [],
          polylines: [],
          curve: null,
          totalLength: 0,
          rect: new Rectangle(0, 0, 0, 0)
        };
      }
      return parsed;
    };
    /**
     * update local position
     */
    _proto.postProcessor = function postProcessor(object, attributes) {
      if (object.nodeName === Shape.PATH && attributes.indexOf('transform') === -1) {
        var _object$parsedStyle = object.parsedStyle,
          _object$parsedStyle$d = _object$parsedStyle.defX,
          defX = _object$parsedStyle$d === void 0 ? 0 : _object$parsedStyle$d,
          _object$parsedStyle$d2 = _object$parsedStyle.defY,
          defY = _object$parsedStyle$d2 === void 0 ? 0 : _object$parsedStyle$d2;
        object.setLocalPosition(defX, defY);
      }
    };
    return CSSPropertyPath;
  }();

  var CSSPropertyPoints = /*#__PURE__*/function () {
    function CSSPropertyPoints() {
      this.parser = parsePoints;
      this.mixer = mergePoints;
    }
    var _proto = CSSPropertyPoints.prototype;
    /**
     * update local position
     */
    _proto.postProcessor = function postProcessor(object, attributes) {
      if ((object.nodeName === Shape.POLYGON || object.nodeName === Shape.POLYLINE) && attributes.indexOf('transform') === -1) {
        var _object$parsedStyle = object.parsedStyle,
          defX = _object$parsedStyle.defX,
          defY = _object$parsedStyle.defY;
        object.setLocalPosition(defX, defY);
      }
    };
    return CSSPropertyPoints;
  }();

  var CSSPropertyShadowBlur = /*#__PURE__*/function (_CSSPropertyLengthOrP) {
    _inheritsLoose(CSSPropertyShadowBlur, _CSSPropertyLengthOrP);
    function CSSPropertyShadowBlur() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _CSSPropertyLengthOrP.call.apply(_CSSPropertyLengthOrP, [this].concat(args)) || this;
      _this.mixer = clampedMergeNumbers(0, Infinity);
      return _this;
    }
    return CSSPropertyShadowBlur;
  }(CSSPropertyLengthOrPercentage);

  var CSSPropertyText = /*#__PURE__*/function () {
    function CSSPropertyText() {}
    var _proto = CSSPropertyText.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed, object) {
      if (parsed instanceof CSSKeywordValue) {
        if (parsed.value === 'unset') {
          return '';
        } else {
          return parsed.value;
        }
      }
      // allow number as valid text content
      return "" + parsed;
    };
    _proto.postProcessor = function postProcessor(object) {
      object.nodeValue = "" + object.parsedStyle.text || '';
    };
    return CSSPropertyText;
  }();

  /**
   * it must transform after text get parsed
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-transform
   */
  var CSSPropertyTextTransform = /*#__PURE__*/function () {
    function CSSPropertyTextTransform() {}
    var _proto = CSSPropertyTextTransform.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed, object) {
      var rawText = object.getAttribute('text');
      if (rawText) {
        var transformedText = rawText;
        if (parsed.value === 'capitalize') {
          transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
        } else if (parsed.value === 'lowercase') {
          transformedText = rawText.toLowerCase();
        } else if (parsed.value === 'uppercase') {
          transformedText = rawText.toUpperCase();
        }
        object.parsedStyle.text = transformedText;
      }
      return parsed.value;
    };
    return CSSPropertyTextTransform;
  }();

  /**
   * @see /zh/docs/api/animation#
   *
   * support the following formats like CSS Transform:
   *
   * scale
   * * scale(x, y)
   * * scaleX(x)
   * * scaleY(x)
   * * scaleZ(z)
   * * scale3d(x, y, z)
   *
   * translate (unit: none, px, %(relative to its bounds))
   * * translate(x, y) eg. translate(0, 0) translate(0, 30px) translate(100%, 100%)
   * * translateX(0)
   * * translateY(0)
   * * translateZ(0)
   * * translate3d(0, 0, 0)
   *
   * rotate (unit: deg rad turn)
   * * rotate(0.5turn) rotate(30deg) rotate(1rad)
   *
   * none
   *
   * unsupported for now:
   * * calc() eg. translate(calc(100% + 10px))
   * * matrix/matrix3d()
   * * skew/skewX/skewY
   * * perspective
   */
  var CSSPropertyTransform = /*#__PURE__*/function () {
    function CSSPropertyTransform() {
      this.parser = parseTransform;
      this.parserWithCSSDisabled = parseTransform;
      this.mixer = mergeTransforms;
    }
    var _proto = CSSPropertyTransform.prototype;
    _proto.calculator = function calculator(name, oldParsed, parsed, object) {
      // 'none'
      if (parsed instanceof CSSKeywordValue) {
        return [];
      }
      return parsed;
    };
    _proto.postProcessor = function postProcessor(object) {
      var transform = object.parsedStyle.transform;
      parsedTransformToMat4(transform, object);
    };
    return CSSPropertyTransform;
  }();

  /**
   * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin
   * @example
   * [10px, 10px] [10%, 10%]
   */
  var CSSPropertyTransformOrigin = function CSSPropertyTransformOrigin() {
    this.parser = parseTransformOrigin;
  };

  var CSSPropertyZIndex = /*#__PURE__*/function () {
    function CSSPropertyZIndex() {
      this.parser = parseNumber;
    }
    var _proto = CSSPropertyZIndex.prototype;
    _proto.calculator = function calculator(name, oldParsed, computed, object) {
      return computed.value;
    };
    _proto.postProcessor = function postProcessor(object) {
      if (object.parentNode) {
        var parentEntity = object.parentNode;
        var parentRenderable = parentEntity.renderable;
        var parentSortable = parentEntity.sortable;
        if (parentRenderable) {
          parentRenderable.dirty = true;
        }
        // need re-sort on parent
        if (parentSortable) {
          parentSortable.dirty = true;
        }
      }
    };
    return CSSPropertyZIndex;
  }();

  /**
   * canvas.customElements
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry
   */
  var CustomElementRegistry = /*#__PURE__*/function () {
    function CustomElementRegistry() {
      this.registry = {};
      this.define(Shape.CIRCLE, Circle);
      this.define(Shape.ELLIPSE, Ellipse);
      this.define(Shape.RECT, Rect);
      this.define(Shape.IMAGE, Image);
      this.define(Shape.LINE, Line);
      this.define(Shape.GROUP, Group);
      this.define(Shape.PATH, Path);
      this.define(Shape.POLYGON, Polygon);
      this.define(Shape.POLYLINE, Polyline);
      this.define(Shape.TEXT, Text);
      this.define(Shape.HTML, HTML);
    }
    var _proto = CustomElementRegistry.prototype;
    _proto.define = function define(name, constructor) {
      this.registry[name] = constructor;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
     */;
    _proto.get = function get(name) {
      return this.registry[name];
    };
    return CustomElementRegistry;
  }();

  function isFederatedEvent(value) {
    return !!value.type;
  }
  /**
   * An DOM-compatible synthetic event implementation that is "forwarded" on behalf of an original
   * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.
   */
  var FederatedEvent = /*#__PURE__*/function () {
    /**
     * The event boundary which manages this event. Propagation can only occur
     *  within the boundary's jurisdiction.
     */
    function FederatedEvent(manager) {
      /**
       * The type of event, supports the following:
       * * pointerdown
       * * touchstart
       * * mousedown
       * * rightdown
       * * ...
       */
      this.type = void 0;
      /**
       * The propagation phase.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase
       */
      this.eventPhase = FederatedEvent.prototype.NONE;
      /**
       * can be used to implement event delegation
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/target
       */
      this.target = void 0;
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/bubbles
       */
      this.bubbles = true;
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/cancelBubble
       */
      this.cancelBubble = true;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable
       */
      this.cancelable = false;
      /** the event target when listeners binded */
      this.currentTarget = void 0;
      /** Flags whether the default response of the user agent was prevent through this event. */
      this.defaultPrevented = false;
      /**
       * timestamp when the event created
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/timeStamp
       */
      this.timeStamp = void 0;
      /**
       * the original event.
       */
      this.nativeEvent = void 0;
      /** The original event that caused this event, if any. */
      this.originalEvent = void 0;
      /** Flags whether propagation was stopped. */
      this.propagationStopped = false;
      /** Flags whether propagation was immediately stopped. */
      this.propagationImmediatelyStopped = false;
      this.manager = void 0;
      /** Event-specific detail */
      this.detail = void 0;
      /**
       * The coordinates of the evnet relative to the nearest DOM layer.
       * This is a non-standard property.
       */
      this.layer = new Point();
      /**
       * The coordinates of the event relative to the DOM document.
       * This is a non-standard property.
       * relative to the DOM document.
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX
       */
      this.page = new Point();
      /**
       * relative to Canvas, origin is left-top
       */
      this.canvas = new Point();
      /**
       * relative to Viewport, account for Camera
       */
      this.viewport = new Point();
      this.path = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
       */
      this.view = void 0;
      this.which = void 0;
      this.returnValue = void 0;
      this.srcElement = void 0;
      this.composed = false;
      this.isTrusted = void 0;
      this.NONE = 0;
      this.CAPTURING_PHASE = 1;
      this.AT_TARGET = 2;
      this.BUBBLING_PHASE = 3;
      this.manager = manager;
    }
    var _proto = FederatedEvent.prototype;
    /**
     * The propagation path for this event
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
     *
     * So composedPath()[0] represents the original target.
     * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
     */
    _proto.composedPath = function composedPath() {
      if (this.manager && (!this.path || this.path[0] !== this.target)) {
        this.path = this.target ? this.manager.propagationPath(this.target) : [];
      }
      return this.path;
    }
    /**
     * @deprecated
     */;
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
     */
    _proto.preventDefault = function preventDefault() {
      if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
        this.nativeEvent.preventDefault();
      }
      this.defaultPrevented = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
     */;
    _proto.stopImmediatePropagation = function stopImmediatePropagation() {
      this.propagationImmediatelyStopped = true;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
     */;
    _proto.stopPropagation = function stopPropagation() {
      this.propagationStopped = true;
    };
    /**
     * added for compatibility with DOM Event,
     * deprecated props and methods
     */
    _proto.initEvent = function initEvent() {};
    _proto.initUIEvent = function initUIEvent() {};
    _proto.clone = function clone() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _createClass(FederatedEvent, [{
      key: "name",
      get:
      /**
       * @deprecated
       */
      function get() {
        return this.type;
      }
    }, {
      key: "layerX",
      get: function get() {
        return this.layer.x;
      }
    }, {
      key: "layerY",
      get: function get() {
        return this.layer.y;
      }
    }, {
      key: "pageX",
      get: function get() {
        return this.page.x;
      }
    }, {
      key: "pageY",
      get: function get() {
        return this.page.y;
      }
    }, {
      key: "x",
      get: function get() {
        return this.canvas.x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.canvas.y;
      }
    }, {
      key: "canvasX",
      get: function get() {
        return this.canvas.x;
      }
    }, {
      key: "canvasY",
      get: function get() {
        return this.canvas.y;
      }
    }, {
      key: "viewportX",
      get: function get() {
        return this.viewport.x;
      }
    }, {
      key: "viewportY",
      get: function get() {
        return this.viewport.y;
      }
    }, {
      key: "propagationPath",
      get: function get() {
        return this.composedPath();
      }
    }]);
    return FederatedEvent;
  }();

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events
   *
   * @example
    const event = new CustomEvent('build', { detail: { prop1: 'xx' } });
    circle.addEventListener('build', (e) => {
      e.target; // circle
      e.detail; // { prop1: 'xx' }
    });

    circle.dispatchEvent(event);
   */
  var CustomEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inheritsLoose(CustomEvent, _FederatedEvent);
    // eslint-disable-next-line @typescript-eslint/ban-types
    function CustomEvent(eventName, object) {
      var _this;
      _this = _FederatedEvent.call(this, null) || this;
      _this.type = eventName;
      _this.detail = object;
      // compatible with G 3.0
      Object.assign(_assertThisInitialized(_this), object);
      return _this;
    }
    return CustomEvent;
  }(FederatedEvent);

  var DELEGATION_SPLITTER = ':';
  /**
   * Objects that can receive events and may have listeners for them.
   * eg. Element, Canvas, DisplayObject
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
   */
  var EventTarget = /*#__PURE__*/function () {
    function EventTarget() {
      /**
       * event emitter
       */
      this.emitter = new eventemitter3();
    }
    var _proto = EventTarget.prototype;
    /**
     * @deprecated
     * @alias addEventListener
     */
    _proto.on = function on(type, listener, options) {
      this.addEventListener(type, listener, options);
      return this;
    }
    /**
     * support `capture` & `once` in options
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
     */;
    _proto.addEventListener = function addEventListener(type, listener, options) {
      var capture = isBoolean(options) && options || isObject(options) && options.capture;
      var once = isObject(options) && options.once;
      var context = isFunction$1(listener) ? undefined : listener;
      // compatible with G 3.0
      // support using delegate name in event type, eg. 'node:click'
      var useDelegatedName = false;
      var delegatedName = '';
      if (type.indexOf(DELEGATION_SPLITTER) > -1) {
        var _type$split = type.split(DELEGATION_SPLITTER),
          name = _type$split[0],
          eventType = _type$split[1];
        type = eventType;
        delegatedName = name;
        useDelegatedName = true;
      }
      type = capture ? type + "capture" : type;
      listener = isFunction$1(listener) ? listener : listener.handleEvent;
      // compatible with G 3.0
      if (useDelegatedName) {
        var originListener = listener;
        listener = function listener() {
          var _args$0$target;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (((_args$0$target = args[0].target) === null || _args$0$target === void 0 ? void 0 : _args$0$target.name) !== delegatedName) {
            return;
          }
          // @ts-ignore
          originListener.apply(void 0, args);
        };
      }
      if (once) {
        this.emitter.once(type, listener, context);
      } else {
        this.emitter.on(type, listener, context);
      }
      return this;
    }
    /**
     * @deprecated
     * @alias removeEventListener
     */;
    _proto.off = function off(type, listener, options) {
      if (type) {
        this.removeEventListener(type, listener, options);
      } else {
        // remove all listeners
        this.removeAllEventListeners();
      }
      return this;
    };
    _proto.removeAllEventListeners = function removeAllEventListeners() {
      this.emitter.removeAllListeners();
    };
    _proto.removeEventListener = function removeEventListener(type, listener, options) {
      var _listener;
      var capture = isBoolean(options) && options || isObject(options) && options.capture;
      var context = isFunction$1(listener) ? undefined : listener;
      type = capture ? type + "capture" : type;
      listener = isFunction$1(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
      this.emitter.off(type, listener, context);
      return this;
    }
    /**
     * @deprecated
     * @alias dispatchEvent
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    ;
    _proto.emit = function emit(eventName, object) {
      this.dispatchEvent(new CustomEvent(eventName, object));
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
     */;
    _proto.dispatchEvent = function dispatchEvent(e, skipPropagate) {
      if (skipPropagate === void 0) {
        skipPropagate = false;
      }
      if (!isFederatedEvent(e)) {
        throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
      }
      // should account for Element / Document / Canvas
      var canvas;
      // @ts-ignore
      if (this.document) {
        canvas = this;
        // @ts-ignore
      } else if (this.defaultView) {
        canvas = this.defaultView;
      } else {
        var _this$ownerDocument;
        canvas = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView;
      }
      // assign event manager
      if (canvas) {
        var _e$manager;
        e.manager = canvas.getEventService() || null;
        if (!e.manager) {
          return false;
        }
        e.defaultPrevented = false;
        e.path = [];
        if (!skipPropagate) {
          e.target = this;
        }
        (_e$manager = e.manager) === null || _e$manager === void 0 ? void 0 : _e$manager.dispatchEvent(e, e.type, skipPropagate);
      }
      return !e.defaultPrevented;
    };
    return EventTarget;
  }();

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node
   */
  var Node$1 = /*#__PURE__*/function (_EventTarget) {
    _inheritsLoose(Node, _EventTarget);
    function Node() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _EventTarget.call.apply(_EventTarget, [this].concat(args)) || this;
      _this.shadow = false;
      /**
       * points to canvas.document
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/ownerDocument
       */
      _this.ownerDocument = null;
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isConnected
       * @example
          circle.isConnected; // false
          canvas.appendChild(circle);
          circle.isConnected; // true
       */
      _this.isConnected = false;
      /**
       * Returns node's node document's document base URL.
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node
       */
      _this.baseURI = '';
      /**
       * Returns the children.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes
       */
      _this.childNodes = [];
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType
       */
      _this.nodeType = 0;
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeName
       */
      _this.nodeName = '';
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeValue
       */
      _this.nodeValue = null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ParentNode
       */
      _this.parentNode = null;
      return _this;
    }
    Node.isNode = function isNode(target) {
      return !!target.childNodes;
    };
    var _proto = Node.prototype;
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
     */
    _proto.getRootNode = function getRootNode(opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (this.parentNode) {
        return this.parentNode.getRootNode(opts);
      }
      if (opts.composed && this.host) {
        return this.host.getRootNode(opts);
      }
      return this;
    };
    _proto.hasChildNodes = function hasChildNodes() {
      return this.childNodes.length > 0;
    };
    _proto.isDefaultNamespace = function isDefaultNamespace(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.lookupNamespaceURI = function lookupNamespaceURI(prefix) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.lookupPrefix = function lookupPrefix(namespace) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.normalize = function normalize() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
     */;
    _proto.isEqualNode = function isEqualNode(otherNode) {
      // TODO: compare 2 nodes, not sameness
      return this === otherNode;
    };
    _proto.isSameNode = function isSameNode(otherNode) {
      return this.isEqualNode(otherNode);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
     * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
     */
    _proto.compareDocumentPosition = function compareDocumentPosition(other) {
      if (other === this) {
        // same node
        return 0;
      }
      if (!(other instanceof Node)) {
        throw new TypeError('Node.compareDocumentPosition: Argument 1 does not implement interface Node.');
      }
      var node1Root = other;
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var node2Root = this;
      var node1Hierarchy = [node1Root];
      var node2Hierarchy = [node2Root];
      while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
        var _node1Root$parentNode;
        node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
        node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
      }
      // Check if they don't share the same root node
      if (node1Root !== node2Root) {
        return Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING;
      }
      var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
      var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
      // Check if either is a container of the other
      if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
        return longerHierarchy === node1Hierarchy ?
        // other is a child of this
        Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING :
        // this is a child of other
        Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;
      }
      // Find their first common ancestor and see whether they
      // are preceding or following
      var longerStart = longerHierarchy.length - shorterHierarchy.length;
      for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
        var shorterHierarchyNode = shorterHierarchy[i];
        var longerHierarchyNode = longerHierarchy[longerStart + i];
        // We found the first common ancestor
        if (longerHierarchyNode !== shorterHierarchyNode) {
          var siblings = shorterHierarchyNode.parentNode.childNodes;
          if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
            // Shorter is before longer
            if (shorterHierarchy === node1Hierarchy) {
              // Other is before this
              return Node.DOCUMENT_POSITION_PRECEDING;
            } else {
              // This is before other
              return Node.DOCUMENT_POSITION_FOLLOWING;
            }
          } else {
            // Longer is before shorter
            if (longerHierarchy === node1Hierarchy) {
              // Other is before this
              return Node.DOCUMENT_POSITION_PRECEDING;
            } else {
              // Other is after this
              return Node.DOCUMENT_POSITION_FOLLOWING;
            }
          }
        }
      }
      return Node.DOCUMENT_POSITION_FOLLOWING;
    }
    /**
     * @deprecated
     * @alias contains
     */;
    _proto.contain = function contain(other) {
      return this.contains(other);
    };
    _proto.contains = function contains(other) {
      // the node itself, one of its direct children
      var tmp = other;
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/contains
      while (tmp && this !== tmp) {
        tmp = tmp.parentNode;
      }
      return !!tmp;
    };
    _proto.getAncestor = function getAncestor(n) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      var temp = this;
      while (n > 0 && temp) {
        temp = temp.parentNode;
        n--;
      }
      return temp;
    };
    _proto.forEach = function forEach(callback, assigned) {
      if (assigned === void 0) {
        assigned = false;
      }
      if (!callback(this)) {
        (assigned ? this.childNodes.slice() : this.childNodes).forEach(function (child) {
          child.forEach(callback);
        });
      }
    };
    _createClass(Node, [{
      key: "textContent",
      get:
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
       */
      function get() {
        var out = '';
        if (this.nodeName === Shape.TEXT) {
          // @ts-ignore
          out += this.style.text;
        }
        for (var _iterator = _createForOfIteratorHelperLoose(this.childNodes), _step; !(_step = _iterator()).done;) {
          var child = _step.value;
          if (child.nodeName === Shape.TEXT) {
            out += child.nodeValue;
          } else {
            out += child.textContent;
          }
        }
        return out;
      },
      set: function set(content) {
        var _this2 = this;
        // remove all children
        this.childNodes.slice().forEach(function (child) {
          _this2.removeChild(child);
        });
        if (this.nodeName === Shape.TEXT) {
          // @ts-ignore
          this.style.text = "" + content;
        }
      }
    }, {
      key: "parent",
      get:
      /**
       * @deprecated
       * @alias parentNode
       */
      function get() {
        return this.parentNode;
      }
    }, {
      key: "parentElement",
      get: function get() {
        return null;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get() {
        return null;
      }
    }, {
      key: "firstChild",
      get: function get() {
        return this.childNodes.length > 0 ? this.childNodes[0] : null;
      }
    }, {
      key: "lastChild",
      get: function get() {
        return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
      }
    }]);
    return Node;
  }(EventTarget);
  /**
   * Both nodes are in different documents or different trees in the same document.
   */
  Node$1.DOCUMENT_POSITION_DISCONNECTED = 1;
  /**
   * otherNode precedes the node in either a pre-order depth-first traversal
   * of a tree containing both (e.g., as an ancestor or previous sibling or a descendant of a previous sibling or previous sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
   */
  Node$1.DOCUMENT_POSITION_PRECEDING = 2;
  /**
   * otherNode follows the node in either a pre-order depth-first traversal of a tree containing both (e.g., as a descendant or following sibling or a descendant of a following sibling or following sibling of an ancestor) or (if they are disconnected) in an arbitrary but consistent ordering.
   */
  Node$1.DOCUMENT_POSITION_FOLLOWING = 4;
  /**
   * otherNode is an ancestor of the node.
   */
  Node$1.DOCUMENT_POSITION_CONTAINS = 8;
  /**
   * otherNode is a descendant of the node.
   */
  Node$1.DOCUMENT_POSITION_CONTAINED_BY = 16;
  /**
   * The result relies upon arbitrary and/or implementation-specific behavior and is not guaranteed to be portable.
   */
  Node$1.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;

  /**
   * the entry of DOM tree
   * Document -> Node -> EventTarget
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document
   */
  var Document = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Document, _Node);
    function Document() {
      var _this;
      _this = _Node.call(this) || this;
      /**
       * only document has defaultView, points to canvas,
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/defaultView
       */
      _this.defaultView = null;
      /**
       * the root element of document, eg. <html>
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement
       */
      _this.documentElement = void 0;
      /**
       * document.timeline in WAAPI
       */
      _this.timeline = void 0;
      _this.ownerDocument = null;
      _this.nodeName = 'document';
      // create timeline
      try {
        _this.timeline = new runtime.AnimationTimeline(_assertThisInitialized(_this));
      } catch (e) {}
      /**
       * for inherited properties, the initial value is used on the root element only,
       * as long as no specified value is supplied.
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial_value
       */
      var initialStyle = {};
      BUILT_IN_PROPERTIES.forEach(function (_ref) {
        var n = _ref.n,
          inh = _ref.inh,
          d = _ref.d;
        if (inh && d) {
          initialStyle[n] = isFunction$1(d) ? d(Shape.GROUP) : d;
        }
      });
      // like <html> in DOM tree
      _this.documentElement = new Group({
        id: 'g-root',
        style: initialStyle
      });
      _this.documentElement.ownerDocument = _assertThisInitialized(_this);
      _this.documentElement.parentNode = _assertThisInitialized(_this);
      _this.childNodes = [_this.documentElement];
      return _this;
    }
    var _proto = Document.prototype;
    /**
     * @example const circle = document.createElement('circle', { style: { r: 10 } });
     */
    _proto.createElement = function createElement(tagName, options) {
      // @observablehq/plot will create <svg>
      if (tagName === 'svg') {
        return this.documentElement;
      }
      // d3 will use <tspan>
      var clazz = this.defaultView.customElements.get(tagName);
      if (!clazz) {
        console.warn('Unsupported tagName: ', tagName);
        clazz = tagName === 'tspan' ? Text : Group;
      }
      var shape = new clazz(options);
      shape.ownerDocument = this;
      return shape;
    };
    _proto.createElementNS = function createElementNS(namespaceURI, tagName, options) {
      return this.createElement(tagName, options);
    };
    _proto.cloneNode = function cloneNode(deep) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.destroy = function destroy() {
      try {
        this.documentElement.destroyChildren();
        this.timeline.destroy();
      } catch (e) {}
    }
    /**
     * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
     */;
    _proto.elementsFromBBox = function elementsFromBBox(minX, minY, maxX, maxY) {
      var rBush = this.defaultView.context.rBushRoot;
      var rBushNodes = rBush.search({
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
      });
      var hitTestList = [];
      rBushNodes.forEach(function (_ref2) {
        var displayObject = _ref2.displayObject;
        var pointerEvents = displayObject.parsedStyle.pointerEvents;
        // account for `visibility`
        // @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
        var isVisibilityAffected = ['auto', 'visiblepainted', 'visiblefill', 'visiblestroke', 'visible'].includes(pointerEvents);
        if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
          hitTestList.push(displayObject);
        }
      });
      // find group with max z-index
      hitTestList.sort(function (a, b) {
        return b.sortable.renderOrder - a.sortable.renderOrder;
      });
      return hitTestList;
    };
    _proto.elementFromPointSync = function elementFromPointSync(x, y) {
      var _this$defaultView$can = this.defaultView.canvas2Viewport({
          x: x,
          y: y
        }),
        viewportX = _this$defaultView$can.x,
        viewportY = _this$defaultView$can.y;
      var _this$defaultView$get = this.defaultView.getConfig(),
        width = _this$defaultView$get.width,
        height = _this$defaultView$get.height;
      // outside canvas' viewport
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      var _this$defaultView$vie = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }),
        clientX = _this$defaultView$vie.x,
        clientY = _this$defaultView$vie.y;
      var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: true,
          position: {
            x: x,
            y: y,
            viewportX: viewportX,
            viewportY: viewportY,
            clientX: clientX,
            clientY: clientY
          },
          picked: []
        }),
        picked = _this$defaultView$get2.picked;
      return picked && picked[0] || this.documentElement;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
     */;
    _proto.elementFromPoint =
    /*#__PURE__*/
    function () {
      var _elementFromPoint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(x, y) {
        var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                x: x,
                y: y
              }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
              _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height; // outside canvas' viewport
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", null);
            case 4:
              _this$defaultView$vie2 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
              _context.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: true,
                position: {
                  x: x,
                  y: y,
                  viewportX: viewportX,
                  viewportY: viewportY,
                  clientX: clientX,
                  clientY: clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi = _context.sent;
              picked = _yield$this$defaultVi.picked;
              return _context.abrupt("return", picked && picked[0] || this.documentElement);
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function elementFromPoint(_x, _x2) {
        return _elementFromPoint.apply(this, arguments);
      }
      return elementFromPoint;
    }();
    _proto.elementsFromPointSync = function elementsFromPointSync(x, y) {
      var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
          x: x,
          y: y
        }),
        viewportX = _this$defaultView$can3.x,
        viewportY = _this$defaultView$can3.y;
      var _this$defaultView$get4 = this.defaultView.getConfig(),
        width = _this$defaultView$get4.width,
        height = _this$defaultView$get4.height;
      // outside canvas' viewport
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return [];
      }
      var _this$defaultView$vie3 = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }),
        clientX = _this$defaultView$vie3.x,
        clientY = _this$defaultView$vie3.y;
      var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: false,
          position: {
            x: x,
            y: y,
            viewportX: viewportX,
            viewportY: viewportY,
            clientX: clientX,
            clientY: clientY
          },
          picked: []
        }),
        picked = _this$defaultView$get5.picked;
      if (picked[picked.length - 1] !== this.documentElement) {
        picked.push(this.documentElement);
      }
      return picked;
    }
    /**
     * Do picking with API instead of triggering interactive events.
     *
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
     */;
    _proto.elementsFromPoint =
    /*#__PURE__*/
    function () {
      var _elementsFromPoint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x, y) {
        var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                x: x,
                y: y
              }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
              _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height; // outside canvas' viewport
              if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                _context2.next = 4;
                break;
              }
              return _context2.abrupt("return", []);
            case 4:
              _this$defaultView$vie4 = this.defaultView.viewport2Client({
                x: viewportX,
                y: viewportY
              }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
              _context2.next = 7;
              return this.defaultView.getRenderingService().hooks.pick.promise({
                topmost: false,
                position: {
                  x: x,
                  y: y,
                  viewportX: viewportX,
                  viewportY: viewportY,
                  clientX: clientX,
                  clientY: clientY
                },
                picked: []
              });
            case 7:
              _yield$this$defaultVi2 = _context2.sent;
              picked = _yield$this$defaultVi2.picked;
              if (picked[picked.length - 1] !== this.documentElement) {
                picked.push(this.documentElement);
              }
              return _context2.abrupt("return", picked);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function elementsFromPoint(_x3, _x4) {
        return _elementsFromPoint.apply(this, arguments);
      }
      return elementsFromPoint;
    }()
    /**
     * eg. Uncaught DOMException: Failed to execute 'appendChild' on 'Node': Only one element on document allowed.
     */
    ;
    _proto.appendChild = function appendChild(newChild, index) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    _proto.insertBefore = function insertBefore(newChild, refChild) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    _proto.removeChild = function removeChild(oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    _proto.replaceChild = function replaceChild(newChild, oldChild, destroy) {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    _proto.append = function append() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    };
    _proto.prepend = function prepend() {
      throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
    }
    /**
     * Execute query on documentElement.
     */;
    _proto.getElementById = function getElementById(id) {
      return this.documentElement.getElementById(id);
    };
    _proto.getElementsByName = function getElementsByName(name) {
      return this.documentElement.getElementsByName(name);
    };
    _proto.getElementsByTagName = function getElementsByTagName(tagName) {
      return this.documentElement.getElementsByTagName(tagName);
    };
    _proto.getElementsByClassName = function getElementsByClassName(className) {
      return this.documentElement.getElementsByClassName(className);
    };
    _proto.querySelector = function querySelector(selectors) {
      return this.documentElement.querySelector(selectors);
    };
    _proto.querySelectorAll = function querySelectorAll(selectors) {
      return this.documentElement.querySelectorAll(selectors);
    };
    _proto.find = function find(filter) {
      return this.documentElement.find(filter);
    };
    _proto.findAll = function findAll(filter) {
      return this.documentElement.findAll(filter);
    };
    _createClass(Document, [{
      key: "children",
      get: function get() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get() {
        return this.lastChild;
      }
    }]);
    return Document;
  }(Node$1);

  /**
   * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
   */
  var Strategy;
  (function (Strategy) {
    Strategy[Strategy["Standard"] = 0] = "Standard";
  })(Strategy || (Strategy = {}));

  /**
   * built-in events for element
   * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationEvent
   *
   * TODO: use MutationObserver instead
   * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
   */
  var ElementEvent;
  (function (ElementEvent) {
    ElementEvent["REPARENT"] = "reparent";
    ElementEvent["DESTROY"] = "destroy";
    /**
     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMAttrModified
     */
    ElementEvent["ATTR_MODIFIED"] = "DOMAttrModified";
    /**
     * it has been inserted
     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeInserted
     */
    ElementEvent["INSERTED"] = "DOMNodeInserted";
    /**
     * it is being removed
     * @see https://www.w3.org/TR/DOM-Level-3-Events/#event-type-DOMNodeRemoved
     */
    ElementEvent["REMOVED"] = "removed";
    /**
     * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnodeinsertedintodocument
     */
    ElementEvent["MOUNTED"] = "DOMNodeInsertedIntoDocument";
    /**
     * @see https://www.w3.org/TR/DOM-Level-3-Events/#domnoderemovedfromdocument
     */
    ElementEvent["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
    ElementEvent["BOUNDS_CHANGED"] = "bounds-changed";
    // GEOMETRY_BOUNDS_CHANGED = 'geometry-bounds-changed',
    /**
     * trigger when z-index changed
     */
    ElementEvent["RENDER_ORDER_CHANGED"] = "render-order-changed";
    ElementEvent["CULLED"] = "culled";
  })(ElementEvent || (ElementEvent = {}));

  var MutationEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inheritsLoose(MutationEvent, _FederatedEvent);
    function MutationEvent(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
      var _this;
      _this = _FederatedEvent.call(this, null) || this;
      _this.relatedNode = void 0;
      _this.prevValue = void 0;
      _this.newValue = void 0;
      _this.attrName = void 0;
      _this.attrChange = void 0;
      _this.prevParsedValue = void 0;
      _this.newParsedValue = void 0;
      _this.relatedNode = relatedNode;
      _this.prevValue = prevValue;
      _this.newValue = newValue;
      _this.attrName = attrName;
      _this.attrChange = attrChange;
      _this.prevParsedValue = prevParsedValue;
      _this.newParsedValue = newParsedValue;
      _this.type = typeArg;
      return _this;
    }
    return MutationEvent;
  }(FederatedEvent);
  MutationEvent.ADDITION = 2;
  MutationEvent.MODIFICATION = 1;
  MutationEvent.REMOVAL = 3;

  var entityCounter = 0;
  var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, '', '', '', 0, '', '');
  var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, '', '', '', 0, '', '');
  var destroyEvent = new CustomEvent(ElementEvent.DESTROY);
  /**
   * Has following capabilities:
   * * Node insert/remove, eg. appendChild, removeChild, remove...
   * * Query eg. querySelector getElementById...
   * * Animation
   */
  var Element = /*#__PURE__*/function (_Node) {
    _inheritsLoose(Element, _Node);
    function Element() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _Node.call.apply(_Node, [this].concat(args)) || this;
      /**
       * Unique id.
       */
      _this.entity = entityCounter++;
      _this.renderable = {
        bounds: undefined,
        boundsDirty: true,
        renderBounds: undefined,
        renderBoundsDirty: true,
        dirtyRenderBounds: undefined,
        dirty: false,
        proxyNodeName: undefined
      };
      _this.cullable = {
        strategy: Strategy.Standard,
        visibilityPlaneMask: -1,
        visible: true,
        enable: true
      };
      _this.transformable = {
        dirtyFlag: false,
        localDirtyFlag: false,
        frozen: false,
        // localPosition: vec3.fromValues(0, 0, 0),
        // localRotation: quat.fromValues(0, 0, 0, 1),
        // localScale: vec3.fromValues(1, 1, 1),
        // localTransform: mat4.create(),
        // localSkew: vec2.fromValues(0, 0),
        // position: vec3.fromValues(0, 0, 0),
        // rotation: quat.fromValues(0, 0, 0, 1),
        // scaling: vec3.fromValues(1, 1, 1),
        // worldTransform: mat4.create(),
        // origin: vec3.fromValues(0, 0, 0),
        localPosition: [0, 0, 0],
        localRotation: [0, 0, 0, 1],
        localScale: [1, 1, 1],
        localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        localSkew: [0, 0],
        position: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scaling: [1, 1, 1],
        worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        origin: [0, 0, 0]
      };
      _this.sortable = {
        dirty: false,
        sorted: undefined,
        lastSortedIndex: undefined,
        renderOrder: 0
      };
      _this.geometry = {
        contentBounds: undefined,
        renderBounds: undefined
      };
      _this.rBushNode = {
        aabb: undefined
      };
      /**
       * used with `getElementById()`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
       */
      _this.id = void 0;
      /**
       * used in `getElementsByName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
       */
      _this.name = void 0;
      /**
       * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/namespaceURI
       */
      _this.namespaceURI = 'g';
      _this.scrollLeft = 0;
      _this.scrollTop = 0;
      /**
       * We don't support border now
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientTop
       */
      _this.clientTop = 0;
      _this.clientLeft = 0;
      /**
       * is destroyed or not
       */
      _this.destroyed = false;
      /**
       * compatible with `style`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style
       */
      _this.style = {};
      _this.computedStyle = runtime.enableCSSParsing ? {
        anchor: unsetKeywordValue,
        opacity: unsetKeywordValue,
        fillOpacity: unsetKeywordValue,
        strokeOpacity: unsetKeywordValue,
        fill: unsetKeywordValue,
        stroke: unsetKeywordValue,
        transform: unsetKeywordValue,
        transformOrigin: unsetKeywordValue,
        visibility: unsetKeywordValue,
        pointerEvents: unsetKeywordValue,
        lineWidth: unsetKeywordValue,
        lineCap: unsetKeywordValue,
        lineJoin: unsetKeywordValue,
        increasedLineWidthForHitTesting: unsetKeywordValue,
        fontSize: unsetKeywordValue,
        fontFamily: unsetKeywordValue,
        fontStyle: unsetKeywordValue,
        fontWeight: unsetKeywordValue,
        fontVariant: unsetKeywordValue,
        textAlign: unsetKeywordValue,
        textBaseline: unsetKeywordValue,
        textTransform: unsetKeywordValue,
        zIndex: unsetKeywordValue,
        filter: unsetKeywordValue,
        shadowType: unsetKeywordValue
      } : null;
      /**
       * Renderers will use these used values.
       */
      _this.parsedStyle = {
        // opacity: '',
        // fillOpacity: '',
        // strokeOpacity: '',
        // transformOrigin: '',
        // visibility: '',
        // pointerEvents: '',
        // lineWidth: '',
        // lineCap: '',
        // lineJoin: '',
        // increasedLineWidthForHitTesting: '',
        // fontSize: '',
        // fontFamily: '',
        // fontStyle: '',
        // fontWeight: '',
        // fontVariant: '',
        // textAlign: '',
        // textBaseline: '',
        // textTransform: '',
      };
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes
       */
      _this.attributes = {};
      return _this;
    }
    Element.isElement = function isElement(target) {
      return !!target.getAttribute;
    };
    var _proto = Element.prototype;
    _proto.cloneNode = function cloneNode(deep) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.appendChild = function appendChild(child, index) {
      var _this$ownerDocument;
      if (child.destroyed) {
        throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
      }
      runtime.sceneGraphService.attach(child, this, index);
      if ((_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.defaultView) {
        this.ownerDocument.defaultView.mountChildren(child);
      }
      insertedEvent.relatedNode = this;
      child.dispatchEvent(insertedEvent);
      return child;
    };
    _proto.insertBefore = function insertBefore(newChild, refChild) {
      if (!refChild) {
        this.appendChild(newChild);
      } else {
        var index = this.childNodes.indexOf(refChild);
        this.appendChild(newChild, index - 1);
      }
      return newChild;
    };
    _proto.replaceChild = function replaceChild(newChild, oldChild) {
      var index = this.childNodes.indexOf(oldChild);
      this.removeChild(oldChild);
      this.appendChild(newChild, index);
      return oldChild;
    };
    _proto.removeChild = function removeChild(child) {
      var _child$ownerDocument;
      // should emit on itself before detach
      removedEvent.relatedNode = this;
      child.dispatchEvent(removedEvent);
      if ((_child$ownerDocument = child.ownerDocument) === null || _child$ownerDocument === void 0 ? void 0 : _child$ownerDocument.defaultView) {
        child.ownerDocument.defaultView.unmountChildren(child);
      }
      // remove from scene graph
      runtime.sceneGraphService.detach(child);
      return child;
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */;
    _proto.removeChildren = function removeChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        this.removeChild(child);
      }
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     */;
    _proto.destroyChildren = function destroyChildren() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        var child = this.childNodes[i];
        if (child.childNodes.length) {
          child.destroyChildren();
        }
        child.destroy();
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
     */;
    _proto.matches = function matches(selector) {
      return runtime.sceneGraphService.matches(selector, this);
    };
    _proto.getElementById = function getElementById(id) {
      return runtime.sceneGraphService.querySelector("#" + id, this);
    };
    _proto.getElementsByName = function getElementsByName(name) {
      return runtime.sceneGraphService.querySelectorAll("[name=\"" + name + "\"]", this);
    };
    _proto.getElementsByClassName = function getElementsByClassName(className) {
      return runtime.sceneGraphService.querySelectorAll("." + className, this);
    };
    _proto.getElementsByTagName = function getElementsByTagName(tagName) {
      return runtime.sceneGraphService.querySelectorAll(tagName, this);
    };
    _proto.querySelector = function querySelector(selectors) {
      return runtime.sceneGraphService.querySelector(selectors, this);
    };
    _proto.querySelectorAll = function querySelectorAll(selectors) {
      return runtime.sceneGraphService.querySelectorAll(selectors, this);
    }
    /**
     * should traverses the element and its parents (heading toward the document root)
     * until it finds a node that matches the specified CSS selector.
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
     */;
    _proto.closest = function closest(selectors) {
      var el = this;
      do {
        if (runtime.sceneGraphService.matches(selectors, el)) return el;
        el = el.parentElement;
      } while (el !== null);
      return null;
    }
    /**
     * search in scene group, but should not include itself
     */;
    _proto.find = function find(filter) {
      var _this2 = this;
      var target = null;
      this.forEach(function (object) {
        if (object !== _this2 && filter(object)) {
          target = object;
          return true;
        }
        return false;
      });
      return target;
    };
    _proto.findAll = function findAll(filter) {
      var _this3 = this;
      var objects = [];
      this.forEach(function (object) {
        if (object !== _this3 && filter(object)) {
          objects.push(object);
        }
      });
      return objects;
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
     */;
    _proto.after = function after() {
      var _this4 = this;
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          nodes[_key2] = arguments[_key2];
        }
        nodes.forEach(function (node, i) {
          var _this4$parentNode;
          return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index + i + 1);
        });
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
     */;
    _proto.before = function before() {
      if (this.parentNode) {
        var index = this.parentNode.childNodes.indexOf(this);
        for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          nodes[_key3] = arguments[_key3];
        }
        var first = nodes[0],
          rest = nodes.slice(1);
        this.parentNode.appendChild(first, index);
        first.after.apply(first, rest);
      }
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
     */;
    _proto.replaceWith = function replaceWith() {
      this.after.apply(this, arguments);
      this.remove();
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
     */;
    _proto.append = function append() {
      var _this5 = this;
      for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        nodes[_key4] = arguments[_key4];
      }
      nodes.forEach(function (node) {
        return _this5.appendChild(node);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
     */;
    _proto.prepend = function prepend() {
      var _this6 = this;
      for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        nodes[_key5] = arguments[_key5];
      }
      nodes.forEach(function (node, i) {
        return _this6.appendChild(node, i);
      });
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
     */;
    _proto.replaceChildren = function replaceChildren() {
      while (this.childNodes.length && this.firstChild) {
        this.removeChild(this.firstChild);
      }
      this.append.apply(this, arguments);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
     */;
    _proto.remove = function remove() {
      if (this.parentNode) {
        return this.parentNode.removeChild(this);
      }
      return this;
    };
    _proto.destroy = function destroy() {
      // destroy itself before remove
      this.dispatchEvent(destroyEvent);
      // remove from scenegraph first
      this.remove();
      // remove event listeners
      this.emitter.removeAllListeners();
      this.destroyed = true;
    };
    _proto.getGeometryBounds = function getGeometryBounds() {
      return runtime.sceneGraphService.getGeometryBounds(this);
    };
    _proto.getRenderBounds = function getRenderBounds() {
      return runtime.sceneGraphService.getBounds(this, true);
    }
    /**
     * get bounds in world space, account for children
     */;
    _proto.getBounds = function getBounds() {
      return runtime.sceneGraphService.getBounds(this);
    }
    /**
     * get bounds in local space, account for children
     */;
    _proto.getLocalBounds = function getLocalBounds() {
      return runtime.sceneGraphService.getLocalBounds(this);
    }
    /**
     * account for context's bounds in client space,
     * but not accounting for children
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
     */;
    _proto.getBoundingClientRect = function getBoundingClientRect() {
      return runtime.sceneGraphService.getBoundingClientRect(this);
    }
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
     */;
    _proto.getClientRects = function getClientRects() {
      return [this.getBoundingClientRect()];
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
     * eg. circle.computedStyleMap().get('fill');
     */
    _proto.computedStyleMap = function computedStyleMap() {
      return new Map(Object.entries(this.computedStyle));
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
     */
    _proto.getAttributeNames = function getAttributeNames() {
      return Object.keys(this.attributes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
     */;
    _proto.getAttribute = function getAttribute(name) {
      // @see https://github.com/antvis/G/issues/1267
      if (isSymbol(name)) {
        return runtime.enableCSSParsing ? null : undefined;
      }
      var value = this.attributes[name];
      if (value === undefined) {
        var attributeName = formatAttributeName(name);
        value = this.attributes[attributeName];
        // if the given attribute does not exist, the value returned will either be null or ""
        return runtime.enableCSSParsing ? isNil(value) ? null : value : value;
      } else {
        return value;
      }
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
     */;
    _proto.hasAttribute = function hasAttribute(qualifiedName) {
      return this.getAttributeNames().includes(qualifiedName);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
     */;
    _proto.hasAttributes = function hasAttributes() {
      return !!this.getAttributeNames().length;
    }
    /**
     * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
     */;
    _proto.removeAttribute = function removeAttribute(attributeName) {
      this.setAttribute(attributeName, null);
      delete this.attributes[attributeName];
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
     */;
    _proto.setAttribute = function setAttribute(attributeName, value, force) {
      this.attributes[attributeName] = value;
    };
    _proto.getAttributeNS = function getAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.getAttributeNode = function getAttributeNode(qualifiedName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.getAttributeNodeNS = function getAttributeNodeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.hasAttributeNS = function hasAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.removeAttributeNS = function removeAttributeNS(namespace, localName) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.removeAttributeNode = function removeAttributeNode(attr) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.setAttributeNS = function setAttributeNS(namespace, qualifiedName, value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.setAttributeNode = function setAttributeNode(attr) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.setAttributeNodeNS = function setAttributeNodeNS(attr) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.toggleAttribute = function toggleAttribute(qualifiedName, force) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _createClass(Element, [{
      key: "className",
      get:
      /**
       * used in `getElementsByClassName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       */
      function get() {
        // @ts-ignore
        return this.getAttribute('class') || '';
      },
      set: function set(className) {
        this.setAttribute('class', className);
      }
    }, {
      key: "classList",
      get:
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
       */
      function get() {
        return this.className.split(' ').filter(function (c) {
          return c !== '';
        });
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.nodeName;
      }
    }, {
      key: "children",
      get: function get() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get() {
        return this.lastChild;
      }
    }, {
      key: "parentElement",
      get: function get() {
        return this.parentNode;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        if (this.parentNode) {
          var index = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index + 1] || null;
        }
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get() {
        if (this.parentNode) {
          var index = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index - 1] || null;
        }
        return null;
      }
    }]);
    return Element;
  }(Node$1);

  var FederatedMouseEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inheritsLoose(FederatedMouseEvent, _FederatedEvent);
    function FederatedMouseEvent() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _FederatedEvent.call.apply(_FederatedEvent, [this].concat(args)) || this;
      /** Whether the "alt" key was pressed when this mouse event occurred. */
      _this.altKey = void 0;
      /** The specific button that was pressed in this mouse event. */
      _this.button = void 0;
      /** The button depressed when this event occurred. */
      _this.buttons = void 0;
      /** Whether the "control" key was pressed when this mouse event occurred. */
      _this.ctrlKey = void 0;
      /** Whether the "meta" key was pressed when this mouse event occurred. */
      _this.metaKey = void 0;
      /** This is currently not implemented in the Federated Events API. */
      _this.relatedTarget = void 0;
      /** Whether the "shift" key was pressed when this mouse event occurred. */
      _this.shiftKey = void 0;
      /**
       * The coordinates of the mouse event relative to the canvas.
       */
      _this.client = new Point();
      /**
       * The movement in this pointer relative to the last `mousemove` event.
       */
      _this.movement = new Point();
      /**
       * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
       * not supported at the moment.
       */
      _this.offset = new Point();
      /**
       * The pointer coordinates in world space.
       */
      _this.global = new Point();
      /**
       * The pointer coordinates in sceen space.
       */
      _this.screen = new Point();
      return _this;
    }
    var _proto = FederatedMouseEvent.prototype;
    _proto.getModifierState = function getModifierState(key) {
      return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);
    };
    _proto.initMouseEvent = function initMouseEvent() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _createClass(FederatedMouseEvent, [{
      key: "clientX",
      get: function get() {
        return this.client.x;
      }
    }, {
      key: "clientY",
      get: function get() {
        return this.client.y;
      }
    }, {
      key: "movementX",
      get: function get() {
        return this.movement.x;
      }
    }, {
      key: "movementY",
      get: function get() {
        return this.movement.y;
      }
    }, {
      key: "offsetX",
      get: function get() {
        return this.offset.x;
      }
    }, {
      key: "offsetY",
      get: function get() {
        return this.offset.y;
      }
    }, {
      key: "globalX",
      get: function get() {
        return this.global.x;
      }
    }, {
      key: "globalY",
      get: function get() {
        return this.global.y;
      }
    }, {
      key: "screenX",
      get: function get() {
        return this.screen.x;
      }
    }, {
      key: "screenY",
      get: function get() {
        return this.screen.y;
      }
    }]);
    return FederatedMouseEvent;
  }(FederatedEvent);

  var FederatedPointerEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
    _inheritsLoose(FederatedPointerEvent, _FederatedMouseEvent);
    function FederatedPointerEvent() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
      /**
       * The unique identifier of the pointer.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      _this.pointerId = void 0;
      /**
       * The width of the pointer's contact along the x-axis, measured in CSS pixels.
       * radiusX of TouchEvents will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
       */
      _this.width = 0;
      /**
       * The height of the pointer's contact along the y-axis, measured in CSS pixels.
       * radiusY of TouchEvents will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
       */
      _this.height = 0;
      /**
       * Indicates whether or not the pointer device that created the event is the primary pointer.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
       */
      _this.isPrimary = false;
      /**
       * The type of pointer that triggered the event.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
       */
      _this.pointerType = void 0;
      /**
       * Pressure applied by the pointing device during the event.
       *s
       * A Touch's force property will be represented by this value.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
       */
      _this.pressure = void 0;
      /**
       * Barrel pressure on a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      _this.tangentialPressure = void 0;
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
       */
      _this.tiltX = void 0;
      /**
       * The angle, in degrees, between the pointer device and the screen.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
       */
      _this.tiltY = void 0;
      /**
       * Twist of a stylus pointer.
       *
       * @see https://w3c.github.io/pointerevents/#pointerevent-interface
       */
      _this.twist = void 0;
      return _this;
    }
    var _proto = FederatedPointerEvent.prototype;
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
     */
    _proto.getCoalescedEvents = function getCoalescedEvents() {
      if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove') {
        return [this];
      }
      return [];
    }
    /**
     * @see https://chromestatus.com/feature/5765569655603200
     */;
    _proto.getPredictedEvents = function getPredictedEvents() {
      throw new Error('getPredictedEvents is not supported!');
    }
    /**
     * @see https://github.com/antvis/G/issues/1115
     * We currently reuses event objects in the event system,
     * avoiding the creation of a large number of event objects.
     * Reused objects are only used to carry different data,
     * such as coordinate information, native event objects,
     * and therefore the lifecycle is limited to the event handler,
     * which can lead to unintended consequences if an attempt is made to cache the entire event object.
     *
     * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
     */;
    _proto.clone = function clone() {
      return this.manager.clonePointerEvent(this);
    };
    return FederatedPointerEvent;
  }(FederatedMouseEvent);

  var FederatedWheelEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
    _inheritsLoose(FederatedWheelEvent, _FederatedMouseEvent);
    function FederatedWheelEvent() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _FederatedMouseEvent.call.apply(_FederatedMouseEvent, [this].concat(args)) || this;
      /**
       * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
       * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
       */
      _this.deltaMode = void 0;
      /** Horizontal scroll amount */
      _this.deltaX = void 0;
      /** Vertical scroll amount */
      _this.deltaY = void 0;
      /** z-axis scroll amount. */
      _this.deltaZ = void 0;
      /** Units specified in lines. */
      _this.DOM_DELTA_LINE = 0;
      /** Units specified in pages. */
      _this.DOM_DELTA_PAGE = 1;
      /** Units specified in pixels. */
      _this.DOM_DELTA_PIXEL = 2;
      return _this;
    }
    var _proto = FederatedWheelEvent.prototype;
    _proto.clone = function clone() {
      return this.manager.cloneWheelEvent(this);
    };
    return FederatedWheelEvent;
  }(FederatedMouseEvent);

  function isDisplayObject(value) {
    return !!(value === null || value === void 0 ? void 0 : value.nodeName);
  }
  var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
  var DEFAULT_STYLE_PROPS = {
    anchor: '',
    opacity: '',
    fillOpacity: '',
    strokeOpacity: '',
    fill: '',
    stroke: '',
    transform: '',
    transformOrigin: '',
    visibility: '',
    pointerEvents: '',
    lineWidth: '',
    lineCap: '',
    lineJoin: '',
    increasedLineWidthForHitTesting: '',
    fontSize: '',
    fontFamily: '',
    fontStyle: '',
    fontWeight: '',
    fontVariant: '',
    textAlign: '',
    textBaseline: '',
    textTransform: '',
    zIndex: '',
    filter: '',
    shadowType: ''
  };
  var DEFAULT_PARSED_STYLE_PROPS = {
    anchor: [0, 0],
    fill: noneColor,
    stroke: noneColor,
    transform: [],
    zIndex: 0,
    filter: [],
    shadowType: 'outer',
    miterLimit: 10
  };
  var DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED = _extends({}, DEFAULT_PARSED_STYLE_PROPS, {
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    visibility: 'visible',
    pointerEvents: 'auto',
    lineWidth: 1,
    lineCap: 'butt',
    lineJoin: 'miter',
    increasedLineWidthForHitTesting: 0,
    fillRule: 'nonzero'
    // TODO: transformOrigin
  });

  var INHERITABLE_BASE_STYLE_PROPS = ['opacity', 'fillOpacity', 'strokeOpacity', 'transformOrigin', 'visibility', 'pointerEvents', 'lineWidth', 'lineCap', 'lineJoin', 'increasedLineWidthForHitTesting'];
  var INHERITABLE_STYLE_PROPS = [].concat(INHERITABLE_BASE_STYLE_PROPS, ['fontSize', 'fontFamily', 'fontStyle', 'fontWeight', 'fontVariant', 'textAlign', 'textBaseline', 'textTransform']);
  var DATASET_PREFIX = 'data-';
  /**
   * prototype chains: DisplayObject -> Element -> Node -> EventTarget
   *
   * mixins: Animatable, Transformable, Visible
   * @see https://github.com/tannerntannern/ts-mixer/blob/master/README.md#mixing-generic-classes
   *
   * Provide abilities in scene graph, such as:
   * * transform `translate/rotate/scale`
   * * add/remove child
   * * visibility and z-index
   *
   * Those abilities are implemented with those components: `Transform/Sortable/Visible`.
   *
   * Emit following events:
   * * init
   * * destroy
   * * attributeChanged
   */
  var DisplayObject = /*#__PURE__*/function (_Element) {
    _inheritsLoose(DisplayObject, _Element);
    /**
     * contains style props in constructor's params, eg. fill, stroke...
     */

    /**
     * push to active animations after calling `animate()`
     */

    /**
     * Use data-* attribute.
     * @see https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes
     * @example
     * group.dataset.prop1 = 1;
     * group.getAttribute('data-prop1'); // 1
     */

    function DisplayObject(config) {
      var _this$config$capture;
      var _this;
      _this = _Element.call(this) || this;
      // assign name, id to config
      // eg. group.get('name')
      _this.config = void 0;
      _this.isCustomElement = false;
      _this.isMutationObserved = false;
      _this.activeAnimations = [];
      _this.dataset = void 0;
      /**
       * Use `this.style.clipPath` instead.
       * @deprecated
       */
      _this.getClip = function () {
        return this.style.clipPath || null;
      };
      _this.config = config;
      // compatible with G 3.0
      _this.config.interactive = (_this$config$capture = _this.config.capture) !== null && _this$config$capture !== void 0 ? _this$config$capture : _this.config.interactive;
      // init scene graph node
      _this.id = _this.config.id || '';
      _this.name = _this.config.name || '';
      if (_this.config.className || _this.config.class) {
        _this.className = _this.config.className || _this.config.class;
      }
      _this.nodeName = _this.config.type || Shape.GROUP;
      // compatible with G 3.0
      _this.config.style = _this.config.style || _this.config.attrs || {};
      Object.assign(_this.config.style, _this.config.attrs);
      // this.config.style = {
      //   // ...DEFAULT_STYLE_PROPS,
      //   ...this.config.style,
      //   ...this.config.attrs,
      // };
      if (_this.config.visible != null) {
        _this.config.style.visibility = _this.config.visible === false ? 'hidden' : 'visible';
      }
      if (_this.config.interactive != null) {
        _this.config.style.pointerEvents = _this.config.interactive === false ? 'none' : 'auto';
      }
      // merge parsed value
      Object.assign(_this.parsedStyle, runtime.enableCSSParsing ? DEFAULT_PARSED_STYLE_PROPS : DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED, _this.config.initialParsedStyle);
      if (runtime.enableCSSParsing) {
        Object.assign(_this.attributes, DEFAULT_STYLE_PROPS);
      }
      // start to process attributes
      _this.initAttributes(_this.config.style);
      var Proxy = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function () {};
      _this.dataset = new Proxy({}, {
        get: function get(target, name) {
          var formattedName = "" + DATASET_PREFIX + kebabize(name);
          if (target[formattedName] !== undefined) {
            return target[formattedName];
          }
          return _this.getAttribute(formattedName);
        },
        set: function set(_, prop, value) {
          _this.setAttribute("" + DATASET_PREFIX + kebabize(prop), value);
          return true;
        }
      });
      _this.style = new Proxy(
      // @ts-ignore
      {
        // ...this.attributes,
        setProperty: function setProperty(propertyName, value) {
          _this.setAttribute(propertyName, value);
        },
        getPropertyValue: function getPropertyValue(propertyName) {
          return _this.getAttribute(propertyName);
        },
        removeProperty: function removeProperty(propertyName) {
          _this.removeAttribute(propertyName);
        },
        item: function item() {
          return '';
        }
      }, {
        get: function get(target, name) {
          if (target[name] !== undefined) {
            // if (name in target) {
            return target[name];
          }
          return _this.getAttribute(name);
        },
        set: function set(_, prop, value) {
          _this.setAttribute(prop, value);
          return true;
        }
      });
      return _this;
    }
    var _proto = DisplayObject.prototype;
    _proto.destroy = function destroy() {
      _Element.prototype.destroy.call(this);
      // stop all active animations
      this.getAnimations().forEach(function (animation) {
        animation.cancel();
      });
      // FIXME
      // this.renderable = null;
      // this.cullable = null;
      // this.transformable = null;
      // this.rBushNode = null;
      // this.geometry = null;
      // this.sortable = null;
    };
    _proto.cloneNode = function cloneNode(deep, customCloneFunc) {
      var clonedStyle = _extends({}, this.attributes);
      for (var attributeName in clonedStyle) {
        var attribute = clonedStyle[attributeName];
        // @see https://github.com/antvis/G/issues/1095
        if (isDisplayObject(attribute) &&
        // share the same clipPath if possible
        attributeName !== 'clipPath' && attributeName !== 'offsetPath' && attributeName !== 'textPath') {
          clonedStyle[attributeName] = attribute.cloneNode(deep);
        }
        // TODO: clone other type
        if (customCloneFunc) {
          clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
        }
      }
      var cloned = new this.constructor({
        // copy id & name
        // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
        id: this.id,
        name: this.name,
        className: this.name,
        interactive: this.interactive,
        style: clonedStyle
      });
      // apply transform
      cloned.setLocalTransform(this.getLocalTransform());
      if (deep) {
        this.children.forEach(function (child) {
          // skip marker
          if (!child.style.isMarker) {
            var clonedChild = child.cloneNode(deep);
            cloned.appendChild(clonedChild);
          }
        });
      }
      return cloned;
    };
    _proto.initAttributes = function initAttributes(attributes) {
      if (attributes === void 0) {
        attributes = {};
      }
      var renderable = this.renderable;
      var options = {
        forceUpdateGeometry: true
        // usedAttributes:
        //   // only Group / Text should account for text relative props
        //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
        //     ? INHERITABLE_STYLE_PROPS
        //     : INHERITABLE_BASE_STYLE_PROPS,
      };

      if (runtime.enableCSSParsing) {
        // @ts-ignore
        options.usedAttributes = INHERITABLE_STYLE_PROPS;
      }
      // account for FCP, process properties as less as possible
      var formattedAttributes = {};
      for (var name in attributes) {
        var attributeName = formatAttributeName(name);
        formattedAttributes[attributeName] = attributes[name];
      }
      runtime.styleValueRegistry.processProperties(this, formattedAttributes, options);
      // redraw at next frame
      renderable.dirty = true;
    };
    _proto.setAttribute = function setAttribute(name, value, force) {
      if (force === void 0) {
        force = false;
      }
      var attributeName = formatAttributeName(name);
      // ignore undefined value
      if (isUndefined(value)) {
        return;
      }
      if (force || value !== this.attributes[attributeName]) {
        this.internalSetAttribute(attributeName, value);
        _Element.prototype.setAttribute.call(this, attributeName, value);
      }
    }
    /**
     * called when attributes get changed or initialized
     */;
    _proto.internalSetAttribute = function internalSetAttribute(name, value, parseOptions) {
      var _runtime$styleValueRe;
      if (parseOptions === void 0) {
        parseOptions = {};
      }
      var renderable = this.renderable;
      var oldValue = this.attributes[name];
      var oldParsedValue = this.parsedStyle[name];
      runtime.styleValueRegistry.processProperties(this, (_runtime$styleValueRe = {}, _runtime$styleValueRe[name] = value, _runtime$styleValueRe), parseOptions);
      // redraw at next frame
      renderable.dirty = true;
      var newParsedValue = this.parsedStyle[name];
      if (this.isConnected) {
        mutationEvent.relatedNode = this;
        mutationEvent.prevValue = oldValue;
        mutationEvent.newValue = value;
        mutationEvent.attrName = name;
        mutationEvent.prevParsedValue = oldParsedValue;
        mutationEvent.newParsedValue = newParsedValue;
        if (this.isMutationObserved) {
          this.dispatchEvent(mutationEvent);
        } else {
          mutationEvent.target = this;
          this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
        }
      }
      if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
        this.attributeChangedCallback(name, oldValue, value, oldParsedValue, newParsedValue);
      }
    }
    // #region transformable
    /**
     * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
     *
     * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
     * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
     */;
    _proto.getBBox = function getBBox() {
      var aabb = this.getBounds();
      var _aabb$getMin = aabb.getMin(),
        left = _aabb$getMin[0],
        top = _aabb$getMin[1];
      var _aabb$getMax = aabb.getMax(),
        right = _aabb$getMax[0],
        bottom = _aabb$getMax[1];
      return new Rectangle(left, top, right - left, bottom - top);
    };
    _proto.setOrigin = function setOrigin(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setOrigin(this, createVec3(position, y, z));
      return this;
    };
    _proto.getOrigin = function getOrigin() {
      return runtime.sceneGraphService.getOrigin(this);
    }
    /**
     * set position in world space
     */;
    _proto.setPosition = function setPosition(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setPosition(this, createVec3(position, y, z));
      return this;
    }
    /**
     * set position in local space
     */;
    _proto.setLocalPosition = function setLocalPosition(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y, z));
      return this;
    }
    /**
     * translate in world space
     */;
    _proto.translate = function translate(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.translate(this, createVec3(position, y, z));
      return this;
    }
    /**
     * translate in local space
     */;
    _proto.translateLocal = function translateLocal(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      runtime.sceneGraphService.translateLocal(this, createVec3(position, y, z));
      return this;
    };
    _proto.getPosition = function getPosition() {
      return runtime.sceneGraphService.getPosition(this);
    };
    _proto.getLocalPosition = function getLocalPosition() {
      return runtime.sceneGraphService.getLocalPosition(this);
    }
    /**
     * compatible with G 3.0
     *
     * scaling in local space
     * scale(10) = scale(10, 10, 10)
     *
     * we can't set scale in world space
     */;
    _proto.scale = function scale(scaling, y, z) {
      return this.scaleLocal(scaling, y, z);
    };
    _proto.scaleLocal = function scaleLocal(scaling, y, z) {
      if (typeof scaling === 'number') {
        y = y || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y, z);
      }
      runtime.sceneGraphService.scaleLocal(this, scaling);
      return this;
    }
    /**
     * set scaling in local space
     */;
    _proto.setLocalScale = function setLocalScale(scaling, y, z) {
      if (typeof scaling === 'number') {
        y = y || scaling;
        z = z || scaling;
        scaling = createVec3(scaling, y, z);
      }
      runtime.sceneGraphService.setLocalScale(this, scaling);
      return this;
    }
    /**
     * get scaling in local space
     */;
    _proto.getLocalScale = function getLocalScale() {
      return runtime.sceneGraphService.getLocalScale(this);
    }
    /**
     * get scaling in world space
     */;
    _proto.getScale = function getScale() {
      return runtime.sceneGraphService.getScale(this);
    }
    /**
     * only return degrees of Z axis in world space
     */;
    _proto.getEulerAngles = function getEulerAngles() {
      var _getEuler = getEuler(create$2(), runtime.sceneGraphService.getWorldTransform(this)),
        ez = _getEuler[2];
      return rad2deg(ez);
    }
    /**
     * only return degrees of Z axis in local space
     */;
    _proto.getLocalEulerAngles = function getLocalEulerAngles() {
      var _getEuler2 = getEuler(create$2(), runtime.sceneGraphService.getLocalRotation(this)),
        ez = _getEuler2[2];
      return rad2deg(ez);
    }
    /**
     * set euler angles(degrees) in world space
     */;
    _proto.setEulerAngles = function setEulerAngles(z) {
      runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
      return this;
    }
    /**
     * set euler angles(degrees) in local space
     */;
    _proto.setLocalEulerAngles = function setLocalEulerAngles(z) {
      runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
      return this;
    };
    _proto.rotateLocal = function rotateLocal(x, y, z) {
      if (isNil(y) && isNil(z)) {
        runtime.sceneGraphService.rotateLocal(this, 0, 0, x);
      } else {
        runtime.sceneGraphService.rotateLocal(this, x, y, z);
      }
      return this;
    };
    _proto.rotate = function rotate(x, y, z) {
      if (isNil(y) && isNil(z)) {
        runtime.sceneGraphService.rotate(this, 0, 0, x);
      } else {
        runtime.sceneGraphService.rotate(this, x, y, z);
      }
      return this;
    };
    _proto.setRotation = function setRotation(rotation, y, z, w) {
      runtime.sceneGraphService.setRotation(this, rotation, y, z, w);
      return this;
    };
    _proto.setLocalRotation = function setLocalRotation(rotation, y, z, w) {
      runtime.sceneGraphService.setLocalRotation(this, rotation, y, z, w);
      return this;
    };
    _proto.setLocalSkew = function setLocalSkew(skew, y) {
      runtime.sceneGraphService.setLocalSkew(this, skew, y);
      return this;
    };
    _proto.getRotation = function getRotation() {
      return runtime.sceneGraphService.getRotation(this);
    };
    _proto.getLocalRotation = function getLocalRotation() {
      return runtime.sceneGraphService.getLocalRotation(this);
    };
    _proto.getLocalSkew = function getLocalSkew() {
      return runtime.sceneGraphService.getLocalSkew(this);
    };
    _proto.getLocalTransform = function getLocalTransform() {
      return runtime.sceneGraphService.getLocalTransform(this);
    };
    _proto.getWorldTransform = function getWorldTransform() {
      return runtime.sceneGraphService.getWorldTransform(this);
    };
    _proto.setLocalTransform = function setLocalTransform(transform) {
      runtime.sceneGraphService.setLocalTransform(this, transform);
      return this;
    };
    _proto.resetLocalTransform = function resetLocalTransform() {
      runtime.sceneGraphService.resetLocalTransform(this);
    }
    // #endregion transformable
    // #region animatable
    /**
     * returns an array of all Animation objects affecting this element
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
     */;
    _proto.getAnimations = function getAnimations() {
      return this.activeAnimations;
    }
    /**
     * create an animation with WAAPI
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
     */;
    _proto.animate = function animate(keyframes, options) {
      var _this$ownerDocument;
      var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
      if (timeline) {
        return timeline.play(this, keyframes, options);
      }
      return null;
    }
    // #endregion animatable
    // #region visible
    /**
     * shortcut for Used value of `visibility`
     */;
    _proto.isVisible = function isVisible() {
      var _this$parsedStyle;
      return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) === 'visible';
    };
    _proto.isInteractive = function isInteractive() {
      var _this$parsedStyle2;
      return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== 'none';
    };
    _proto.isCulled = function isCulled() {
      return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
    }
    /**
     * bring to front in current group
     */;
    _proto.toFront = function toFront() {
      if (this.parentNode) {
        this.style.zIndex = Math.max.apply(Math, this.parentNode.children.map(function (child) {
          return Number(child.style.zIndex);
        })) + 1;
      }
      return this;
    }
    /**
     * send to back in current group
     */;
    _proto.toBack = function toBack() {
      if (this.parentNode) {
        this.style.zIndex = Math.min.apply(Math, this.parentNode.children.map(function (child) {
          return Number(child.style.zIndex);
        })) - 1;
      }
      return this;
    }
    // #endregion visible
    // #region deprecated
    /**
     * compatible with G 3.0
     * @alias object.config
     * @deprecated
     */;
    _proto.getConfig = function getConfig() {
      return this.config;
    };
    _proto.attr = function attr() {
      var _this2 = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var name = args[0],
        value = args[1];
      if (!name) {
        return this.attributes;
      }
      if (isObject(name)) {
        Object.keys(name).forEach(function (key) {
          _this2.setAttribute(key, name[key]);
        });
        return this;
      }
      if (args.length === 2) {
        this.setAttribute(name, value);
        return this;
      }
      return this.attributes[name];
    }
    /**
     * return 3x3 matrix in world space
     * @deprecated
     */;
    _proto.getMatrix = function getMatrix(transformMat4) {
      var transform = transformMat4 || this.getWorldTransform();
      var _mat4$getTranslation = getTranslation(create$2(), transform),
        tx = _mat4$getTranslation[0],
        ty = _mat4$getTranslation[1];
      var _mat4$getScaling = getScaling(create$2(), transform),
        sx = _mat4$getScaling[0],
        sy = _mat4$getScaling[1];
      var rotation = getRotation(create$4(), transform);
      var _getEuler3 = getEuler(create$2(), rotation),
        eux = _getEuler3[0],
        euz = _getEuler3[2];
      // gimbal lock at 90 degrees
      return fromRotationTranslationScale$1(eux || euz, tx, ty, sx, sy);
    }
    /**
     * return 3x3 matrix in local space
     * @deprecated
     */;
    _proto.getLocalMatrix = function getLocalMatrix() {
      return this.getMatrix(this.getLocalTransform());
    }
    /**
     * set 3x3 matrix in world space
     * @deprecated
     */;
    _proto.setMatrix = function setMatrix(mat) {
      var _decompose = decompose(mat),
        tx = _decompose[0],
        ty = _decompose[1],
        scalingX = _decompose[2],
        scalingY = _decompose[3],
        angle = _decompose[4];
      this.setEulerAngles(angle).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * set 3x3 matrix in local space
     * @deprecated
     */;
    _proto.setLocalMatrix = function setLocalMatrix(mat) {
      var _decompose2 = decompose(mat),
        tx = _decompose2[0],
        ty = _decompose2[1],
        scalingX = _decompose2[2],
        scalingY = _decompose2[3],
        angle = _decompose2[4];
      this.setLocalEulerAngles(angle).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
    }
    /**
     * Use `visibility: visible` instead.
     * @deprecated
     */;
    _proto.show = function show() {
      if (runtime.enableCSSParsing) {
        this.style.visibility = 'visible';
      } else {
        this.forEach(function (object) {
          object.style.visibility = 'visible';
        });
      }
    }
    /**
     * Use `visibility: hidden` instead.
     * @deprecated
     */;
    _proto.hide = function hide() {
      if (runtime.enableCSSParsing) {
        this.style.visibility = 'hidden';
      } else {
        this.forEach(function (object) {
          object.style.visibility = 'hidden';
        });
      }
    }
    /**
     * Use `childElementCount` instead.
     * @deprecated
     */;
    _proto.getCount = function getCount() {
      return this.childElementCount;
    }
    /**
     * Use `parentElement` instead.
     * @deprecated
     */;
    _proto.getParent = function getParent() {
      return this.parentElement;
    }
    /**
     * Use `children` instead.
     * @deprecated
     */;
    _proto.getChildren = function getChildren() {
      return this.children;
    }
    /**
     * Use `firstElementChild` instead.
     * @deprecated
     */;
    _proto.getFirst = function getFirst() {
      return this.firstElementChild;
    }
    /**
     * Use `lastElementChild` instead.
     * @deprecated
     */;
    _proto.getLast = function getLast() {
      return this.lastElementChild;
    }
    /**
     * Use `this.children[index]` instead.
     * @deprecated
     */;
    _proto.getChildByIndex = function getChildByIndex(index) {
      return this.children[index] || null;
    }
    /**
     * Use `appendChild` instead.
     * @deprecated
     */;
    _proto.add = function add(child, index) {
      return this.appendChild(child, index);
    }
    /**
     * Use `this.style.clipPath` instead.
     * @deprecated
     */;
    _proto.setClip = function setClip(clipPath) {
      this.style.clipPath = clipPath;
    };
    /**
     * @deprecated
     */
    _proto.set = function set(name, value) {
      // @ts-ignore
      this.config[name] = value;
    }
    /**
     * @deprecated
     */;
    _proto.get = function get(name) {
      return this.config[name];
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */;
    _proto.moveTo = function moveTo(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      this.setPosition(position, y, z);
      return this;
    }
    /**
     * Use `setPosition` instead.
     * @deprecated
     */;
    _proto.move = function move(position, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      this.setPosition(position, y, z);
      return this;
    }
    /**
     * Use `this.style.zIndex` instead.
     * @deprecated
     */;
    _proto.setZIndex = function setZIndex(zIndex) {
      this.style.zIndex = zIndex;
      return this;
    };
    _createClass(DisplayObject, [{
      key: "interactive",
      get: function get() {
        return this.isInteractive();
      },
      set: function set(b) {
        this.style.pointerEvents = b ? 'auto' : 'none';
      }
    }]);
    return DisplayObject;
  }(Element);

  var _excluded = ["style"];
  var Circle = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Circle, _DisplayObject);
    function Circle(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded);
      return _DisplayObject.call(this, _extends({
        type: Shape.CIRCLE,
        style: runtime.enableCSSParsing ? _extends({
          cx: '',
          cy: '',
          r: ''
        }, style) : _extends({}, style),
        initialParsedStyle: {
          anchor: [0.5, 0.5],
          transformOrigin: runtime.enableCSSParsing ? null : [PECENTAGE_50, PECENTAGE_50]
        }
      }, rest)) || this;
    }
    return Circle;
  }(DisplayObject);

  var _excluded$2 = ["style"];
  var Ellipse = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Ellipse, _DisplayObject);
    function Ellipse(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
      return _DisplayObject.call(this, _extends({
        type: Shape.ELLIPSE,
        style: runtime.enableCSSParsing ? _extends({
          cx: '',
          cy: '',
          rx: '',
          ry: ''
        }, style) : _extends({}, style),
        initialParsedStyle: {
          anchor: [0.5, 0.5],
          transformOrigin: runtime.enableCSSParsing ? null : [PECENTAGE_50, PECENTAGE_50]
        }
      }, rest)) || this;
    }
    return Ellipse;
  }(DisplayObject);

  var _excluded$3 = ["style"];
  /**
   * its attributes are inherited by its children.
   * @see https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/g
   *
   * @example
   * <g fill="white" stroke="green" stroke-width="5">
      <circle cx="40" cy="40" r="25" />
      <circle cx="60" cy="60" r="25" />
    </g>
   */
  var Group = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Group, _DisplayObject);
    function Group(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
      return _DisplayObject.call(this, _extends({
        type: Shape.GROUP,
        style: runtime.enableCSSParsing ? _extends({
          x: '',
          y: '',
          width: '',
          height: ''
        }, style) : _extends({}, style)
      }, rest)) || this;
    }
    return Group;
  }(DisplayObject);

  var _excluded$4 = ["style"];
  /**
   * HTML container
   * @see https://github.com/pmndrs/drei#html
   */
  var HTML = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(HTML, _DisplayObject);
    function HTML(_temp) {
      var _this;
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$4);
      _this = _DisplayObject.call(this, _extends({
        type: Shape.HTML,
        style: runtime.enableCSSParsing ? _extends({
          x: '',
          y: '',
          width: 'auto',
          height: 'auto',
          innerHTML: ''
        }, style) : _extends({}, style)
      }, rest)) || this;
      _this.cullable.enable = false;
      return _this;
    }
    /**
     * return wrapper HTMLElement
     * * <div> in g-webgl/canvas
     * * <foreignObject> in g-svg
     */
    var _proto = HTML.prototype;
    _proto.getDomElement = function getDomElement() {
      return this.parsedStyle.$el;
    }
    /**
     * override with $el.getBoundingClientRect
     * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
     */;
    _proto.getBoundingClientRect = function getBoundingClientRect() {
      return this.parsedStyle.$el.getBoundingClientRect();
    };
    _proto.getClientRects = function getClientRects() {
      return [this.getBoundingClientRect()];
    };
    _proto.getBounds = function getBounds() {
      var _this$ownerDocument, _this$ownerDocument$d;
      var clientRect = this.getBoundingClientRect();
      // calc context's offset
      // @ts-ignore
      var canvasRect = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : (_this$ownerDocument$d = _this$ownerDocument.defaultView) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.getContextService().getBoundingClientRect();
      if (canvasRect) {
        var minX = clientRect.left - canvasRect.left;
        var minY = clientRect.top - canvasRect.top;
        var aabb = new AABB();
        // aabb.setMinMax(
        //   vec3.fromValues(minX, minY, 0),
        //   vec3.fromValues(minX + clientRect.width, minY + clientRect.height, 0),
        // );
        aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
        return aabb;
      }
      return null;
    };
    _proto.getLocalBounds = function getLocalBounds() {
      if (this.parentNode) {
        var parentInvert = invert(create$1(), this.parentNode.getWorldTransform());
        var bounds = this.getBounds();
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds();
    };
    return HTML;
  }(DisplayObject);

  var _excluded$5 = ["style"];
  var Image = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Image, _DisplayObject);
    function Image(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$5);
      return _DisplayObject.call(this, _extends({
        type: Shape.IMAGE,
        style: runtime.enableCSSParsing ? _extends({
          x: '',
          y: '',
          img: '',
          width: '',
          height: ''
        }, style) : _extends({}, style)
      }, rest)) || this;
    }
    return Image;
  }(DisplayObject);

  var _excluded$6 = ["style"];
  /**
   * Create a line connecting two points.
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line
   *
   * Also support for using marker.
   */
  var Line = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Line, _DisplayObject);
    function Line(_temp) {
      var _this;
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$6);
      _this = _DisplayObject.call(this, _extends({
        type: Shape.LINE,
        style: _extends({
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          z1: 0,
          z2: 0,
          isBillboard: false
        }, style)
      }, rest)) || this;
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      var _this$parsedStyle = _this.parsedStyle,
        markerStart = _this$parsedStyle.markerStart,
        markerEnd = _this$parsedStyle.markerEnd;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    var _proto = Line.prototype;
    _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === 'x1' || attrName === 'y1' || attrName === 'x2' || attrName === 'y2' || attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === 'markerStart') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        // CSSKeyword 'unset'
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === 'markerEnd') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      }
    };
    _proto.transformMarker = function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle,
        markerStart = _this$parsedStyle2.markerStart,
        markerEnd = _this$parsedStyle2.markerEnd,
        markerStartOffset = _this$parsedStyle2.markerStartOffset,
        markerEndOffset = _this$parsedStyle2.markerEndOffset,
        x1 = _this$parsedStyle2.x1,
        x2 = _this$parsedStyle2.x2,
        y1 = _this$parsedStyle2.y1,
        y2 = _this$parsedStyle2.y2,
        defX = _this$parsedStyle2.defX,
        defY = _this$parsedStyle2.defY;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad = 0;
      var x;
      var y;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        ox = x1 - defX;
        oy = y1 - defY;
        x = x2 - x1;
        y = y2 - y1;
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        ox = x2 - defX;
        oy = y2 - defY;
        x = x1 - x2;
        y = y1 - y2;
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y, x);
      // account for markerOffset
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
    };
    _proto.getPoint = function getPoint(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      // TODO: account for z1/z2 in 3D line
      var _this$parsedStyle3 = this.parsedStyle,
        x1 = _this$parsedStyle3.x1,
        y1 = _this$parsedStyle3.y1,
        x2 = _this$parsedStyle3.x2,
        y2 = _this$parsedStyle3.y2,
        defX = _this$parsedStyle3.defX,
        defY = _this$parsedStyle3.defY;
      var _LineUtil$pointAt = line.pointAt(x1, y1, x2, y2, ratio),
        x = _LineUtil$pointAt.x,
        y = _LineUtil$pointAt.y;
      var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      // apply local transformation
      return new Point(transformed[0], transformed[1]);
    };
    _proto.getPointAtLength = function getPointAtLength(distance, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
    };
    _proto.getTotalLength = function getTotalLength() {
      // TODO: account for z1/z2 in 3D line
      var _this$parsedStyle4 = this.parsedStyle,
        x1 = _this$parsedStyle4.x1,
        y1 = _this$parsedStyle4.y1,
        x2 = _this$parsedStyle4.x2,
        y2 = _this$parsedStyle4.y2;
      return line.length(x1, y1, x2, y2);
    };
    return Line;
  }(DisplayObject);

  var _excluded$7 = ["style"];
  var EMPTY_PARSED_PATH = {
    absolutePath: [],
    hasArc: false,
    segments: [],
    polygons: [],
    polylines: [],
    curve: null,
    totalLength: 0,
    rect: new Rectangle(0, 0, 0, 0)
  };
  var Path = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Path, _DisplayObject);
    /**
     * markers placed at the mid
     */

    function Path(_temp) {
      var _this;
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$7);
      _this = _DisplayObject.call(this, _extends({
        type: Shape.PATH,
        style: runtime.enableCSSParsing ? _extends({
          path: '',
          miterLimit: ''
        }, style) : _extends({}, style),
        initialParsedStyle: runtime.enableCSSParsing ? null : {
          miterLimit: 4,
          path: _extends({}, EMPTY_PARSED_PATH)
        }
      }, rest)) || this;
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      _this.markerMidList = [];
      var _this$parsedStyle = _this.parsedStyle,
        markerStart = _this$parsedStyle.markerStart,
        markerEnd = _this$parsedStyle.markerEnd,
        markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    var _proto = Path.prototype;
    _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === 'path') {
        // recalc markers
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === 'markerStart') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        // CSSKeyword 'unset'
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === 'markerEnd') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === 'markerMid') {
        this.placeMarkerMid(newParsedValue);
      }
    };
    _proto.transformMarker = function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle,
        markerStart = _this$parsedStyle2.markerStart,
        markerEnd = _this$parsedStyle2.markerEnd,
        markerStartOffset = _this$parsedStyle2.markerStartOffset,
        markerEndOffset = _this$parsedStyle2.markerEndOffset,
        defX = _this$parsedStyle2.defX,
        defY = _this$parsedStyle2.defY;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad = 0;
      var x;
      var y;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      if (isStart) {
        var _this$getStartTangent = this.getStartTangent(),
          p1 = _this$getStartTangent[0],
          p2 = _this$getStartTangent[1];
        ox = p2[0] - defX;
        oy = p2[1] - defY;
        x = p1[0] - p2[0];
        y = p1[1] - p2[1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var _this$getEndTangent = this.getEndTangent(),
          _p = _this$getEndTangent[0],
          _p2 = _this$getEndTangent[1];
        ox = _p2[0] - defX;
        oy = _p2[1] - defY;
        x = _p[0] - _p2[0];
        y = _p[1] - _p2[1];
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y, x);
      // account for markerOffset
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
    };
    _proto.placeMarkerMid = function placeMarkerMid(marker) {
      var _this$parsedStyle3 = this.parsedStyle,
        segments = _this$parsedStyle3.path.segments,
        defX = _this$parsedStyle3.defX,
        defY = _this$parsedStyle3.defY;
      // clear all existed markers
      this.markerMidList.forEach(function (marker) {
        marker.remove();
      });
      if (marker && isDisplayObject(marker)) {
        for (var i = 1; i < segments.length - 1; i++) {
          var _segments$i$currentPo = segments[i].currentPoint,
            ox = _segments$i$currentPo[0],
            oy = _segments$i$currentPo[1];
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox - defX, oy - defY);
          // TODO: orient of marker
        }
      }
    }
    /**
     * Returns the total length of the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
     */;
    _proto.getTotalLength = function getTotalLength() {
      return getOrCalculatePathTotalLength(this);
    }
    /**
     * Returns the point at a given distance along the path.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
     */;
    _proto.getPointAtLength = function getPointAtLength$1(distance, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      var _this$parsedStyle4 = this.parsedStyle,
        defX = _this$parsedStyle4.defX,
        defY = _this$parsedStyle4.defY,
        absolutePath = _this$parsedStyle4.path.absolutePath;
      var _getPointAtLength2 = getPointAtLength(absolutePath, distance),
        x = _getPointAtLength2.x,
        y = _getPointAtLength2.y;
      var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      // apply local transformation
      return new Point(transformed[0], transformed[1]);
    }
    /**
     * Returns the point at a given ratio of the total length in path.
     */;
    _proto.getPoint = function getPoint(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
    }
    /**
     * Get start tangent vector
     */;
    _proto.getStartTangent = function getStartTangent() {
      var segments = this.parsedStyle.path.segments;
      var result = [];
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    }
    /**
     * Get end tangent vector
     */;
    _proto.getEndTangent = function getEndTangent() {
      var segments = this.parsedStyle.path.segments;
      var length = segments.length;
      var result = [];
      if (length > 1) {
        var startPoint = segments[length - 2].currentPoint;
        var endPoint = segments[length - 1].currentPoint;
        var tangent = segments[length - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path;
  }(DisplayObject);

  var _excluded$8 = ["style"];
  var Polygon = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Polygon, _DisplayObject);
    /**
     * markers placed at the mid
     */

    function Polygon(_temp) {
      var _this;
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$8);
      _this = _DisplayObject.call(this, _extends({
        type: Shape.POLYGON,
        style: runtime.enableCSSParsing ? _extends({
          points: '',
          miterLimit: '',
          isClosed: true
        }, style) : _extends({}, style),
        initialParsedStyle: runtime.enableCSSParsing ? null : {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: true
        }
      }, rest)) || this;
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      _this.markerMidList = [];
      var _this$parsedStyle = _this.parsedStyle,
        markerStart = _this$parsedStyle.markerStart,
        markerEnd = _this$parsedStyle.markerEnd,
        markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    var _proto = Polygon.prototype;
    _proto.attributeChangedCallback = function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
      if (attrName === 'points') {
        // recalc markers
        this.transformMarker(true);
        this.transformMarker(false);
        this.placeMarkerMid(this.parsedStyle.markerMid);
      } else if (attrName === 'markerStartOffset' || attrName === 'markerEndOffset') {
        this.transformMarker(true);
        this.transformMarker(false);
      } else if (attrName === 'markerStart') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerStartAngle = 0;
          prevParsedValue.remove();
        }
        // CSSKeyword 'unset'
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerStartAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(true);
        }
      } else if (attrName === 'markerEnd') {
        if (prevParsedValue && isDisplayObject(prevParsedValue)) {
          this.markerEndAngle = 0;
          prevParsedValue.remove();
        }
        if (newParsedValue && isDisplayObject(newParsedValue)) {
          this.markerEndAngle = newParsedValue.getLocalEulerAngles();
          this.appendChild(newParsedValue);
          this.transformMarker(false);
        }
      } else if (attrName === 'markerMid') {
        this.placeMarkerMid(newParsedValue);
      }
    };
    _proto.transformMarker = function transformMarker(isStart) {
      var _this$parsedStyle2 = this.parsedStyle,
        markerStart = _this$parsedStyle2.markerStart,
        markerEnd = _this$parsedStyle2.markerEnd,
        markerStartOffset = _this$parsedStyle2.markerStartOffset,
        markerEndOffset = _this$parsedStyle2.markerEndOffset,
        points = _this$parsedStyle2.points.points,
        defX = _this$parsedStyle2.defX,
        defY = _this$parsedStyle2.defY;
      var marker = isStart ? markerStart : markerEnd;
      if (!marker || !isDisplayObject(marker)) {
        return;
      }
      var rad = 0;
      var x;
      var y;
      var ox;
      var oy;
      var offset;
      var originalAngle;
      ox = points[0][0] - defX;
      oy = points[0][1] - defY;
      if (isStart) {
        x = points[1][0] - points[0][0];
        y = points[1][1] - points[0][1];
        offset = markerStartOffset || 0;
        originalAngle = this.markerStartAngle;
      } else {
        var length = points.length;
        if (!this.parsedStyle.isClosed) {
          ox = points[length - 1][0] - defX;
          oy = points[length - 1][1] - defY;
          x = points[length - 2][0] - points[length - 1][0];
          y = points[length - 2][1] - points[length - 1][1];
        } else {
          x = points[length - 1][0] - points[0][0];
          y = points[length - 1][1] - points[0][1];
        }
        offset = markerEndOffset || 0;
        originalAngle = this.markerEndAngle;
      }
      rad = Math.atan2(y, x);
      // account for markerOffset
      marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
      marker.setLocalPosition(ox + Math.cos(rad) * offset, oy + Math.sin(rad) * offset);
    };
    _proto.placeMarkerMid = function placeMarkerMid(marker) {
      var _this$parsedStyle3 = this.parsedStyle,
        points = _this$parsedStyle3.points.points,
        defX = _this$parsedStyle3.defX,
        defY = _this$parsedStyle3.defY;
      // clear all existed markers
      this.markerMidList.forEach(function (marker) {
        marker.remove();
      });
      this.markerMidList = [];
      if (marker && isDisplayObject(marker)) {
        for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
          var ox = points[i][0] - defX;
          var oy = points[i][1] - defY;
          var cloned = i === 1 ? marker : marker.cloneNode(true);
          this.markerMidList.push(cloned);
          this.appendChild(cloned);
          cloned.setLocalPosition(ox, oy);
          // TODO: orient of marker
        }
      }
    };
    return Polygon;
  }(DisplayObject);

  var _excluded$9 = ["style"];
  /**
   * Polyline inherits the marker-related capabilities of Polygon.
   */
  var Polyline = /*#__PURE__*/function (_Polygon) {
    _inheritsLoose(Polyline, _Polygon);
    function Polyline(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$9);
      return _Polygon.call(this, _extends({
        type: Shape.POLYLINE,
        style: runtime.enableCSSParsing ? _extends({
          points: '',
          miterLimit: '',
          isClosed: false
        }, style) : _extends({}, style),
        initialParsedStyle: runtime.enableCSSParsing ? null : {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: false
        }
      }, rest)) || this;
    }
    var _proto = Polyline.prototype;
    _proto.getTotalLength = function getTotalLength() {
      return this.parsedStyle.points.totalLength;
    };
    _proto.getPointAtLength = function getPointAtLength(distance, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      return this.getPoint(distance / this.getTotalLength(), inWorldSpace);
    };
    _proto.getPoint = function getPoint(ratio, inWorldSpace) {
      if (inWorldSpace === void 0) {
        inWorldSpace = false;
      }
      var _this$parsedStyle = this.parsedStyle,
        defX = _this$parsedStyle.defX,
        defY = _this$parsedStyle.defY,
        _this$parsedStyle$poi = _this$parsedStyle.points,
        points = _this$parsedStyle$poi.points,
        segments = _this$parsedStyle$poi.segments;
      var subt = 0;
      var index = 0;
      segments.forEach(function (v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      var _LineUtil$pointAt = line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt),
        x = _LineUtil$pointAt.x,
        y = _LineUtil$pointAt.y;
      var transformed = transformMat4(create$2(), fromValues$2(x - defX, y - defY, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
      // apply local transformation
      return new Point(transformed[0], transformed[1]);
    };
    _proto.getStartTangent = function getStartTangent() {
      var points = this.parsedStyle.points.points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    _proto.getEndTangent = function getEndTangent() {
      var points = this.parsedStyle.points.points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return Polyline;
  }(Polygon);

  var _excluded$a = ["style"];
  var Rect = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Rect, _DisplayObject);
    function Rect(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$a);
      return _DisplayObject.call(this, _extends({
        type: Shape.RECT,
        style: runtime.enableCSSParsing ? _extends({
          x: '',
          y: '',
          width: '',
          height: '',
          radius: ''
        }, style) : _extends({}, style)
      }, rest)) || this;
    }
    return Rect;
  }(DisplayObject);

  var _excluded$b = ["style"];
  /**
   * <text> @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextElement
   */
  var Text = /*#__PURE__*/function (_DisplayObject) {
    _inheritsLoose(Text, _DisplayObject);
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement#constants
     */
    // LENGTHADJUST_SPACING: number = 1;
    // LENGTHADJUST_SPACINGANDGLYPHS: number = 2;
    // LENGTHADJUST_UNKNOWN: number = 0;
    function Text(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        style = _ref.style,
        rest = _objectWithoutPropertiesLoose(_ref, _excluded$b);
      return _DisplayObject.call(this, _extends({
        type: Shape.TEXT,
        style: runtime.enableCSSParsing ? _extends({
          x: '',
          y: '',
          text: '',
          fontSize: '',
          fontFamily: '',
          fontStyle: '',
          fontWeight: '',
          fontVariant: '',
          textAlign: '',
          textBaseline: '',
          textTransform: '',
          fill: 'black',
          letterSpacing: '',
          lineHeight: '',
          miterLimit: '',
          // whiteSpace: 'pre',
          wordWrap: false,
          wordWrapWidth: 0,
          leading: 0,
          dx: '',
          dy: ''
        }, style) : _extends({
          fill: 'black'
        }, style),
        initialParsedStyle: runtime.enableCSSParsing ? {} : {
          x: 0,
          y: 0,
          fontSize: 16,
          fontFamily: 'sans-serif',
          fontStyle: 'normal',
          fontWeight: 'normal',
          fontVariant: 'normal',
          lineHeight: 0,
          letterSpacing: 0,
          textBaseline: 'alphabetic',
          textAlign: 'start',
          wordWrap: false,
          wordWrapWidth: 0,
          leading: 0,
          dx: 0,
          dy: 0
        }
      }, rest)) || this;
    }
    // lengthAdjust: SVGAnimatedEnumeration;
    // textLength: SVGAnimatedLength;
    // getCharNumAtPosition(point?: DOMPointInit): number {
    //   throw new Error('Method not implemented.');
    // }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGTextContentElement
     */
    var _proto = Text.prototype;
    _proto.getComputedTextLength = function getComputedTextLength() {
      var _this$parsedStyle$met;
      return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
    }
    // getEndPositionOfChar(charnum: number): DOMPoint {
    //   throw new Error('Method not implemented.');
    // }
    // getExtentOfChar(charnum: number): DOMRect {
    //   throw new Error('Method not implemented.');
    // }
    // getNumberOfChars(): number {
    //   throw new Error('Method not implemented.');
    // }
    // getRotationOfChar(charnum: number): number {
    //   throw new Error('Method not implemented.');
    // }
    // getStartPositionOfChar(charnum: number): DOMPoint {
    //   throw new Error('Method not implemented.');
    // }
    // getSubStringLength(charnum: number, nchars: number): number {
    //   throw new Error('Method not implemented.');
    // }
    // selectSubString(charnum: number, nchars: number): void {
    //   throw new Error('Method not implemented.');
    // }
    ;
    _proto.getLineBoundingRects = function getLineBoundingRects() {
      var _this$parsedStyle$met2;
      return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
    };
    _proto.isOverflowing = function isOverflowing() {
      return !!this.parsedStyle.isOverflowing;
    };
    return Text;
  }(DisplayObject);

  /**
   * Blink used them in code generation(css_properties.json5)
   */
  var BUILT_IN_PROPERTIES = [{
    /**
     * used in CSS Layout API
     * eg. `display: 'flex'`
     */
    n: 'display',
    k: ['none']
  }, {
    /**
     * range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
     */
    n: 'opacity',
    int: true,
    inh: true,
    d: '1',
    syntax: PropertySyntax.OPACITY_VALUE
  }, {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
     */
    n: 'fillOpacity',
    int: true,
    inh: true,
    d: '1',
    syntax: PropertySyntax.OPACITY_VALUE
  }, {
    /**
     * inheritable, range [0.0, 1.0]
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
     * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
     */
    n: 'strokeOpacity',
    int: true,
    inh: true,
    d: '1',
    syntax: PropertySyntax.OPACITY_VALUE
  }, {
    /**
     * background-color is not inheritable
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
     */
    n: 'fill',
    int: true,
    k: ['none'],
    d: 'none',
    syntax: PropertySyntax.PAINT
  }, {
    n: 'fillRule',
    k: ['nonzero', 'evenodd'],
    d: 'nonzero'
  },
  /**
   * default to none
   * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
   */
  {
    n: 'stroke',
    int: true,
    k: ['none'],
    d: 'none',
    syntax: PropertySyntax.PAINT,
    /**
     * Stroke 'none' won't affect geometry but others will.
     */
    l: true
  }, {
    n: 'shadowType',
    k: ['inner', 'outer', 'both'],
    d: 'outer',
    l: true
  }, {
    n: 'shadowColor',
    int: true,
    syntax: PropertySyntax.COLOR
  }, {
    n: 'shadowOffsetX',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'shadowOffsetY',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'shadowBlur',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.SHADOW_BLUR
  }, {
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
     */
    n: 'lineWidth',
    int: true,
    inh: true,
    d: '1',
    l: true,
    a: ['strokeWidth'],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'increasedLineWidthForHitTesting',
    inh: true,
    d: '0',
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'lineJoin',
    inh: true,
    l: true,
    a: ['strokeLinejoin'],
    k: ['miter', 'bevel', 'round'],
    d: 'miter'
  }, {
    n: 'lineCap',
    inh: true,
    l: true,
    a: ['strokeLinecap'],
    k: ['butt', 'round', 'square'],
    d: 'butt'
  }, {
    n: 'lineDash',
    int: true,
    inh: true,
    k: ['none'],
    a: ['strokeDasharray'],
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  }, {
    n: 'lineDashOffset',
    int: true,
    inh: true,
    d: '0',
    a: ['strokeDashoffset'],
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'offsetPath',
    syntax: PropertySyntax.DEFINED_PATH
  }, {
    n: 'offsetDistance',
    int: true,
    syntax: PropertySyntax.OFFSET_DISTANCE
  }, {
    n: 'dx',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'dy',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'zIndex',
    ind: true,
    int: true,
    d: '0',
    k: ['auto'],
    syntax: PropertySyntax.Z_INDEX
  }, {
    n: 'visibility',
    k: ['visible', 'hidden'],
    ind: true,
    inh: true,
    /**
     * support interpolation
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
     */
    int: true,
    d: 'visible'
  }, {
    n: 'pointerEvents',
    inh: true,
    k: ['none', 'auto', 'stroke', 'fill', 'painted', 'visible', 'visiblestroke', 'visiblefill', 'visiblepainted',
    // 'bounding-box',
    'all'],
    d: 'auto'
  }, {
    n: 'filter',
    ind: true,
    l: true,
    k: ['none'],
    d: 'none',
    syntax: PropertySyntax.FILTER
  }, {
    n: 'clipPath',
    syntax: PropertySyntax.DEFINED_PATH
  }, {
    n: 'textPath',
    syntax: PropertySyntax.DEFINED_PATH
  }, {
    n: 'textPathSide',
    k: ['left', 'right'],
    d: 'left'
  }, {
    n: 'textPathStartOffset',
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'transform',
    p: 100,
    int: true,
    k: ['none'],
    d: 'none',
    syntax: PropertySyntax.TRANSFORM
  }, {
    n: 'transformOrigin',
    p: 100,
    // int: true,
    d: function d(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return 'center';
      }
      if (nodeName === Shape.TEXT) {
        return 'text-anchor';
      }
      return 'left top';
    },
    l: true,
    syntax: PropertySyntax.TRANSFORM_ORIGIN
  }, {
    n: 'anchor',
    p: 99,
    d: function d(nodeName) {
      if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
        return '0.5 0.5';
      }
      return '0 0';
    },
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE_12
  },
  // <circle> & <ellipse>
  {
    n: 'cx',
    int: true,
    d: '0',
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'cy',
    int: true,
    d: '0',
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'r',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'rx',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'ry',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  },
  // Rect Image Group
  {
    // x in local space
    n: 'x',
    int: true,
    d: '0',
    syntax: PropertySyntax.COORDINATE
  }, {
    // y in local space
    n: 'y',
    int: true,
    d: '0',
    syntax: PropertySyntax.COORDINATE
  }, {
    // z in local space
    n: 'z',
    int: true,
    d: '0',
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'width',
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
     */
    k: ['auto', 'fit-content', 'min-content', 'max-content'],
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'height',
    int: true,
    l: true,
    /**
     * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
     */
    k: ['auto', 'fit-content', 'min-content', 'max-content'],
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'radius',
    int: true,
    l: true,
    d: '0',
    syntax: PropertySyntax.LENGTH_PERCENTAGE_14
  },
  // Line
  {
    n: 'x1',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'y1',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'z1',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'x2',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'y2',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  }, {
    n: 'z2',
    int: true,
    l: true,
    syntax: PropertySyntax.COORDINATE
  },
  // Path
  {
    n: 'path',
    int: true,
    l: true,
    d: '',
    a: ['d'],
    syntax: PropertySyntax.PATH,
    p: 50
  },
  // Polyline & Polygon
  {
    n: 'points',
    /**
     * support interpolation
     */
    int: true,
    l: true,
    syntax: PropertySyntax.LIST_OF_POINTS,
    p: 50
  },
  // Text
  {
    n: 'text',
    l: true,
    d: '',
    syntax: PropertySyntax.TEXT,
    p: 50
  }, {
    n: 'textTransform',
    l: true,
    inh: true,
    k: ['capitalize', 'uppercase', 'lowercase', 'none'],
    d: 'none',
    syntax: PropertySyntax.TEXT_TRANSFORM,
    p: 51 // it must get parsed after text
  }, {
    n: 'font',
    l: true
  }, {
    n: 'fontSize',
    int: true,
    inh: true,
    /**
     * @see https://www.w3schools.com/css/css_font_size.asp
     */
    d: '16px',
    l: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    n: 'fontFamily',
    l: true,
    inh: true,
    d: 'sans-serif'
  }, {
    n: 'fontStyle',
    l: true,
    inh: true,
    k: ['normal', 'italic', 'oblique'],
    d: 'normal'
  }, {
    n: 'fontWeight',
    l: true,
    inh: true,
    k: ['normal', 'bold', 'bolder', 'lighter'],
    d: 'normal'
  }, {
    n: 'fontVariant',
    l: true,
    inh: true,
    k: ['normal', 'small-caps'],
    d: 'normal'
  }, {
    n: 'lineHeight',
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: '0'
  }, {
    n: 'letterSpacing',
    l: true,
    syntax: PropertySyntax.LENGTH,
    int: true,
    d: '0'
  }, {
    n: 'miterLimit',
    l: true,
    syntax: PropertySyntax.NUMBER,
    d: function d(nodeName) {
      if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
        return '4';
      }
      return '10';
    }
  }, {
    n: 'wordWrap',
    l: true
  }, {
    n: 'wordWrapWidth',
    l: true
  }, {
    n: 'maxLines',
    l: true
  }, {
    n: 'textOverflow',
    l: true,
    d: 'clip'
  }, {
    n: 'leading',
    l: true
  }, {
    n: 'textBaseline',
    l: true,
    inh: true,
    k: ['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'],
    d: 'alphabetic'
  }, {
    n: 'textAlign',
    l: true,
    inh: true,
    k: ['start', 'center', 'middle', 'end', 'left', 'right'],
    d: 'start'
  },
  // {
  //   n: 'whiteSpace',
  //   l: true,
  // },
  {
    n: 'markerStart',
    syntax: PropertySyntax.MARKER
  }, {
    n: 'markerEnd',
    syntax: PropertySyntax.MARKER
  }, {
    n: 'markerMid',
    syntax: PropertySyntax.MARKER
  }, {
    n: 'markerStartOffset',
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: '0'
  }, {
    n: 'markerEndOffset',
    syntax: PropertySyntax.LENGTH,
    l: true,
    int: true,
    d: '0'
  }];
  var GEOMETRY_ATTRIBUTE_NAMES = BUILT_IN_PROPERTIES.filter(function (n) {
    return !!n.l;
  }).map(function (n) {
    return n.n;
  });
  var propertyMetadataCache = {};
  var unresolvedProperties = new WeakMap();
  // const uniqueAttributeSet = new Set<string>();
  // const tmpVec3a = vec3.create();
  // const tmpVec3b = vec3.create();
  // const tmpVec3c = vec3.create();
  var isPropertyResolved = function isPropertyResolved(object, name) {
    var properties = unresolvedProperties.get(object);
    if (!properties || properties.length === 0) {
      return true;
    }
    return properties.includes(name);
  };
  var DefaultStyleValueRegistry = /*#__PURE__*/function () {
    /**
     * need recalc later
     */
    // dirty = false;
    function DefaultStyleValueRegistry() {
      var _this = this;
      BUILT_IN_PROPERTIES.forEach(function (property) {
        _this.registerMetadata(property);
      });
    }
    var _proto = DefaultStyleValueRegistry.prototype;
    _proto.registerMetadata = function registerMetadata(metadata) {
      [metadata.n].concat(metadata.a || []).forEach(function (name) {
        propertyMetadataCache[name] = metadata;
      });
    };
    _proto.unregisterMetadata = function unregisterMetadata(name) {
      delete propertyMetadataCache[name];
    };
    _proto.getPropertySyntax = function getPropertySyntax(syntax) {
      return runtime.CSSPropertySyntaxFactory[syntax];
    }
    /**
     * * parse value, eg.
     * fill: 'red' => CSSRGB
     * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
     * fontSize: '2em' => { unit: 'px', value: 32 }
     *
     * * calculate used value
     * * post process
     */;
    _proto.processProperties = function processProperties(object, attributes, options) {
      var _this2 = this;
      if (options === void 0) {
        options = {
          skipUpdateAttribute: false,
          skipParse: false,
          forceUpdateGeometry: false,
          usedAttributes: []
        };
      }
      if (!runtime.enableCSSParsing) {
        Object.assign(object.attributes, attributes);
        var _attributeNames = Object.keys(attributes);
        // clipPath
        var oldClipPath = object.parsedStyle.clipPath;
        var oldOffsetPath = object.parsedStyle.offsetPath;
        object.parsedStyle = Object.assign(object.parsedStyle, attributes);
        var _needUpdateGeometry = !!options.forceUpdateGeometry;
        if (!_needUpdateGeometry) {
          for (var i = 0; i < GEOMETRY_ATTRIBUTE_NAMES.length; i++) {
            if (GEOMETRY_ATTRIBUTE_NAMES[i] in attributes) {
              _needUpdateGeometry = true;
              break;
            }
          }
        }
        if (attributes.fill) {
          object.parsedStyle.fill = parseColor(attributes.fill);
        }
        if (attributes.stroke) {
          object.parsedStyle.stroke = parseColor(attributes.stroke);
        }
        if (attributes.shadowColor) {
          object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
        }
        if (attributes.filter) {
          object.parsedStyle.filter = parseFilter(attributes.filter);
        }
        // Rect
        // @ts-ignore
        if (!isNil(attributes.radius)) {
          // @ts-ignore
          object.parsedStyle.radius = parseDimensionArrayFormat(
          // @ts-ignore
          attributes.radius, 4);
        }
        // Polyline
        if (!isNil(attributes.lineDash)) {
          object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
        }
        // @ts-ignore
        if (attributes.points) {
          // @ts-ignore
          object.parsedStyle.points = parsePoints(attributes.points, object);
        }
        // Path
        // @ts-ignore
        if (attributes.path === '') {
          object.parsedStyle.path = _extends({}, EMPTY_PARSED_PATH);
        }
        // @ts-ignore
        if (attributes.path) {
          object.parsedStyle.path = parsePath(
          // @ts-ignore
          attributes.path, object);
        }
        // Text
        if (attributes.textTransform) {
          runtime.CSSPropertySyntaxFactory['<text-transform>'].calculator(null, null, {
            value: attributes.textTransform
          }, object, null);
        }
        if (attributes.clipPath) {
          runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('clipPath', oldClipPath, attributes.clipPath, object, this);
        }
        if (attributes.offsetPath) {
          runtime.CSSPropertySyntaxFactory['<defined-path>'].calculator('offsetPath', oldOffsetPath, attributes.offsetPath, object, this);
        }
        if (attributes.anchor) {
          object.parsedStyle.anchor = parseDimensionArrayFormat(
          // @ts-ignorex
          attributes.anchor, 2);
        }
        if (attributes.transform) {
          object.parsedStyle.transform = parseTransform(attributes.transform);
        }
        if (attributes.transformOrigin) {
          object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
        }
        // Marker
        // @ts-ignore
        if (attributes.markerStart) {
          // @ts-ignore
          object.parsedStyle.markerStart = runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null,
          // @ts-ignore
          attributes.markerStart,
          // @ts-ignore
          attributes.markerStart, null, null);
        }
        // @ts-ignore
        if (attributes.markerEnd) {
          // @ts-ignore
          object.parsedStyle.markerEnd = runtime.CSSPropertySyntaxFactory['<marker>'].calculator(null,
          // @ts-ignore
          attributes.markerEnd,
          // @ts-ignore
          attributes.markerEnd, null, null);
        }
        // @ts-ignore
        if (attributes.markerMid) {
          // @ts-ignore
          object.parsedStyle.markerMid = runtime.CSSPropertySyntaxFactory['<marker>'].calculator('',
          // @ts-ignore
          attributes.markerMid,
          // @ts-ignore
          attributes.markerMid, null, null);
        }
        if (
        // Circle & Ellipse
        (object.nodeName === Shape.CIRCLE || object.nodeName === Shape.ELLIPSE) && (
        // @ts-ignore
        !isNil(attributes.cx) ||
        // @ts-ignore
        !isNil(attributes.cy)) || (object.nodeName === Shape.RECT || object.nodeName === Shape.IMAGE || object.nodeName === Shape.GROUP || object.nodeName === Shape.HTML || object.nodeName === Shape.TEXT || object.nodeName === Shape.MESH) && (
        // @ts-ignore
        !isNil(attributes.x) ||
        // @ts-ignore
        !isNil(attributes.y) ||
        // @ts-ignore
        !isNil(attributes.z)) ||
        // Line
        object.nodeName === Shape.LINE && (
        // @ts-ignore
        !isNil(attributes.x1) ||
        // @ts-ignore
        !isNil(attributes.y1) ||
        // @ts-ignore
        !isNil(attributes.z1) ||
        // @ts-ignore
        !isNil(attributes.x2) ||
        // @ts-ignore
        !isNil(attributes.y2) ||
        // @ts-ignore
        !isNil(attributes.z2))) {
          runtime.CSSPropertySyntaxFactory['<coordinate>'].postProcessor(object, _attributeNames);
        }
        if (!isNil(attributes.zIndex)) {
          runtime.CSSPropertySyntaxFactory['<z-index>'].postProcessor(object, _attributeNames);
        }
        // @ts-ignore
        if (attributes.path) {
          runtime.CSSPropertySyntaxFactory['<path>'].postProcessor(object, _attributeNames);
        }
        // @ts-ignore
        if (attributes.points) {
          runtime.CSSPropertySyntaxFactory['<list-of-points>'].postProcessor(object, _attributeNames);
        }
        if (!isNil(attributes.offsetDistance)) {
          runtime.CSSPropertySyntaxFactory['<offset-distance>'].postProcessor(object, _attributeNames);
        }
        if (attributes.transform) {
          runtime.CSSPropertySyntaxFactory['<transform>'].postProcessor(object, _attributeNames);
        }
        if (_needUpdateGeometry) {
          this.updateGeometry(object);
        }
        return;
      }
      var _options = options,
        skipUpdateAttribute = _options.skipUpdateAttribute,
        skipParse = _options.skipParse,
        forceUpdateGeometry = _options.forceUpdateGeometry,
        usedAttributes = _options.usedAttributes;
      var needUpdateGeometry = forceUpdateGeometry;
      var attributeNames = Object.keys(attributes);
      attributeNames.forEach(function (attributeName) {
        var _propertyMetadataCach;
        if (!skipUpdateAttribute) {
          object.attributes[attributeName] = attributes[attributeName];
        }
        if (!needUpdateGeometry && ((_propertyMetadataCach = propertyMetadataCache[attributeName]) === null || _propertyMetadataCach === void 0 ? void 0 : _propertyMetadataCach.l)) {
          needUpdateGeometry = true;
        }
      });
      if (!skipParse) {
        attributeNames.forEach(function (name) {
          object.computedStyle[name] = _this2.parseProperty(name, object.attributes[name], object);
        });
      }
      // let hasUnresolvedProperties = false;
      // parse according to priority
      // path 50
      // points 50
      // text 50
      // textTransform 51
      // anchor 99
      // transform 100
      // transformOrigin 100
      if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
        // uniqueAttributeSet.clear();
        attributeNames = Array.from(new Set(attributeNames.concat(usedAttributes)));
      }
      // [
      //   'path',
      //   'points',
      //   'text',
      //   'textTransform',
      //   'anchor',
      //   'transform',
      //   'transformOrigin',
      // ].forEach((name) => {
      //   const index = attributeNames.indexOf(name);
      //   if (index > -1) {
      //     attributeNames.splice(index, 1);
      //     attributeNames.push(name);
      //   }
      // });
      attributeNames.forEach(function (name) {
        // some style props maybe deleted after parsing such as `anchor` in Text
        if (name in object.computedStyle) {
          object.parsedStyle[name] = _this2.computeProperty(name, object.computedStyle[name], object);
        }
      });
      // if (hasUnresolvedProperties) {
      //   this.dirty = true;
      //   return;
      // }
      // update geometry
      if (needUpdateGeometry) {
        // object.geometry.dirty = true;
        // runtime.sceneGraphService.dirtifyToRoot(object);
        this.updateGeometry(object);
      }
      attributeNames.forEach(function (name) {
        if (name in object.parsedStyle) {
          _this2.postProcessProperty(name, object, attributeNames);
        }
      });
      if (runtime.enableCSSParsing && object.children.length) {
        attributeNames.forEach(function (name) {
          if (name in object.parsedStyle && _this2.isPropertyInheritable(name)) {
            // update children's inheritable
            object.children.forEach(function (child) {
              child.internalSetAttribute(name, null, {
                skipUpdateAttribute: true,
                skipParse: true
              });
            });
          }
        });
      }
    }
    /**
     * string -> parsed value
     */;
    _proto.parseProperty = function parseProperty(name, value, object) {
      var metadata = propertyMetadataCache[name];
      var computed = value;
      if (value === '' || isNil(value)) {
        value = 'unset';
      }
      if (value === 'unset' || value === 'initial' || value === 'inherit') {
        // computed = new CSSKeywordValue(value);
        computed = getOrCreateKeyword(value);
      } else {
        if (metadata) {
          var keywords = metadata.k,
            syntax = metadata.syntax;
          var handler = syntax && this.getPropertySyntax(syntax);
          // use keywords
          if (keywords && keywords.indexOf(value) > -1) {
            // computed = new CSSKeywordValue(value);
            computed = getOrCreateKeyword(value);
          } else if (handler && handler.parser) {
            // try to parse it to CSSStyleValue, eg. '10px' -> CSS.px(10)
            computed = handler.parser(value, object);
          }
        }
      }
      return computed;
    }
    /**
     * computed value -> used value
     */;
    _proto.computeProperty = function computeProperty(name, computed, object) {
      var metadata = propertyMetadataCache[name];
      var isDocumentElement = object.id === 'g-root';
      // let used: CSSStyleValue = computed instanceof CSSStyleValue ? computed.clone() : computed;
      var used = computed;
      if (metadata) {
        var syntax = metadata.syntax,
          inherited = metadata.inh,
          defaultValue = metadata.d;
        if (computed instanceof CSSKeywordValue) {
          var value = computed.value;
          /**
           * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/unset
           */
          if (value === 'unset') {
            if (inherited && !isDocumentElement) {
              value = 'inherit';
            } else {
              value = 'initial';
            }
          }
          if (value === 'initial') {
            // @see https://developer.mozilla.org/en-US/docs/Web/CSS/initial
            if (!isNil(defaultValue)) {
              computed = this.parseProperty(name, isFunction$1(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object);
            }
          } else if (value === 'inherit') {
            // @see https://developer.mozilla.org/en-US/docs/Web/CSS/inherit
            // behave like `inherit`
            var resolved = this.tryToResolveProperty(object, name, {
              inherited: true
            });
            if (!isNil(resolved)) {
              // object.parsedStyle[name] = resolved;
              // return false;
              return resolved;
            } else {
              this.addUnresolveProperty(object, name);
              return;
            }
          }
        }
        var handler = syntax && this.getPropertySyntax(syntax);
        if (handler && handler.calculator) {
          // convert computed value to used value
          var oldParsedValue = object.parsedStyle[name];
          used = handler.calculator(name, oldParsedValue, computed, object, this);
        } else if (computed instanceof CSSKeywordValue) {
          used = computed.value;
        } else {
          used = computed;
        }
      }
      // object.parsedStyle[name] = used;
      // return false;
      return used;
    };
    _proto.postProcessProperty = function postProcessProperty(name, object, attributes) {
      var metadata = propertyMetadataCache[name];
      if (metadata && metadata.syntax) {
        var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
        var propertyHandler = handler;
        if (propertyHandler && propertyHandler.postProcessor) {
          propertyHandler.postProcessor(object, attributes);
        }
      }
    }
    /**
     * resolve later
     */;
    _proto.addUnresolveProperty = function addUnresolveProperty(object, name) {
      var properties = unresolvedProperties.get(object);
      if (!properties) {
        unresolvedProperties.set(object, []);
        properties = unresolvedProperties.get(object);
      }
      if (properties.indexOf(name) === -1) {
        properties.push(name);
      }
    };
    _proto.tryToResolveProperty = function tryToResolveProperty(object, name, options) {
      if (options === void 0) {
        options = {};
      }
      var _options2 = options,
        inherited = _options2.inherited;
      if (inherited) {
        if (object.parentElement && isPropertyResolved(object.parentElement, name)) {
          // const computedValue = object.parentElement.computedStyle[name];
          var usedValue = object.parentElement.parsedStyle[name];
          if (
          // usedValue instanceof CSSKeywordValue &&
          usedValue === 'unset' || usedValue === 'initial' || usedValue === 'inherit') {
            return;
          }
          // else if (
          //   usedValue instanceof CSSUnitValue &&
          //   CSSUnitValue.isRelativeUnit(usedValue.unit)
          // ) {
          //   return false;
          // }
          return usedValue;
        }
      }
      return;
    };
    _proto.recalc = function recalc(object) {
      var properties = unresolvedProperties.get(object);
      if (properties && properties.length) {
        var attributes = {};
        properties.forEach(function (property) {
          attributes[property] = object.attributes[property];
        });
        this.processProperties(object, attributes);
        unresolvedProperties.delete(object);
      }
    }
    /**
     * update geometry when relative props changed,
     * eg. r of Circle, width/height of Rect
     */;
    _proto.updateGeometry = function updateGeometry(object) {
      var nodeName = object.nodeName;
      var geometryUpdater = runtime.geometryUpdaterFactory[nodeName];
      if (geometryUpdater) {
        var geometry = object.geometry;
        if (!geometry.contentBounds) {
          geometry.contentBounds = new AABB();
        }
        if (!geometry.renderBounds) {
          geometry.renderBounds = new AABB();
        }
        var parsedStyle = object.parsedStyle;
        var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object),
          width = _geometryUpdater$upda.width,
          height = _geometryUpdater$upda.height,
          _geometryUpdater$upda2 = _geometryUpdater$upda.depth,
          depth = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2,
          _geometryUpdater$upda3 = _geometryUpdater$upda.offsetX,
          offsetX = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3,
          _geometryUpdater$upda4 = _geometryUpdater$upda.offsetY,
          offsetY = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4,
          _geometryUpdater$upda5 = _geometryUpdater$upda.offsetZ,
          offsetZ = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5;
        // init with content box
        var halfExtents = [Math.abs(width) / 2, Math.abs(height) / 2, depth / 2];
        // const halfExtents = vec3.set(
        //   tmpVec3a,
        //   Math.abs(width) / 2,
        //   Math.abs(height) / 2,
        //   depth / 2,
        // );
        // anchor is center by default, don't account for lineWidth here
        var stroke = parsedStyle.stroke,
          lineWidth = parsedStyle.lineWidth,
          increasedLineWidthForHitTesting = parsedStyle.increasedLineWidthForHitTesting,
          shadowType = parsedStyle.shadowType,
          shadowColor = parsedStyle.shadowColor,
          _parsedStyle$filter = parsedStyle.filter,
          filter = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter,
          transformOrigin = parsedStyle.transformOrigin;
        var anchor = parsedStyle.anchor;
        // <Text> use textAlign & textBaseline instead of anchor
        if (nodeName === Shape.TEXT) {
          delete parsedStyle.anchor;
        }
        var center = [(1 - (anchor && anchor[0] || 0) * 2) * width / 2 + offsetX, (1 - (anchor && anchor[1] || 0) * 2) * height / 2 + offsetY, (1 - (anchor && anchor[2] || 0) * 2) * halfExtents[2] + offsetZ];
        // const center = vec3.set(
        //   tmpVec3b,
        //   ((1 - ((anchor && anchor[0]) || 0) * 2) * width) / 2 + offsetX,
        //   ((1 - ((anchor && anchor[1]) || 0) * 2) * height) / 2 + offsetY,
        //   (1 - ((anchor && anchor[2]) || 0) * 2) * halfExtents[2] + offsetZ,
        // );
        // update geometry's AABB
        geometry.contentBounds.update(center, halfExtents);
        // @see https://github.molgen.mpg.de/git-mirror/cairo/blob/master/src/cairo-stroke-style.c#L97..L128
        var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
        // if (lineCap?.value === 'square') {
        //   expansion = Math.SQRT1_2;
        // }
        // if (lineJoin?.value === 'miter' && expansion < Math.SQRT2 * miterLimit) {
        //   expansion = Math.SQRT1_2 * miterLimit;
        // }
        // append border only if stroke existed
        var hasStroke = stroke && !stroke.isNone;
        if (hasStroke) {
          var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
          // halfExtents[0] += halfLineWidth[0];
          // halfExtents[1] += halfLineWidth[1];
          halfExtents[0] += halfLineWidth;
          halfExtents[1] += halfLineWidth;
          // vec3.add(
          //   halfExtents,
          //   halfExtents,
          //   vec3.set(tmpVec3c, halfLineWidth, halfLineWidth, 0),
          // );
        }

        geometry.renderBounds.update(center, halfExtents);
        // account for shadow, only support constant value now
        if (shadowColor && shadowType && shadowType !== 'inner') {
          var _geometry$renderBound = geometry.renderBounds,
            min = _geometry$renderBound.min,
            max = _geometry$renderBound.max;
          var shadowBlur = parsedStyle.shadowBlur,
            shadowOffsetX = parsedStyle.shadowOffsetX,
            shadowOffsetY = parsedStyle.shadowOffsetY;
          var shadowBlurInPixels = shadowBlur || 0;
          var shadowOffsetXInPixels = shadowOffsetX || 0;
          var shadowOffsetYInPixels = shadowOffsetY || 0;
          var shadowLeft = min[0] - shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowRight = max[0] + shadowBlurInPixels + shadowOffsetXInPixels;
          var shadowTop = min[1] - shadowBlurInPixels + shadowOffsetYInPixels;
          var shadowBottom = max[1] + shadowBlurInPixels + shadowOffsetYInPixels;
          min[0] = Math.min(min[0], shadowLeft);
          max[0] = Math.max(max[0], shadowRight);
          min[1] = Math.min(min[1], shadowTop);
          max[1] = Math.max(max[1], shadowBottom);
          geometry.renderBounds.setMinMax(min, max);
        }
        // account for filter, eg. blur(5px), drop-shadow()
        filter.forEach(function (_ref) {
          var name = _ref.name,
            params = _ref.params;
          if (name === 'blur') {
            var blurRadius = params[0].value;
            geometry.renderBounds.update(geometry.renderBounds.center, addVec3(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
          } else if (name === 'drop-shadow') {
            var _shadowOffsetX = params[0].value;
            var _shadowOffsetY = params[1].value;
            var _shadowBlur = params[2].value;
            var _geometry$renderBound2 = geometry.renderBounds,
              _min = _geometry$renderBound2.min,
              _max = _geometry$renderBound2.max;
            var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
            var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
            var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
            var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
            _min[0] = Math.min(_min[0], _shadowLeft);
            _max[0] = Math.max(_max[0], _shadowRight);
            _min[1] = Math.min(_min[1], _shadowTop);
            _max[1] = Math.max(_max[1], _shadowBottom);
            geometry.renderBounds.setMinMax(_min, _max);
          }
        });
        anchor = parsedStyle.anchor;
        // if (nodeName === Shape.RECT) {
        // account for negative width / height of Rect
        // @see https://github.com/antvis/g/issues/957
        var flipY = width < 0;
        var flipX = height < 0;
        // } else {
        // }
        // set transform origin
        var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object) : 0);
        var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object) : 0);
        usedOriginXValue = usedOriginXValue - (flipY ? -1 : 1) * (anchor && anchor[0] || 0) * geometry.contentBounds.halfExtents[0] * 2;
        usedOriginYValue = usedOriginYValue - (flipX ? -1 : 1) * (anchor && anchor[1] || 0) * geometry.contentBounds.halfExtents[1] * 2;
        object.setOrigin(usedOriginXValue, usedOriginYValue);
        // FIXME setOrigin may have already dirtified to root.
        runtime.sceneGraphService.dirtifyToRoot(object);
      }
    };
    _proto.isPropertyInheritable = function isPropertyInheritable(name) {
      var metadata = propertyMetadataCache[name];
      if (!metadata) {
        return false;
      }
      return metadata.inh;
    };
    return DefaultStyleValueRegistry;
  }();

  /**
   * Different type of cameras, eg. simple camera used in 2D scene or
   * advanced camera which can do actions & switch between landmarks.
   */
  var CameraType;
  (function (CameraType) {
    /**
     * Performs all the rotational operations with the focal point instead of the camera position.
     * This type of camera is useful in applications(like CAD) where 3D objects are being designed or explored.
     * Camera cannot orbits over the north & south poles.
     * @see http://voxelent.com/tutorial-cameras/
     *
     * In Three.js it's used in OrbitControls.
     * @see https://threejs.org/docs/#examples/zh/controls/OrbitControls
     */
    CameraType[CameraType["ORBITING"] = 0] = "ORBITING";
    /**
     * It's similar to the ORBITING camera, but it allows the camera to orbit over the north or south poles.
     *
     * In Three.js it's used in OrbitControls.
     * @see https://threejs.org/docs/#examples/en/controls/TrackballControls
     */
    CameraType[CameraType["EXPLORING"] = 1] = "EXPLORING";
    /**
     * Performs all the rotational operations with the camera position.
     * It's useful in first person shooting games.
     * Camera cannot orbits over the north & south poles.
     *
     * In Three.js it's used in FirstPersonControls.
     * @see https://threejs.org/docs/#examples/en/controls/FirstPersonControls
     */
    CameraType[CameraType["TRACKING"] = 2] = "TRACKING";
  })(CameraType || (CameraType = {}));
  /**
   * CameraType must be TRACKING
   */
  var CameraTrackingMode;
  (function (CameraTrackingMode) {
    CameraTrackingMode[CameraTrackingMode["DEFAULT"] = 0] = "DEFAULT";
    CameraTrackingMode[CameraTrackingMode["ROTATIONAL"] = 1] = "ROTATIONAL";
    CameraTrackingMode[CameraTrackingMode["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
    CameraTrackingMode[CameraTrackingMode["CINEMATIC"] = 3] = "CINEMATIC";
  })(CameraTrackingMode || (CameraTrackingMode = {}));
  var CameraProjectionMode;
  (function (CameraProjectionMode) {
    CameraProjectionMode[CameraProjectionMode["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
    CameraProjectionMode[CameraProjectionMode["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  })(CameraProjectionMode || (CameraProjectionMode = {}));
  var CameraEvent = {
    UPDATED: 'updated'
  };

  var MIN_DISTANCE = 0.0002;
  /**
   * WebGL Insights - 23.Designing Cameras for WebGL Applications Responsible Camera 
   * @see https://github.com/d13g0/nucleo.js/blob/master/source/camera/Camera.js
   *
   * 
   * 1. dolly  n 
   * 2. pan  u v 
   * 3. rotate 
   * 4.  Landmark
   */
  var Camera = /*#__PURE__*/function () {
    function Camera() {
      this.canvas = void 0;
      this.eventEmitter = new eventemitter3();
      /**
       * 
       */
      this.matrix = create$1();
      /**
       * u 
       * @see http://learnwebgl.brown37.net/07_cameras/camera_introduction.html#a-camera-definition
       */
      this.right = fromValues$2(1, 0, 0);
      /**
       * v  +Y is down
       */
      this.up = fromValues$2(0, 1, 0);
      /**
       * n  +Z is inside
       */
      this.forward = fromValues$2(0, 0, 1);
      /**
       * 
       */
      this.position = fromValues$2(0, 0, 1);
      /**
       * 
       */
      this.focalPoint = fromValues$2(0, 0, 0);
      /**
       * 
       * focalPoint - position
       */
      this.distanceVector = fromValues$2(0, 0, -1);
      /**
       * 
       * length(focalPoint - position)
       */
      this.distance = 1;
      /**
       * @see https://en.wikipedia.org/wiki/Azimuth
       */
      this.azimuth = 0;
      this.elevation = 0;
      this.roll = 0;
      this.relAzimuth = 0;
      this.relElevation = 0;
      this.relRoll = 0;
      /**
       *  n 
       */
      this.dollyingStep = 0;
      this.maxDistance = Infinity;
      this.minDistance = -Infinity;
      /**
       * zoom factor of the camera, default is 1
       * eg. https://threejs.org/docs/#api/en/cameras/OrthographicCamera.zoom
       */
      this.zoom = 1;
      /**
       * invert the horizontal coordinate system HCS
       */
      this.rotateWorld = false;
      /**
       * 
       */
      /**
       * field of view [0-360]
       * @see http://en.wikipedia.org/wiki/Angle_of_view
       */
      this.fov = 30;
      this.near = 0.1;
      this.far = 1000;
      this.aspect = 1;
      this.left = void 0;
      this.rright = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.projectionMatrix = create$1();
      this.projectionMatrixInverse = create$1();
      this.jitteredProjectionMatrix = undefined;
      this.view = void 0;
      this.enableUpdate = true;
      // protected following = undefined;
      this.type = CameraType.EXPLORING;
      this.trackingMode = CameraTrackingMode.DEFAULT;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      /**
       * for culling use
       */
      this.frustum = new Frustum();
      /**
       * ortho matrix for Canvas2D & SVG
       */
      this.orthoMatrix = create$1();
    }
    var _proto = Camera.prototype;
    // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
    //   this.setType(type, trackingMode);
    // }
    _proto.isOrtho = function isOrtho() {
      return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
    };
    _proto.getProjectionMode = function getProjectionMode() {
      return this.projectionMode;
    };
    _proto.getPerspective = function getPerspective() {
      // account for TAA
      return this.jitteredProjectionMatrix || this.projectionMatrix;
    };
    _proto.getPerspectiveInverse = function getPerspectiveInverse() {
      return this.projectionMatrixInverse;
    };
    _proto.getFrustum = function getFrustum() {
      return this.frustum;
    };
    _proto.getPosition = function getPosition() {
      return this.position;
    };
    _proto.getFocalPoint = function getFocalPoint() {
      return this.focalPoint;
    };
    _proto.getDollyingStep = function getDollyingStep() {
      return this.dollyingStep;
    };
    _proto.getNear = function getNear() {
      return this.near;
    };
    _proto.getFar = function getFar() {
      return this.far;
    };
    _proto.getZoom = function getZoom() {
      return this.zoom;
    };
    _proto.getOrthoMatrix = function getOrthoMatrix() {
      return this.orthoMatrix;
    };
    _proto.getView = function getView() {
      return this.view;
    };
    _proto.setEnableUpdate = function setEnableUpdate(enabled) {
      this.enableUpdate = enabled;
    };
    _proto.setType = function setType(type, trackingMode) {
      this.type = type;
      if (this.type === CameraType.EXPLORING) {
        this.setWorldRotation(true);
      } else {
        this.setWorldRotation(false);
      }
      this._getAngles();
      if (this.type === CameraType.TRACKING && trackingMode !== undefined) {
        this.setTrackingMode(trackingMode);
      }
      return this;
    };
    _proto.setProjectionMode = function setProjectionMode(projectionMode) {
      this.projectionMode = projectionMode;
      return this;
    };
    _proto.setTrackingMode = function setTrackingMode(trackingMode) {
      if (this.type !== CameraType.TRACKING) {
        throw new Error('Impossible to set a tracking mode if the camera is not of tracking type');
      }
      this.trackingMode = trackingMode;
      return this;
    }
    /**
     * If flag is true, it reverses the azimuth and elevation angles.
     * Subsequent calls to rotate, setAzimuth, setElevation,
     * changeAzimuth or changeElevation will cause the inverted effect.
     * setRoll or changeRoll is not affected by this method.
     *
     * This inversion is useful when one wants to simulate that the world
     * is moving, instead of the camera.
     *
     * By default the camera angles are not reversed.
     * @param {Boolean} flag the boolean flag to reverse the angles.
     */;
    _proto.setWorldRotation = function setWorldRotation(flag) {
      this.rotateWorld = flag;
      this._getAngles();
      return this;
    }
    /**
     *  MV 
     */;
    _proto.getViewTransform = function getViewTransform() {
      return invert(create$1(), this.matrix);
    };
    _proto.getWorldTransform = function getWorldTransform() {
      return this.matrix;
    };
    _proto.jitterProjectionMatrix = function jitterProjectionMatrix(x, y) {
      var translation = fromTranslation(create$1(), [x, y, 0]);
      this.jitteredProjectionMatrix = multiply(create$1(), translation, this.projectionMatrix);
    };
    _proto.clearJitterProjectionMatrix = function clearJitterProjectionMatrix() {
      this.jitteredProjectionMatrix = undefined;
    }
    /**
     * 
     */;
    _proto.setMatrix = function setMatrix(matrix) {
      this.matrix = matrix;
      this._update();
      return this;
    };
    _proto.setFov = function setFov(fov) {
      this.setPerspective(this.near, this.far, fov, this.aspect);
      return this;
    };
    _proto.setAspect = function setAspect(aspect) {
      this.setPerspective(this.near, this.far, this.fov, aspect);
      return this;
    };
    _proto.setNear = function setNear(near) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
      }
      return this;
    };
    _proto.setFar = function setFar(far) {
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
      }
      return this;
    }
    /**
     * Sets an offset in a larger frustum, used in PixelPicking
     */;
    _proto.setViewOffset = function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === undefined) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width;
      this.view.height = height;
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    };
    _proto.clearViewOffset = function clearViewOffset() {
      if (this.view !== undefined) {
        this.view.enabled = false;
      }
      if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      } else {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      }
      return this;
    };
    _proto.setZoom = function setZoom(zoom) {
      this.zoom = zoom;
      if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
      } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
        this.setPerspective(this.near, this.far, this.fov, this.aspect);
      }
      return this;
    }
    /**
     * Zoom by specified point in viewport coordinates.
     */;
    _proto.setZoomByViewportPoint = function setZoomByViewportPoint(zoom, viewportPoint) {
      var _this$canvas$viewport = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }),
        ox = _this$canvas$viewport.x,
        oy = _this$canvas$viewport.y;
      var roll = this.roll;
      this.rotate(0, 0, -roll);
      this.setPosition(ox, oy);
      this.setFocalPoint(ox, oy);
      this.setZoom(zoom);
      this.rotate(0, 0, roll);
      var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }),
        cx = _this$canvas$viewport2.x,
        cy = _this$canvas$viewport2.y;
      // project to rotated axis
      var dvec = fromValues$2(cx - ox, cy - oy, 0);
      var dx = dot(dvec, this.right) / length(this.right);
      var dy = dot(dvec, this.up) / length(this.up);
      this.pan(-dx, -dy);
      return this;
    };
    _proto.setPerspective = function setPerspective(near, far, fov, aspect) {
      var _this$view;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.fov = fov;
      this.near = near;
      this.far = far;
      this.aspect = aspect;
      var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
      var height = 2 * top;
      var width = this.aspect * height;
      var left = -0.5 * width;
      if ((_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.enabled) {
        var fullWidth = this.view.fullWidth;
        var fullHeight = this.view.fullHeight;
        left += this.view.offsetX * width / fullWidth;
        top -= this.view.offsetY * height / fullHeight;
        width *= this.view.width / fullWidth;
        height *= this.view.height / fullHeight;
      }
      makePerspective(this.projectionMatrix, left, left + width, top, top - height, near, this.far);
      // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
      scale(this.projectionMatrix, this.projectionMatrix, fromValues$2(1, -1, 1));
      invert(this.projectionMatrixInverse, this.projectionMatrix);
      this.triggerUpdate();
      return this;
    };
    _proto.setOrthographic = function setOrthographic(l, r, t, b, near, far) {
      var _this$view2;
      this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
      this.rright = r;
      this.left = l;
      this.top = t;
      this.bottom = b;
      this.near = near;
      this.far = far;
      var dx = (this.rright - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.rright + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if ((_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.enabled) {
        var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      ortho(this.projectionMatrix, left, right, bottom, top, near, far);
      // flipY since the origin of OpenGL/WebGL is bottom-left compared with top-left in Canvas2D
      scale(this.projectionMatrix, this.projectionMatrix, fromValues$2(1, -1, 1));
      invert(this.projectionMatrixInverse, this.projectionMatrix);
      this._getOrthoMatrix();
      this.triggerUpdate();
      return this;
    }
    /**
     * Move the camera in world coordinates.
     * It will keep looking at the current focal point.
     *
     * support scalars or vectors.
     * @example
     * setPosition(1, 2, 3);
     * setPosition([1, 2, 3]);
     */;
    _proto.setPosition = function setPosition(x, y, z) {
      if (y === void 0) {
        y = this.position[1];
      }
      if (z === void 0) {
        z = this.position[2];
      }
      var position = createVec3(x, y, z);
      this._setPosition(position);
      this.setFocalPoint(this.focalPoint);
      this.triggerUpdate();
      return this;
    }
    /**
     * Sets the focal point of this camera in world coordinates.
     *
     * support scalars or vectors.
     * @example
     * setFocalPoint(1, 2, 3);
     * setFocalPoint([1, 2, 3]);
     */;
    _proto.setFocalPoint = function setFocalPoint(x, y, z) {
      if (y === void 0) {
        y = this.focalPoint[1];
      }
      if (z === void 0) {
        z = this.focalPoint[2];
      }
      var up = fromValues$2(0, 1, 0);
      this.focalPoint = createVec3(x, y, z);
      if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
        var d = subtract$1(create$2(), this.focalPoint, this.position);
        x = d[0];
        y = d[1];
        z = d[2];
        var r = length(d);
        var el = rad2deg(Math.asin(y / r));
        var az = 90 + rad2deg(Math.atan2(z, x));
        var m = create$1();
        rotateY(m, m, deg2rad(az));
        rotateX(m, m, deg2rad(el));
        up = transformMat4(create$2(), [0, 1, 0], m);
      }
      invert(this.matrix, lookAt(create$1(), this.position, this.focalPoint, up));
      this._getAxes();
      this._getDistance();
      this._getAngles();
      this.triggerUpdate();
      return this;
    };
    _proto.getDistance = function getDistance() {
      return this.distance;
    };
    _proto.getDistanceVector = function getDistanceVector() {
      return this.distanceVector;
    }
    /**
     * Moves the camera towards/from the focal point.
     */;
    _proto.setDistance = function setDistance(d) {
      if (this.distance === d || d < 0) {
        return this;
      }
      this.distance = d;
      if (this.distance < MIN_DISTANCE) {
        this.distance = MIN_DISTANCE;
      }
      this.dollyingStep = this.distance / 100;
      var pos = create$2();
      d = this.distance;
      var n = this.forward;
      var f = this.focalPoint;
      pos[0] = d * n[0] + f[0];
      pos[1] = d * n[1] + f[1];
      pos[2] = d * n[2] + f[2];
      this._setPosition(pos);
      this.triggerUpdate();
      return this;
    };
    _proto.setMaxDistance = function setMaxDistance(d) {
      this.maxDistance = d;
      return this;
    };
    _proto.setMinDistance = function setMinDistance(d) {
      this.minDistance = d;
      return this;
    }
    /**
     * 
     * the azimuth in degrees
     */;
    _proto.setAzimuth = function setAzimuth(az) {
      this.azimuth = getAngle$1(az);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    _proto.getAzimuth = function getAzimuth() {
      return this.azimuth;
    }
    /**
     * 
     */;
    _proto.setElevation = function setElevation(el) {
      this.elevation = getAngle$1(el);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    _proto.getElevation = function getElevation() {
      return this.elevation;
    }
    /**
     * 
     */;
    _proto.setRoll = function setRoll(angle) {
      this.roll = getAngle$1(angle);
      this.computeMatrix();
      this._getAxes();
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        this._getPosition();
      } else if (this.type === CameraType.TRACKING) {
        this._getFocalPoint();
      }
      this.triggerUpdate();
      return this;
    };
    _proto.getRoll = function getRoll() {
      return this.roll;
    }
    /**
     * 
     */;
    _proto._update = function _update() {
      this._getAxes();
      this._getPosition();
      this._getDistance();
      this._getAngles();
      this._getOrthoMatrix();
      this.triggerUpdate();
    }
    /**
     * 
     */;
    _proto.computeMatrix = function computeMatrix() {
      //  3D 
      // @see https://xiaoiver.github.io/coding/2018/12/28/Camera-%E8%AE%BE%E8%AE%A1-%E4%B8%80.html
      var rotZ = setAxisAngle(create$4(), [0, 0, 1], deg2rad(this.roll));
      identity(this.matrix);
      // only consider HCS for EXPLORING and ORBITING cameras
      var rotX = setAxisAngle(create$4(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
      var rotY = setAxisAngle(create$4(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
      var rotQ = multiply$2(create$4(), rotY, rotX);
      rotQ = multiply$2(create$4(), rotQ, rotZ);
      var rotMatrix = fromQuat(create$1(), rotQ);
      if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
        translate(this.matrix, this.matrix, this.focalPoint);
        multiply(this.matrix, this.matrix, rotMatrix);
        translate(this.matrix, this.matrix, [0, 0, this.distance]);
      } else if (this.type === CameraType.TRACKING) {
        translate(this.matrix, this.matrix, this.position);
        multiply(this.matrix, this.matrix, rotMatrix);
      }
    }
    /**
     * Sets the camera position in the camera matrix
     */;
    _proto._setPosition = function _setPosition(x, y, z) {
      this.position = createVec3(x, y, z);
      var m = this.matrix;
      m[12] = this.position[0];
      m[13] = this.position[1];
      m[14] = this.position[2];
      m[15] = 1;
      this._getOrthoMatrix();
    }
    /**
     * Recalculates axes based on the current matrix
     */;
    _proto._getAxes = function _getAxes() {
      copy$1(this.right, createVec3(transformMat4$1(create$3(), [1, 0, 0, 0], this.matrix)));
      copy$1(this.up, createVec3(transformMat4$1(create$3(), [0, 1, 0, 0], this.matrix)));
      copy$1(this.forward, createVec3(transformMat4$1(create$3(), [0, 0, 1, 0], this.matrix)));
      normalize(this.right, this.right);
      normalize(this.up, this.up);
      normalize(this.forward, this.forward);
    }
    /**
     * Recalculates euler angles based on the current state
     */;
    _proto._getAngles = function _getAngles() {
      // Recalculates angles
      var x = this.distanceVector[0];
      var y = this.distanceVector[1];
      var z = this.distanceVector[2];
      var r = length(this.distanceVector);
      // FAST FAIL: If there is no distance we cannot compute angles
      if (r === 0) {
        this.elevation = 0;
        this.azimuth = 0;
        return;
      }
      if (this.type === CameraType.TRACKING) {
        this.elevation = rad2deg(Math.asin(y / r));
        this.azimuth = rad2deg(Math.atan2(-x, -z));
      } else {
        if (this.rotateWorld) {
          this.elevation = rad2deg(Math.asin(y / r));
          this.azimuth = rad2deg(Math.atan2(-x, -z));
        } else {
          this.elevation = -rad2deg(Math.asin(y / r));
          this.azimuth = -rad2deg(Math.atan2(-x, -z));
        }
      }
    }
    /**
     *  ORBITING 
     */;
    _proto._getPosition = function _getPosition() {
      copy$1(this.position, createVec3(transformMat4$1(create$3(), [0, 0, 0, 1], this.matrix)));
      // 
      this._getDistance();
    }
    /**
     *  TRACKING 
     */;
    _proto._getFocalPoint = function _getFocalPoint() {
      transformMat3(this.distanceVector, [0, 0, -this.distance], fromMat4(create(), this.matrix));
      add$1(this.focalPoint, this.position, this.distanceVector);
      // 
      this._getDistance();
    }
    /**
     * 
     */;
    _proto._getDistance = function _getDistance() {
      this.distanceVector = subtract$1(create$2(), this.focalPoint, this.position);
      this.distance = length(this.distanceVector);
      this.dollyingStep = this.distance / 100;
    };
    _proto._getOrthoMatrix = function _getOrthoMatrix() {
      if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
        return;
      }
      var position = this.position;
      var rotZ = setAxisAngle(create$4(), [0, 0, 1], -this.roll * Math.PI / 180);
      fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, fromValues$2((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), fromValues$2(this.zoom, this.zoom, 1), position);
    };
    _proto.triggerUpdate = function triggerUpdate() {
      if (this.enableUpdate) {
        // update frustum
        var viewMatrix = this.getViewTransform();
        var vpMatrix = multiply(create$1(), this.getPerspective(), viewMatrix);
        this.getFrustum().extractFromVPMatrix(vpMatrix);
        this.eventEmitter.emit(CameraEvent.UPDATED);
      }
    };
    _proto.rotate = function rotate(azimuth, elevation, roll) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.pan = function pan(tx, ty) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.dolly = function dolly(value) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.createLandmark = function createLandmark(name, params) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.gotoLandmark = function gotoLandmark(name, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.cancelLandmarkAnimation = function cancelLandmarkAnimation() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    return Camera;
  }();

  var CircleUpdater = /*#__PURE__*/function () {
    function CircleUpdater() {}
    var _proto = CircleUpdater.prototype;
    _proto.update = function update(parsedStyle, object) {
      var r = parsedStyle.r;
      var width = r * 2;
      var height = r * 2;
      return {
        width: width,
        height: height
      };
    };
    return CircleUpdater;
  }();

  var EllipseUpdater = /*#__PURE__*/function () {
    function EllipseUpdater() {}
    var _proto = EllipseUpdater.prototype;
    _proto.update = function update(parsedStyle, object) {
      var rx = parsedStyle.rx,
        ry = parsedStyle.ry;
      var width = rx * 2;
      var height = ry * 2;
      return {
        width: width,
        height: height
      };
    };
    return EllipseUpdater;
  }();

  var LineUpdater = /*#__PURE__*/function () {
    function LineUpdater() {}
    var _proto = LineUpdater.prototype;
    _proto.update = function update(parsedStyle) {
      var x1 = parsedStyle.x1,
        y1 = parsedStyle.y1,
        x2 = parsedStyle.x2,
        y2 = parsedStyle.y2;
      var minX = Math.min(x1, x2);
      var maxX = Math.max(x1, x2);
      var minY = Math.min(y1, y2);
      var maxY = Math.max(y1, y2);
      var width = maxX - minX;
      var height = maxY - minY;
      return {
        width: width,
        height: height
      };
    };
    return LineUpdater;
  }();

  var PathUpdater = /*#__PURE__*/function () {
    function PathUpdater() {}
    var _proto = PathUpdater.prototype;
    _proto.update = function update(parsedStyle) {
      var path = parsedStyle.path;
      var _path$rect = path.rect,
        width = _path$rect.width,
        height = _path$rect.height;
      return {
        width: width,
        height: height
      };
    };
    return PathUpdater;
  }();

  var PolylineUpdater = /*#__PURE__*/function () {
    function PolylineUpdater() {}
    var _proto = PolylineUpdater.prototype;
    _proto.update = function update(parsedStyle) {
      var points = parsedStyle.points.points;
      // FIXME: account for miter lineJoin
      var minX = Math.min.apply(Math, points.map(function (point) {
        return point[0];
      }));
      var maxX = Math.max.apply(Math, points.map(function (point) {
        return point[0];
      }));
      var minY = Math.min.apply(Math, points.map(function (point) {
        return point[1];
      }));
      var maxY = Math.max.apply(Math, points.map(function (point) {
        return point[1];
      }));
      var width = maxX - minX;
      var height = maxY - minY;
      return {
        width: width,
        height: height
      };
    };
    return PolylineUpdater;
  }();

  var RectUpdater = /*#__PURE__*/function () {
    function RectUpdater() {}
    var _proto = RectUpdater.prototype;
    _proto.update = function update(parsedStyle, object) {
      var img = parsedStyle.img,
        _parsedStyle$width = parsedStyle.width,
        width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width,
        _parsedStyle$height = parsedStyle.height,
        height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
      var contentWidth = width;
      var contentHeight = height;
      // resize with HTMLImageElement's size
      if (img && !isString(img)) {
        if (!contentWidth) {
          contentWidth = img.width;
          parsedStyle.width = contentWidth;
        }
        if (!contentHeight) {
          contentHeight = img.height;
          parsedStyle.height = contentHeight;
        }
      }
      return {
        width: contentWidth,
        height: contentHeight
      };
    };
    return RectUpdater;
  }();

  var TextUpdater = /*#__PURE__*/function () {
    function TextUpdater(globalRuntime) {
      this.globalRuntime = void 0;
      this.globalRuntime = globalRuntime;
    }
    var _proto = TextUpdater.prototype;
    _proto.isReadyToMeasure = function isReadyToMeasure(parsedStyle, object) {
      var text = parsedStyle.text,
        textAlign = parsedStyle.textAlign,
        textBaseline = parsedStyle.textBaseline,
        fontSize = parsedStyle.fontSize,
        fontStyle = parsedStyle.fontStyle,
        fontWeight = parsedStyle.fontWeight,
        fontVariant = parsedStyle.fontVariant,
        lineWidth = parsedStyle.lineWidth;
      return text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !isNil(lineWidth);
    };
    _proto.update = function update(parsedStyle, object) {
      var _object$ownerDocument, _object$ownerDocument2;
      var text = parsedStyle.text,
        textAlign = parsedStyle.textAlign,
        lineWidth = parsedStyle.lineWidth,
        textBaseline = parsedStyle.textBaseline,
        dx = parsedStyle.dx,
        dy = parsedStyle.dy;
      var _ref = (object === null || object === void 0 ? void 0 : (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 ? void 0 : (_object$ownerDocument2 = _object$ownerDocument.defaultView) === null || _object$ownerDocument2 === void 0 ? void 0 : _object$ownerDocument2.getConfig()) || {},
        offscreenCanvas = _ref.offscreenCanvas;
      if (!this.isReadyToMeasure(parsedStyle, object)) {
        parsedStyle.metrics = {
          font: '',
          width: 0,
          height: 0,
          lines: [],
          lineWidths: [],
          lineHeight: 0,
          maxLineWidth: 0,
          fontProperties: {
            ascent: 0,
            descent: 0,
            fontSize: 0
          },
          lineMetrics: []
        };
        return {
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          offsetX: 0,
          offsetY: 0
        };
      }
      var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
      parsedStyle.metrics = metrics;
      var width = metrics.width,
        height = metrics.height,
        lineHeight = metrics.lineHeight,
        fontProperties = metrics.fontProperties;
      // anchor is left-top by default
      var halfExtents = [width / 2, height / 2, 0];
      // default 'left'
      var anchor = [0, 1];
      var lineXOffset = 0;
      if (textAlign === 'center' || textAlign === 'middle') {
        lineXOffset = lineWidth / 2;
        anchor = [0.5, 1];
      } else if (textAlign === 'right' || textAlign === 'end') {
        lineXOffset = lineWidth;
        anchor = [1, 1];
      }
      var lineYOffset = 0;
      if (textBaseline === 'middle') {
        // eslint-disable-next-line prefer-destructuring
        lineYOffset = halfExtents[1];
      } else if (textBaseline === 'top' || textBaseline === 'hanging') {
        lineYOffset = halfExtents[1] * 2;
      } else if (textBaseline === 'alphabetic') {
        // prevent calling getImageData for ascent metrics
        lineYOffset = runtime.enableCSSParsing ? lineHeight - fontProperties.ascent : 0;
      } else if (textBaseline === 'bottom' || textBaseline === 'ideographic') {
        lineYOffset = 0;
      }
      // TODO: ideographic & bottom
      if (dx) {
        lineXOffset += dx;
      }
      if (dy) {
        lineYOffset += dy;
      }
      // update anchor
      parsedStyle.anchor = [anchor[0], anchor[1], 0];
      return {
        width: halfExtents[0] * 2,
        height: halfExtents[1] * 2,
        offsetX: lineXOffset,
        offsetY: lineYOffset
      };
    };
    return TextUpdater;
  }();

  var PROPAGATION_LIMIT = 2048;
  var EventService = /*#__PURE__*/function () {
    function EventService(globalRuntime, context) {
      var _this = this;
      this.globalRuntime = void 0;
      this.context = void 0;
      this.rootTarget = void 0;
      this.emitter = new eventemitter3();
      this.cursor = 'default';
      this.mappingTable = {};
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = new Map();
      this.pickHandler = void 0;
      this.tmpMatrix = create$1();
      this.tmpVec3 = create$2();
      this.onPointerDown = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var e = _this.createPointerEvent(from);
        _this.dispatchEvent(e, 'pointerdown');
        if (e.pointerType === 'touch') {
          _this.dispatchEvent(e, 'touchstart');
        } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
          var isRightButton = e.button === 2;
          _this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
        }
        var trackingData = _this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e.composedPath();
        _this.freeEvent(e);
      };
      this.onPointerUp = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var now = performance.now();
        var e = _this.createPointerEvent(from);
        _this.dispatchEvent(e, 'pointerup');
        if (e.pointerType === 'touch') {
          _this.dispatchEvent(e, 'touchend');
        } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
          var isRightButton = e.button === 2;
          _this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
        }
        var trackingData = _this.trackingData(from.pointerId);
        var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var clickTarget = pressTarget;
        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain
        // the pointerup location.
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          var currentTarget = pressTarget;
          while (currentTarget && !e.composedPath().includes(currentTarget)) {
            e.currentTarget = currentTarget;
            _this.notifyTarget(e, 'pointerupoutside');
            if (e.pointerType === 'touch') {
              _this.notifyTarget(e, 'touchendoutside');
            } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
              var _isRightButton = e.button === 2;
              _this.notifyTarget(e, _isRightButton ? 'rightupoutside' : 'mouseupoutside');
            }
            if (Node$1.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
          // currentTarget is the most specific ancestor holding both the pointerdown and pointerup
          // targets. That is - it's our click target!
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          var _e$detail;
          var clickEvent = _this.clonePointerEvent(e, 'click');
          clickEvent.target = clickTarget;
          clickEvent.path = [];
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now
            };
          }
          var clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now;
          clickEvent.detail = clickHistory.clickCount;
          // @see https://github.com/antvis/G/issues/1091
          if (!((_e$detail = e.detail) === null || _e$detail === void 0 ? void 0 : _e$detail.preventClick)) {
            if (!_this.context.config.useNativeClickEvent && (clickEvent.pointerType === 'mouse' || clickEvent.pointerType === 'touch')) {
              _this.dispatchEvent(clickEvent, 'click');
            }
            _this.dispatchEvent(clickEvent, 'pointertap');
          }
          _this.freeEvent(clickEvent);
        }
        _this.freeEvent(e);
      };
      this.onPointerMove = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var e = _this.createPointerEvent(from);
        var isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
        var trackingData = _this.trackingData(from.pointerId);
        var outTarget = _this.findMountedTarget(trackingData.overTargets);
        // First pointerout/pointerleave
        if (trackingData.overTargets && outTarget !== e.target) {
          // pointerout always occurs on the overTarget when the pointer hovers over another element.
          var outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
          var outEvent = _this.createPointerEvent(from, outType, outTarget || undefined);
          _this.dispatchEvent(outEvent, 'pointerout');
          if (isMouse) _this.dispatchEvent(outEvent, 'mouseout');
          // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event
          // is dispatched to all ancestors that no longer capture the pointer.
          if (!e.composedPath().includes(outTarget)) {
            var leaveEvent = _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              _this.notifyTarget(leaveEvent);
              if (isMouse) {
                _this.notifyTarget(leaveEvent, 'mouseleave');
              }
              if (Node$1.isNode(leaveEvent.target)) {
                leaveEvent.target = leaveEvent.target.parentNode;
              }
            }
            _this.freeEvent(leaveEvent);
          }
          _this.freeEvent(outEvent);
        }
        // Then pointerover
        if (outTarget !== e.target) {
          // pointerover always occurs on the new overTarget
          var overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
          var overEvent = _this.clonePointerEvent(e, overType); // clone faster
          _this.dispatchEvent(overEvent, 'pointerover');
          if (isMouse) _this.dispatchEvent(overEvent, 'mouseover');
          // Probe whether the newly hovered Node is an ancestor of the original overTarget.
          var overTargetAncestor = outTarget && Node$1.isNode(outTarget) && outTarget.parentNode;
          while (overTargetAncestor && overTargetAncestor !== (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
            if (overTargetAncestor === e.target) break;
            overTargetAncestor = overTargetAncestor.parentNode;
          }
          // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered
          // event.
          var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode);
          if (didPointerEnter) {
            var enterEvent = _this.clonePointerEvent(e, 'pointerenter');
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
              enterEvent.currentTarget = enterEvent.target;
              _this.notifyTarget(enterEvent);
              if (isMouse) _this.notifyTarget(enterEvent, 'mouseenter');
              if (Node$1.isNode(enterEvent.target)) {
                enterEvent.target = enterEvent.target.parentNode;
              }
            }
            _this.freeEvent(enterEvent);
          }
          _this.freeEvent(overEvent);
        }
        // Then pointermove
        _this.dispatchEvent(e, 'pointermove');
        if (e.pointerType === 'touch') _this.dispatchEvent(e, 'touchmove');
        if (isMouse) {
          _this.dispatchEvent(e, 'mousemove');
          _this.cursor = _this.getCursor(e.target);
        }
        trackingData.overTargets = e.composedPath();
        _this.freeEvent(e);
      };
      this.onPointerOut = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var trackingData = _this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          var isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';
          var outTarget = _this.findMountedTarget(trackingData.overTargets);
          // pointerout first
          var outEvent = _this.createPointerEvent(from, 'pointerout', outTarget || undefined);
          _this.dispatchEvent(outEvent);
          if (isMouse) _this.dispatchEvent(outEvent, 'mouseout');
          // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to
          // get an upstream pointerout event (upstream events do not know rootTarget has descendants).
          var leaveEvent = _this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this.notifyTarget(leaveEvent);
            if (isMouse) {
              _this.notifyTarget(leaveEvent, 'mouseleave');
            }
            if (Node$1.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          trackingData.overTargets = null;
          _this.freeEvent(outEvent);
          _this.freeEvent(leaveEvent);
        }
        _this.cursor = null;
      };
      this.onPointerOver = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var trackingData = _this.trackingData(from.pointerId);
        var e = _this.createPointerEvent(from);
        var isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';
        _this.dispatchEvent(e, 'pointerover');
        if (isMouse) _this.dispatchEvent(e, 'mouseover');
        if (e.pointerType === 'mouse') _this.cursor = _this.getCursor(e.target);
        // pointerenter events must be fired since the pointer entered from upstream.
        var enterEvent = _this.clonePointerEvent(e, 'pointerenter');
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== (Node$1.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
          enterEvent.currentTarget = enterEvent.target;
          _this.notifyTarget(enterEvent);
          if (isMouse) {
            // mouseenter should not bubble
            // @see https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event#usage_notes
            _this.notifyTarget(enterEvent, 'mouseenter');
          }
          if (Node$1.isNode(enterEvent.target)) {
            enterEvent.target = enterEvent.target.parentNode;
          }
        }
        trackingData.overTargets = e.composedPath();
        _this.freeEvent(e);
        _this.freeEvent(enterEvent);
      };
      this.onPointerUpOutside = function (from) {
        // if (!(from instanceof FederatedPointerEvent)) {
        //   return;
        // }
        var trackingData = _this.trackingData(from.pointerId);
        var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var e = _this.createPointerEvent(from);
        if (pressTarget) {
          var currentTarget = pressTarget;
          while (currentTarget) {
            e.currentTarget = currentTarget;
            _this.notifyTarget(e, 'pointerupoutside');
            if (e.pointerType === 'touch') ; else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
              _this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
            }
            if (Node$1.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        _this.freeEvent(e);
      };
      this.onWheel = function (from) {
        // if (!(from instanceof FederatedWheelEvent)) {
        //   return;
        // }
        var wheelEvent = _this.createWheelEvent(from);
        _this.dispatchEvent(wheelEvent);
        _this.freeEvent(wheelEvent);
      };
      this.onClick = function (from) {
        if (_this.context.config.useNativeClickEvent) {
          var e = _this.createPointerEvent(from);
          _this.dispatchEvent(e);
          _this.freeEvent(e);
        }
      };
      this.onPointerCancel = function (from) {
        var e = _this.createPointerEvent(from);
        _this.dispatchEvent(e);
        _this.freeEvent(e);
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    var _proto = EventService.prototype;
    _proto.init = function init() {
      this.rootTarget = this.context.renderingContext.root.parentNode; // document
      this.addEventMapping('pointerdown', this.onPointerDown);
      this.addEventMapping('pointerup', this.onPointerUp);
      this.addEventMapping('pointermove', this.onPointerMove);
      this.addEventMapping('pointerout', this.onPointerOut);
      this.addEventMapping('pointerleave', this.onPointerOut);
      this.addEventMapping('pointercancel', this.onPointerCancel);
      this.addEventMapping('pointerover', this.onPointerOver);
      this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
      this.addEventMapping('wheel', this.onWheel);
      this.addEventMapping('click', this.onClick);
    };
    _proto.destroy = function destroy() {
      this.emitter.removeAllListeners();
      this.mappingTable = {};
      this.mappingState = {};
      this.eventPool.clear();
    };
    _proto.client2Viewport = function client2Viewport(client) {
      var bbox = this.context.contextService.getBoundingClientRect();
      return new Point(client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
    };
    _proto.viewport2Client = function viewport2Client(canvas) {
      var bbox = this.context.contextService.getBoundingClientRect();
      return new Point(canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0));
    };
    _proto.viewport2Canvas = function viewport2Canvas(_ref) {
      var x = _ref.x,
        y = _ref.y;
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      var _this$context$config = this.context.config,
        width = _this$context$config.width,
        height = _this$context$config.height;
      var projectionMatrixInverse = camera.getPerspectiveInverse();
      var worldMatrix = camera.getWorldTransform();
      var vpMatrix = multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
      var viewport = set$1(this.tmpVec3, x / width * 2 - 1, (1 - y / height) * 2 - 1, 0);
      transformMat4(viewport, viewport, vpMatrix);
      return new Point(viewport[0], viewport[1]);
    };
    _proto.canvas2Viewport = function canvas2Viewport(canvasP) {
      var canvas = this.rootTarget.defaultView;
      var camera = canvas.getCamera();
      // World -> Clip
      var projectionMatrix = camera.getPerspective();
      var viewMatrix = camera.getViewTransform();
      var vpMatrix = multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
      var clip = set$1(this.tmpVec3, canvasP.x, canvasP.y, 0);
      transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
      // Clip -> NDC -> Viewport, flip Y
      var _this$context$config2 = this.context.config,
        width = _this$context$config2.width,
        height = _this$context$config2.height;
      return new Point((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
    };
    _proto.setPickHandler = function setPickHandler(pickHandler) {
      this.pickHandler = pickHandler;
    };
    _proto.addEventMapping = function addEventMapping(type, fn) {
      if (!this.mappingTable[type]) {
        this.mappingTable[type] = [];
      }
      this.mappingTable[type].push({
        fn: fn,
        priority: 0
      });
      this.mappingTable[type].sort(function (a, b) {
        return a.priority - b.priority;
      });
    };
    _proto.mapEvent = function mapEvent(e) {
      if (!this.rootTarget) {
        return;
      }
      var mappers = this.mappingTable[e.type];
      if (mappers) {
        for (var i = 0, j = mappers.length; i < j; i++) {
          mappers[i].fn(e);
        }
      } else {
        console.warn("[EventService]: Event mapping not defined for " + e.type);
      }
    };
    _proto.dispatchEvent = function dispatchEvent(e, type, skipPropagate) {
      // Canvas should skip
      if (!skipPropagate) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
      } else {
        // target phase
        e.eventPhase = e.AT_TARGET;
        var canvas = this.rootTarget.defaultView || null;
        e.currentTarget = canvas;
        this.notifyListeners(e, type);
      }
      this.emitter.emit(type || e.type, e);
    };
    _proto.propagate = function propagate(e, type) {
      if (!e.target) {
        return;
      }
      // [target, parent, root, Canvas]
      var composedPath = e.composedPath();
      // event flow: capture -> target -> bubbling
      // capture phase
      e.eventPhase = e.CAPTURING_PHASE;
      for (var i = composedPath.length - 1; i >= 1; i--) {
        e.currentTarget = composedPath[i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      }
      // target phase
      e.eventPhase = e.AT_TARGET;
      e.currentTarget = e.target;
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      // find current target in composed path
      var index = composedPath.indexOf(e.currentTarget);
      // bubbling phase
      e.eventPhase = e.BUBBLING_PHASE;
      for (var _i = index + 1; _i < composedPath.length; _i++) {
        e.currentTarget = composedPath[_i];
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) return;
      }
    };
    _proto.propagationPath = function propagationPath(target) {
      var propagationPath = [target];
      var canvas = this.rootTarget.defaultView || null;
      if (canvas && canvas === target) {
        propagationPath.unshift(canvas.document);
        return propagationPath;
      }
      for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
        // if (Node.isNode(target) && !target.parentNode) {
        //   throw new Error('Cannot find propagation path to disconnected target');
        // }
        if (Node$1.isNode(target) && target.parentNode) {
          // [target, parent, parent, root]
          propagationPath.push(target.parentNode);
          target = target.parentNode;
        }
      }
      if (canvas) {
        // @ts-ignore
        propagationPath.push(canvas);
      }
      return propagationPath;
    };
    _proto.hitTest = function hitTest(position) {
      var viewportX = position.viewportX,
        viewportY = position.viewportY;
      var _this$context$config3 = this.context.config,
        width = _this$context$config3.width,
        height = _this$context$config3.height;
      // outside canvas
      if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
        return null;
      }
      return this.pickHandler(position) || this.rootTarget ||
      // return Document
      null;
    }
    /**
     * whether the native event trigger came from Canvas,
     * should account for HTML shape
     */;
    _proto.isNativeEventFromCanvas = function isNativeEventFromCanvas(event) {
      var _event$nativeEvent;
      var $el = this.context.contextService.getDomElement();
      var target = (_event$nativeEvent = event.nativeEvent) === null || _event$nativeEvent === void 0 ? void 0 : _event$nativeEvent.target;
      if (target) {
        // from <canvas>
        if (target === $el) {
          return true;
        }
        // from <svg>
        if ($el && $el.contains) {
          return $el.contains(target);
        }
      }
      if (event.nativeEvent.composedPath) {
        return event.nativeEvent.composedPath().indexOf($el) > -1;
      }
      // account for Touch
      return false;
    }
    /**
     * Find HTML from composed path in native UI event.
     */;
    _proto.getExistedHTML = function getExistedHTML(event) {
      if (event.nativeEvent.composedPath) {
        for (var _iterator = _createForOfIteratorHelperLoose(event.nativeEvent.composedPath()), _step; !(_step = _iterator()).done;) {
          var eventTarget = _step.value;
          var existed = runtime.nativeHTMLMap.get(eventTarget);
          if (existed) {
            return existed;
          }
        }
      }
      return null;
    };
    _proto.pickTarget = function pickTarget(event) {
      return this.hitTest({
        clientX: event.clientX,
        clientY: event.clientY,
        viewportX: event.viewportX,
        viewportY: event.viewportY,
        x: event.canvasX,
        y: event.canvasY
      });
    };
    _proto.createPointerEvent = function createPointerEvent(from, type, target) {
      var event = this.allocateEvent(FederatedPointerEvent);
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas(event) && this.pickTarget(event);
      if (typeof type === 'string') {
        event.type = type;
      }
      return event;
    };
    _proto.createWheelEvent = function createWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from;
      var existedHTML = this.getExistedHTML(event);
      event.target = existedHTML || this.isNativeEventFromCanvas(event) && this.pickTarget(event);
      return event;
    };
    _proto.trackingData = function trackingData(id) {
      if (!this.mappingState.trackingData[id]) {
        this.mappingState.trackingData[id] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        };
      }
      return this.mappingState.trackingData[id];
    };
    _proto.cloneWheelEvent = function cloneWheelEvent(from) {
      var event = this.allocateEvent(FederatedWheelEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyWheelData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = from.type;
      return event;
    };
    _proto.clonePointerEvent = function clonePointerEvent(from, type) {
      var event = this.allocateEvent(FederatedPointerEvent);
      event.nativeEvent = from.nativeEvent;
      event.originalEvent = from.originalEvent;
      this.copyPointerData(from, event);
      this.copyMouseData(from, event);
      this.copyData(from, event);
      event.target = from.target;
      event.path = from.composedPath().slice();
      event.type = type !== null && type !== void 0 ? type : event.type;
      return event;
    };
    _proto.copyPointerData = function copyPointerData(from, to) {
      // if (
      //   !(
      //     from instanceof FederatedPointerEvent &&
      //     to instanceof FederatedPointerEvent
      //   )
      // )
      //   return;
      to.pointerId = from.pointerId;
      to.width = from.width;
      to.height = from.height;
      to.isPrimary = from.isPrimary;
      to.pointerType = from.pointerType;
      to.pressure = from.pressure;
      to.tangentialPressure = from.tangentialPressure;
      to.tiltX = from.tiltX;
      to.tiltY = from.tiltY;
      to.twist = from.twist;
    };
    _proto.copyMouseData = function copyMouseData(from, to) {
      // if (
      //   !(
      //     from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent
      //   )
      // )
      //   return;
      to.altKey = from.altKey;
      to.button = from.button;
      to.buttons = from.buttons;
      to.ctrlKey = from.ctrlKey;
      to.metaKey = from.metaKey;
      to.shiftKey = from.shiftKey;
      to.client.copyFrom(from.client);
      to.movement.copyFrom(from.movement);
      to.canvas.copyFrom(from.canvas);
      to.screen.copyFrom(from.screen);
      to.global.copyFrom(from.global);
      to.offset.copyFrom(from.offset);
    };
    _proto.copyWheelData = function copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    };
    _proto.copyData = function copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.timeStamp = performance.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.page.copyFrom(from.page);
      to.viewport.copyFrom(from.viewport);
    };
    _proto.allocateEvent = function allocateEvent(constructor) {
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      // @ts-ignore
      var event = this.eventPool.get(constructor).pop() || new constructor(this);
      event.eventPhase = event.NONE;
      event.currentTarget = null;
      event.path = [];
      event.target = null;
      return event;
    };
    _proto.freeEvent = function freeEvent(event) {
      if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');
      var constructor = event.constructor;
      if (!this.eventPool.has(constructor)) {
        this.eventPool.set(constructor, []);
      }
      // @ts-ignore
      this.eventPool.get(constructor).push(event);
    };
    _proto.notifyTarget = function notifyTarget(e, type) {
      var _type;
      type = (_type = type) !== null && _type !== void 0 ? _type : e.type;
      var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? type + "capture" : type;
      this.notifyListeners(e, key);
      if (e.eventPhase === e.AT_TARGET) {
        this.notifyListeners(e, type);
      }
    };
    _proto.notifyListeners = function notifyListeners(e, type) {
      // hack EventEmitter, stops if the `propagationImmediatelyStopped` flag is set
      // @ts-ignore
      var emitter = e.currentTarget.emitter;
      // @ts-ignore
      var listeners = emitter._events[type];
      if (!listeners) return;
      if ('fn' in listeners) {
        if (listeners.once) {
          emitter.removeListener(type, listeners.fn, undefined, true);
        }
        listeners.fn.call(e.currentTarget || listeners.context, e);
        // listeners.fn.call(listeners.context, e);
      } else {
        for (var i = 0; i < listeners.length && !e.propagationImmediatelyStopped; i++) {
          if (listeners[i].once) {
            emitter.removeListener(type, listeners[i].fn, undefined, true);
          }
          listeners[i].fn.call(e.currentTarget || listeners[i].context, e);
          // listeners[i].fn.call(listeners[i].context, e);
        }
      }
    }
    /**
     * some detached nodes may exist in propagation path, need to skip them
     */;
    _proto.findMountedTarget = function findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      var currentTarget = propagationPath[propagationPath.length - 1];
      for (var i = propagationPath.length - 2; i >= 0; i--) {
        var target = propagationPath[i];
        if (target === this.rootTarget || Node$1.isNode(target) && target.parentNode === currentTarget) {
          currentTarget = propagationPath[i];
        } else {
          break;
        }
      }
      return currentTarget;
    };
    _proto.getCursor = function getCursor(target) {
      var tmp = target;
      while (tmp) {
        var cursor = Element.isElement(tmp) && tmp.getAttribute('cursor');
        if (cursor) {
          return cursor;
        }
        tmp = Node$1.isNode(tmp) && tmp.parentNode;
      }
    };
    return EventService;
  }();

  /**
   * used in following scenes:
   * - g `ctx.measureText`
   * - g-plugin-canvas-picker `ctx.isPointInPath`
   * - g-plugin-device-renderer `ctx.createLinearGradient` and generate texture
   *
   * @see https://blog.scottlogic.com/2020/03/19/offscreen-canvas.html
   */
  var OffscreenCanvasCreator = /*#__PURE__*/function () {
    function OffscreenCanvasCreator() {
      this.canvas = void 0;
      this.context = void 0;
    }
    var _proto = OffscreenCanvasCreator.prototype;
    _proto.getOrCreateCanvas = function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
      if (this.canvas) {
        return this.canvas;
      }
      // user-defined offscreen canvas
      if (offscreenCanvas) {
        this.canvas = offscreenCanvas;
        this.context = this.canvas.getContext('2d', contextAttributes);
      } else {
        try {
          // OffscreenCanvas2D measureText can be up to 40% faster.
          this.canvas = new window.OffscreenCanvas(0, 0);
          this.context = this.canvas.getContext('2d', contextAttributes);
          if (!this.context || !this.context.measureText) {
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
          }
        } catch (ex) {
          this.canvas = document.createElement('canvas');
          this.context = this.canvas.getContext('2d', contextAttributes);
        }
      }
      this.canvas.width = 10;
      this.canvas.height = 10;
      return this.canvas;
    };
    _proto.getOrCreateContext = function getOrCreateContext(offscreenCanvas, contextAttributes) {
      if (this.context) {
        return this.context;
      }
      this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
      return this.context;
    };
    return OffscreenCanvasCreator;
  }();

  /**
   * why we need re-render
   */
  var RenderReason;
  (function (RenderReason) {
    RenderReason[RenderReason["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
    RenderReason[RenderReason["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
    RenderReason[RenderReason["NONE"] = 2] = "NONE";
  })(RenderReason || (RenderReason = {}));

  /**
   * Use frame renderer implemented by `g-canvas/svg/webgl`, in every frame we do followings:
   * * update & merge dirty rectangles
   * * begin frame
   * * filter by visible
   * * sort by z-index in scene graph
   * * culling with strategies registered in `g-canvas/webgl`
   * * end frame
   */
  var RenderingService = /*#__PURE__*/function () {
    function RenderingService(globalRuntime, context) {
      this.globalRuntime = void 0;
      this.context = void 0;
      this.inited = false;
      this.stats = {
        /**
         * total display objects in scenegraph
         */
        total: 0,
        /**
         * number of display objects need to render in current frame
         */
        rendered: 0
      };
      this.zIndexCounter = 0;
      /**
       * avoid re-creating too many custom events
       */
      this.renderOrderChangedEvent = new CustomEvent(ElementEvent.RENDER_ORDER_CHANGED);
      this.hooks = {
        /**
         * called before any frame rendered
         */
        init: new AsyncParallelHook(),
        /**
         * only dirty object which has sth changed will be rendered
         */
        dirtycheck: new SyncWaterfallHook(['object']),
        /**
         * do culling
         */
        cull: new SyncWaterfallHook(['object', 'camera']),
        /**
         * called at beginning of each frame, won't get called if nothing to re-render
         */
        beginFrame: new SyncHook([]),
        /**
         * called before every dirty object get rendered
         */
        beforeRender: new SyncHook(['objectToRender']),
        /**
         * called when every dirty object rendering even it's culled
         */
        render: new SyncHook(['objectToRender']),
        /**
         * called after every dirty object get rendered
         */
        afterRender: new SyncHook(['objectToRender']),
        endFrame: new SyncHook([]),
        destroy: new SyncHook([]),
        /**
         * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
         */
        pick: new AsyncSeriesWaterfallHook(['result']),
        /**
         * Unsafe but sync version of pick.
         */
        pickSync: new SyncWaterfallHook(['result']),
        /**
         * used in event system
         */
        pointerDown: new SyncHook(['event']),
        pointerUp: new SyncHook(['event']),
        pointerMove: new SyncHook(['event']),
        pointerOut: new SyncHook(['event']),
        pointerOver: new SyncHook(['event']),
        pointerWheel: new SyncHook(['event']),
        pointerCancel: new SyncHook(['event']),
        click: new SyncHook(['event'])
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    var _proto = RenderingService.prototype;
    _proto.init = /*#__PURE__*/function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var context;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              context = _extends({}, this.globalRuntime, this.context); // register rendering plugins
              this.context.renderingPlugins.forEach(function (plugin) {
                plugin.apply(context, runtime);
              });
              // await this.hooks.init.callPromise();
              _context.next = 4;
              return this.hooks.init.promise();
            case 4:
              this.inited = true;
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }();
    _proto.getStats = function getStats() {
      return this.stats;
    }
    /**
     * Meet the following conditions:
     * * disable DirtyRectangleRendering
     * * camera changed
     */;
    _proto.disableDirtyRectangleRendering = function disableDirtyRectangleRendering() {
      var renderer = this.context.config.renderer;
      var _renderer$getConfig = renderer.getConfig(),
        enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
      return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
    };
    _proto.render = function render(canvasConfig, rerenderCallback) {
      var _this = this;
      this.stats.total = 0;
      this.stats.rendered = 0;
      this.zIndexCounter = 0;
      var renderingContext = this.context.renderingContext;
      this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
      this.globalRuntime.sceneGraphService.triggerPendingEvents();
      if (renderingContext.renderReasons.size && this.inited) {
        this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
        this.hooks.beginFrame.call();
        renderingContext.renderListCurrentFrame.forEach(function (object) {
          _this.hooks.beforeRender.call(object);
          _this.hooks.render.call(object);
          _this.hooks.afterRender.call(object);
        });
        this.hooks.endFrame.call();
        renderingContext.renderListCurrentFrame = [];
        renderingContext.renderReasons.clear();
        rerenderCallback();
      }
      // console.log('stats', this.stats);
    };
    _proto.renderDisplayObject = function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
      var _this2 = this;
      var _canvasConfig$rendere = canvasConfig.renderer.getConfig(),
        enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck,
        enableCulling = _canvasConfig$rendere.enableCulling;
      // recalc style values
      if (this.globalRuntime.enableCSSParsing) {
        this.globalRuntime.styleValueRegistry.recalc(displayObject);
      }
      // TODO: relayout
      // dirtycheck first
      var objectChanged = enableDirtyCheck ? this.hooks.dirtycheck.call(displayObject) : displayObject;
      if (objectChanged) {
        var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
        if (objectToRender) {
          this.stats.rendered++;
          renderingContext.renderListCurrentFrame.push(objectToRender);
        }
      }
      displayObject.renderable.dirty = false;
      displayObject.sortable.renderOrder = this.zIndexCounter++;
      this.stats.total++;
      // sort is very expensive, use cached result if posible
      var sortable = displayObject.sortable;
      var renderOrderChanged = false;
      if (sortable.dirty) {
        sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
        renderOrderChanged = true;
        sortable.dirty = false;
      }
      // recursive rendering its children
      (sortable.sorted || displayObject.childNodes).forEach(function (child) {
        _this2.renderDisplayObject(child, canvasConfig, renderingContext);
      });
      if (renderOrderChanged) {
        displayObject.forEach(function (child) {
          _this2.renderOrderChangedEvent.target = child;
          _this2.renderOrderChangedEvent.detail = {
            renderOrder: child.sortable.renderOrder
          };
          child.ownerDocument.defaultView.dispatchEvent(_this2.renderOrderChangedEvent, true);
        });
      }
    };
    _proto.destroy = function destroy() {
      this.inited = false;
      this.hooks.destroy.call();
      this.globalRuntime.sceneGraphService.clearPendingEvents();
    };
    _proto.dirtify = function dirtify() {
      // need re-render
      this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
    };
    return RenderingService;
  }();

  var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
  /**
   * support the following DOM API:
   * * getElementById
   * * getElementsByClassName
   * * getElementsByName
   * * getElementsByTag
   * * querySelector
   * * querySelectorAll
   */
  var DefaultSceneGraphSelector = /*#__PURE__*/function () {
    function DefaultSceneGraphSelector() {}
    var _proto = DefaultSceneGraphSelector.prototype;
    _proto.selectOne = function selectOne(query, root) {
      var _this = this;
      if (query.startsWith('.')) {
        return root.find(function (node) {
          // return !node.shadow && node.id === query.substring(1);
          return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
        });
      } else if (query.startsWith('#')) {
        // getElementById('id')
        return root.find(function (node) {
          // return !node.shadow && node.id === query.substring(1);
          return node.id === _this.getIdOrClassname(query);
        });
      } else if (query.startsWith('[')) {
        var _this$getAttribute = this.getAttribute(query),
          name = _this$getAttribute.name,
          value = _this$getAttribute.value;
        if (name) {
          // getElementByName();
          return root.find(function (node) {
            return root !== node && (name === 'name' ? node.name === value : _this.attributeToString(node, name) === value);
          });
        } else {
          return null;
        }
      } else {
        // getElementsByTag('circle');
        return root.find(function (node) {
          return root !== node && node.nodeName === query;
        });
      }
    };
    _proto.selectAll = function selectAll(query, root) {
      var _this2 = this;
      // only support `[name="${name}"]` `.className` `#id`
      if (query.startsWith('.')) {
        // getElementsByClassName('className');
        // should not include itself
        return root.findAll(function (node) {
          return root !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
        });
      } else if (query.startsWith('#')) {
        return root.findAll(function (node) {
          return root !== node && node.id === _this2.getIdOrClassname(query);
        });
      } else if (query.startsWith('[')) {
        var _this$getAttribute2 = this.getAttribute(query),
          name = _this$getAttribute2.name,
          value = _this$getAttribute2.value;
        if (name) {
          // getElementsByName();
          return root.findAll(function (node) {
            return root !== node && (name === 'name' ? node.name === value : _this2.attributeToString(node, name) === value);
          });
        } else {
          return [];
        }
      } else {
        // getElementsByTag('circle');
        return root.findAll(function (node) {
          return root !== node && node.nodeName === query;
        });
      }
    };
    _proto.is = function is(query, node) {
      // a simple `matches` implementation
      if (query.startsWith('.')) {
        return node.className === this.getIdOrClassname(query);
      } else if (query.startsWith('#')) {
        return node.id === this.getIdOrClassname(query);
      } else if (query.startsWith('[')) {
        var _this$getAttribute3 = this.getAttribute(query),
          name = _this$getAttribute3.name,
          value = _this$getAttribute3.value;
        return name === 'name' ? node.name === value : this.attributeToString(node, name) === value;
      } else {
        return node.nodeName === query;
      }
    };
    _proto.getIdOrClassname = function getIdOrClassname(query) {
      return query.substring(1);
    };
    _proto.getAttribute = function getAttribute(query) {
      var matches = query.match(ATTRIBUTE_REGEXP);
      var name = '';
      var value = '';
      if (matches && matches.length > 2) {
        name = matches[1].replace(/"/g, '');
        value = matches[2].replace(/"/g, '');
      }
      return {
        name: name,
        value: value
      };
    };
    _proto.attributeToString = function attributeToString(node, name) {
      if (!node.getAttribute) {
        return '';
      }
      var value = node.getAttribute(name);
      if (isNil(value)) {
        return '';
      }
      if (value.toString) {
        return value.toString();
      }
      return '';
    };
    return DefaultSceneGraphSelector;
  }();

  function markRenderableDirty(e) {
    var renderable = e.renderable;
    if (renderable) {
      renderable.renderBoundsDirty = true;
      renderable.boundsDirty = true;
    }
  }
  var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, '', '', '', 0, '', '');
  /**
   * update transform in scene graph
   *
   * @see https://community.khronos.org/t/scene-graphs/50542/7
   */
  var DefaultSceneGraphService = /*#__PURE__*/function () {
    function DefaultSceneGraphService(runtime) {
      var _this = this;
      this.runtime = void 0;
      this.pendingEvents = [];
      this.boundsChangedEvent = new CustomEvent(ElementEvent.BOUNDS_CHANGED);
      /**
       * rotate in world space
       */
      this.rotate = function () {
        var parentInvertRotation = create$4();
        return function (element, degrees, y, z) {
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees === 'number') {
            degrees = fromValues$2(degrees, y, z);
          }
          var transform = element.transformable;
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this.rotateLocal(element, degrees);
          } else {
            var rotation = create$4();
            fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
            var rot = _this.getRotation(element);
            var parentRot = _this.getRotation(element.parentNode);
            copy$3(parentInvertRotation, parentRot);
            invert$1(parentInvertRotation, parentInvertRotation);
            multiply$2(rotation, parentInvertRotation, rotation);
            multiply$2(transform.localRotation, rotation, rot);
            normalize$2(transform.localRotation, transform.localRotation);
            _this.dirtifyLocal(element, transform);
          }
        };
      }();
      /**
       * rotate in local space
       * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
       */
      this.rotateLocal = function () {
        var rotation = create$4();
        return function (element, degrees, y, z) {
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees === 'number') {
            degrees = fromValues$2(degrees, y, z);
          }
          var transform = element.transformable;
          fromEuler(rotation, degrees[0], degrees[1], degrees[2]);
          mul$1(transform.localRotation, transform.localRotation, rotation);
          _this.dirtifyLocal(element, transform);
        };
      }();
      /**
       * set euler angles(degrees) in world space
       */
      this.setEulerAngles = function () {
        var invParentRot = create$4();
        return function (element, degrees, y, z) {
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof degrees === 'number') {
            degrees = fromValues$2(degrees, y, z);
          }
          var transform = element.transformable;
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this.setLocalEulerAngles(element, degrees);
          } else {
            fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
            var parentRotation = _this.getRotation(element.parentNode);
            copy$3(invParentRot, invert$1(create$4(), parentRotation));
            mul$1(transform.localRotation, transform.localRotation, invParentRot);
            _this.dirtifyLocal(element, transform);
          }
        };
      }();
      /**
       * translate in local space
       *
       * @example
       * ```
       * translateLocal(x, y, z)
       * translateLocal(vec3(x, y, z))
       * ```
       */
      this.translateLocal = function () {
        return function (element, translation, y, z) {
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof translation === 'number') {
            translation = fromValues$2(translation, y, z);
          }
          var transform = element.transformable;
          if (equals$1(translation, create$2())) {
            return;
          }
          transformQuat(translation, translation, transform.localRotation);
          add$1(transform.localPosition, transform.localPosition, translation);
          _this.dirtifyLocal(element, transform);
        };
      }();
      /**
       * move to position in world space
       *
       *  g  move/moveTo
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
       */
      this.setPosition = function () {
        var parentInvertMatrix = create$1();
        var tmpPosition = create$2();
        return function (element, position) {
          var transform = element.transformable;
          tmpPosition[0] = position[0];
          tmpPosition[1] = position[1];
          tmpPosition[2] = position[2] || 0;
          if (equals$1(_this.getPosition(element), tmpPosition)) {
            return;
          }
          copy$1(transform.position, tmpPosition);
          if (element.parentNode === null || !element.parentNode.transformable) {
            copy$1(transform.localPosition, tmpPosition);
          } else {
            var parentTransform = element.parentNode.transformable;
            copy(parentInvertMatrix, parentTransform.worldTransform);
            invert(parentInvertMatrix, parentInvertMatrix);
            transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
          }
          _this.dirtifyLocal(element, transform);
        };
      }();
      /**
       * move to position in local space
       */
      this.setLocalPosition = function () {
        var tmpPosition = create$2();
        return function (element, position) {
          var transform = element.transformable;
          tmpPosition[0] = position[0];
          tmpPosition[1] = position[1];
          tmpPosition[2] = position[2] || 0;
          if (equals$1(transform.localPosition, tmpPosition)) {
            return;
          }
          copy$1(transform.localPosition, tmpPosition);
          _this.dirtifyLocal(element, transform);
        };
      }();
      /**
       * translate in world space
       *
       * @example
       * ```
       * translate(x, y, z)
       * translate(vec3(x, y, z))
       * ```
       *
       *  g  translate 2D
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
       */
      this.translate = function () {
        var zeroVec3 = create$2();
        var tmpVec3 = create$2();
        var tr = create$2();
        return function (element, translation, y, z) {
          if (y === void 0) {
            y = 0;
          }
          if (z === void 0) {
            z = 0;
          }
          if (typeof translation === 'number') {
            translation = set$1(tmpVec3, translation, y, z);
          }
          if (equals$1(translation, zeroVec3)) {
            return;
          }
          add$1(tr, _this.getPosition(element), translation);
          _this.setPosition(element, tr);
        };
      }();
      this.setRotation = function () {
        var parentInvertRotation = create$4();
        return function (element, rotation, y, z, w) {
          var transform = element.transformable;
          if (typeof rotation === 'number') {
            rotation = fromValues$4(rotation, y, z, w);
          }
          if (element.parentNode === null || !element.parentNode.transformable) {
            _this.setLocalRotation(element, rotation);
          } else {
            var parentRot = _this.getRotation(element.parentNode);
            copy$3(parentInvertRotation, parentRot);
            invert$1(parentInvertRotation, parentInvertRotation);
            multiply$2(transform.localRotation, parentInvertRotation, rotation);
            normalize$2(transform.localRotation, transform.localRotation);
            _this.dirtifyLocal(element, transform);
          }
        };
      };
      this.displayObjectDependencyMap = new WeakMap();
      this.calcLocalTransform = function () {
        var tmpMat = create$1();
        var tmpPosition = create$2();
        var tmpQuat = fromValues$4(0, 0, 0, 1);
        return function (transform) {
          var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
          if (hasSkew) {
            fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, fromValues$2(1, 1, 1), transform.origin);
            // apply skew2D
            if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
              var tmpMat4 = identity(tmpMat);
              tmpMat4[4] = Math.tan(transform.localSkew[0]);
              tmpMat4[1] = Math.tan(transform.localSkew[1]);
              multiply(transform.localTransform, transform.localTransform, tmpMat4);
            }
            var scaling = fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
            multiply(transform.localTransform, transform.localTransform, scaling);
          } else {
            // @see https://github.com/mattdesl/css-mat4/blob/master/index.js
            fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
          }
        };
      }();
      this.runtime = runtime;
    }
    var _proto = DefaultSceneGraphService.prototype;
    _proto.matches = function matches(query, root) {
      return this.runtime.sceneGraphSelector.is(query, root);
    };
    _proto.querySelector = function querySelector(query, root) {
      return this.runtime.sceneGraphSelector.selectOne(query, root);
    };
    _proto.querySelectorAll = function querySelectorAll(query, root) {
      return this.runtime.sceneGraphSelector.selectAll(query, root);
      // .filter((node) => !node.shadow);
    };
    _proto.attach = function attach(child, parent, index) {
      var _sortable$sorted, _child$style;
      var detached = false;
      if (child.parentNode) {
        detached = child.parentNode !== parent;
        this.detach(child);
      }
      child.parentNode = parent;
      if (!isNil(index)) {
        child.parentNode.childNodes.splice(index, 0, child);
      } else {
        child.parentNode.childNodes.push(child);
      }
      // parent needs re-sort
      var sortable = parent.sortable;
      if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted = sortable.sorted) === null || _sortable$sorted === void 0 ? void 0 : _sortable$sorted.length) || ((_child$style = child.style) === null || _child$style === void 0 ? void 0 : _child$style.zIndex)) {
        // if (sortable) {
        // only child has z-Index
        sortable.dirty = true;
      }
      // this.updateGraphDepth(child);
      var transform = child.transformable;
      if (transform) {
        this.dirtifyWorld(child, transform);
      }
      if (transform.frozen) {
        this.unfreezeParentToRoot(child);
      }
      if (detached) {
        child.dispatchEvent(reparentEvent);
      }
    };
    _proto.detach = function detach(child) {
      if (child.parentNode) {
        var _sortable$sorted2, _child$style2;
        var transform = child.transformable;
        // if (transform) {
        //   const worldTransform = this.getWorldTransform(child, transform);
        //   mat4.getScaling(transform.localScale, worldTransform);
        //   mat4.getTranslation(transform.localPosition, worldTransform);
        //   mat4.getRotation(transform.localRotation, worldTransform);
        //   transform.localDirtyFlag = true;
        // }
        // parent needs re-sort
        var sortable = child.parentNode.sortable;
        // if (sortable) {
        if ((sortable === null || sortable === void 0 ? void 0 : (_sortable$sorted2 = sortable.sorted) === null || _sortable$sorted2 === void 0 ? void 0 : _sortable$sorted2.length) || ((_child$style2 = child.style) === null || _child$style2 === void 0 ? void 0 : _child$style2.zIndex)) {
          sortable.dirty = true;
        }
        var index = child.parentNode.childNodes.indexOf(child);
        if (index > -1) {
          child.parentNode.childNodes.splice(index, 1);
        }
        if (transform) {
          this.dirtifyWorld(child, transform);
        }
        child.parentNode = null;
      }
    };
    _proto.getOrigin = function getOrigin(element) {
      return element.transformable.origin;
    }
    /**
     * same as pivot in Pixi.js
     *
     * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
     */;
    _proto.setOrigin = function setOrigin(element, origin, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (typeof origin === 'number') {
        origin = [origin, y, z];
      }
      var transform = element.transformable;
      if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {
        return;
      }
      var originVec = transform.origin;
      // const delta = vec3.subtract(vec3.create(), origin, originVec);
      // vec3.add(transform.localPosition, transform.localPosition, delta);
      // update origin
      originVec[0] = origin[0];
      originVec[1] = origin[1];
      originVec[2] = origin[2] || 0;
      this.dirtifyLocal(element, transform);
    };
    /**
     * set euler angles(degrees) in local space
     */
    _proto.setLocalEulerAngles = function setLocalEulerAngles(element, degrees, y, z) {
      if (y === void 0) {
        y = 0;
      }
      if (z === void 0) {
        z = 0;
      }
      if (typeof degrees === 'number') {
        degrees = fromValues$2(degrees, y, z);
      }
      var transform = element.transformable;
      fromEuler(transform.localRotation, degrees[0], degrees[1], degrees[2]);
      this.dirtifyLocal(element, transform);
    };
    /**
     * scale in local space
     */
    _proto.scaleLocal = function scaleLocal(element, scaling) {
      var transform = element.transformable;
      multiply$1(transform.localScale, transform.localScale, fromValues$2(scaling[0], scaling[1], scaling[2] || 1));
      this.dirtifyLocal(element, transform);
    };
    _proto.setLocalScale = function setLocalScale(element, scaling) {
      var transform = element.transformable;
      var updatedScaling = fromValues$2(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
      if (equals$1(updatedScaling, transform.localScale)) {
        return;
      }
      copy$1(transform.localScale, updatedScaling);
      this.dirtifyLocal(element, transform);
    };
    _proto.setLocalRotation = function setLocalRotation(element, rotation, y, z, w) {
      if (typeof rotation === 'number') {
        rotation = fromValues$4(rotation, y, z, w);
      }
      var transform = element.transformable;
      copy$3(transform.localRotation, rotation);
      this.dirtifyLocal(element, transform);
    };
    _proto.setLocalSkew = function setLocalSkew(element, skew, y) {
      if (typeof skew === 'number') {
        skew = fromValues$5(skew, y);
      }
      var transform = element.transformable;
      copy$4(transform.localSkew, skew);
      this.dirtifyLocal(element, transform);
    };
    _proto.dirtifyLocal = function dirtifyLocal(element, transform) {
      if (!transform.localDirtyFlag) {
        transform.localDirtyFlag = true;
        if (!transform.dirtyFlag) {
          this.dirtifyWorld(element, transform);
        }
      }
    };
    _proto.dirtifyWorld = function dirtifyWorld(element, transform) {
      if (!transform.dirtyFlag) {
        this.unfreezeParentToRoot(element);
      }
      this.dirtifyWorldInternal(element, transform);
      this.dirtifyToRoot(element, true);
    };
    _proto.triggerPendingEvents = function triggerPendingEvents() {
      var _this2 = this;
      var set = new Set();
      var trigger = function trigger(element, detail) {
        if (element.isConnected && !set.has(element.entity)) {
          _this2.boundsChangedEvent.detail = detail;
          _this2.boundsChangedEvent.target = element;
          if (element.isMutationObserved) {
            element.dispatchEvent(_this2.boundsChangedEvent);
          } else {
            element.ownerDocument.defaultView.dispatchEvent(_this2.boundsChangedEvent, true);
          }
          set.add(element.entity);
        }
      };
      this.pendingEvents.forEach(function (_ref) {
        var element = _ref[0],
          detail = _ref[1];
        if (detail.affectChildren) {
          element.forEach(function (e) {
            trigger(e, detail);
          });
        } else {
          trigger(element, detail);
        }
      });
      this.clearPendingEvents();
      set.clear();
    };
    _proto.clearPendingEvents = function clearPendingEvents() {
      this.pendingEvents = [];
    };
    _proto.dirtifyToRoot = function dirtifyToRoot(element, affectChildren) {
      if (affectChildren === void 0) {
        affectChildren = false;
      }
      var p = element;
      // only need to re-render itself
      if (p.renderable) {
        p.renderable.dirty = true;
      }
      while (p) {
        markRenderableDirty(p);
        p = p.parentNode;
      }
      if (affectChildren) {
        element.forEach(function (e) {
          markRenderableDirty(e);
        });
      }
      // inform dependencies
      this.informDependentDisplayObjects(element);
      // reuse the same custom event
      this.pendingEvents.push([element, {
        affectChildren: affectChildren
      }]);
    };
    _proto.updateDisplayObjectDependency = function updateDisplayObjectDependency(name, oldPath, newPath, object) {
      // clear ref to old clip path
      if (oldPath && oldPath !== newPath) {
        var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
        if (oldDependencyMap && oldDependencyMap[name]) {
          var index = oldDependencyMap[name].indexOf(object);
          oldDependencyMap[name].splice(index, 1);
        }
      }
      if (newPath) {
        var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        if (!newDependencyMap) {
          this.displayObjectDependencyMap.set(newPath, {});
          newDependencyMap = this.displayObjectDependencyMap.get(newPath);
        }
        if (!newDependencyMap[name]) {
          newDependencyMap[name] = [];
        }
        newDependencyMap[name].push(object);
      }
    };
    _proto.informDependentDisplayObjects = function informDependentDisplayObjects(object) {
      var _this3 = this;
      var dependencyMap = this.displayObjectDependencyMap.get(object);
      if (dependencyMap) {
        Object.keys(dependencyMap).forEach(function (name) {
          dependencyMap[name].forEach(function (target) {
            _this3.dirtifyToRoot(target, true);
            target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this3, _this3, name, MutationEvent.MODIFICATION, _this3, _this3));
            if (target.isCustomElement && target.isConnected) {
              if (target.attributeChangedCallback) {
                target.attributeChangedCallback(name, _this3, _this3);
              }
            }
          });
        });
      }
    };
    _proto.getPosition = function getPosition(element) {
      var transform = element.transformable;
      return getTranslation(transform.position, this.getWorldTransform(element, transform));
    };
    _proto.getRotation = function getRotation$1(element) {
      var transform = element.transformable;
      return getRotation(transform.rotation, this.getWorldTransform(element, transform));
    };
    _proto.getScale = function getScale(element) {
      var transform = element.transformable;
      return getScaling(transform.scaling, this.getWorldTransform(element, transform));
    };
    _proto.getWorldTransform = function getWorldTransform(element, transform) {
      if (transform === void 0) {
        transform = element.transformable;
      }
      if (!transform.localDirtyFlag && !transform.dirtyFlag) {
        return transform.worldTransform;
      }
      if (element.parentNode && element.parentNode.transformable) {
        this.getWorldTransform(element.parentNode);
      }
      this.sync(element, transform);
      return transform.worldTransform;
    };
    _proto.getLocalPosition = function getLocalPosition(element) {
      return element.transformable.localPosition;
    };
    _proto.getLocalRotation = function getLocalRotation(element) {
      return element.transformable.localRotation;
    };
    _proto.getLocalScale = function getLocalScale(element) {
      return element.transformable.localScale;
    };
    _proto.getLocalSkew = function getLocalSkew(element) {
      return element.transformable.localSkew;
    };
    _proto.getLocalTransform = function getLocalTransform(element) {
      var transform = element.transformable;
      if (transform.localDirtyFlag) {
        this.calcLocalTransform(transform);
        transform.localDirtyFlag = false;
      }
      return transform.localTransform;
    };
    _proto.setLocalTransform = function setLocalTransform(element, transform) {
      var t = getTranslation(create$2(), transform);
      var r = getRotation(create$4(), transform);
      var s = getScaling(create$2(), transform);
      this.setLocalScale(element, s);
      this.setLocalPosition(element, t);
      this.setLocalRotation(element, r);
    };
    _proto.resetLocalTransform = function resetLocalTransform(element) {
      this.setLocalScale(element, [1, 1, 1]);
      this.setLocalPosition(element, [0, 0, 0]);
      this.setLocalEulerAngles(element, [0, 0, 0]);
      this.setLocalSkew(element, [0, 0]);
    };
    _proto.getTransformedGeometryBounds = function getTransformedGeometryBounds(element, render, existedAABB) {
      if (render === void 0) {
        render = false;
      }
      var bounds = this.getGeometryBounds(element, render);
      if (!AABB.isEmpty(bounds)) {
        var aabb = existedAABB || new AABB();
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        return aabb;
      } else {
        return null;
      }
    }
    /**
     * won't account for children
     */;
    _proto.getGeometryBounds = function getGeometryBounds(element, render) {
      if (render === void 0) {
        render = false;
      }
      var geometry = element.geometry;
      var bounds = render ? geometry.renderBounds : geometry.contentBounds || null;
      // return (bounds && new AABB(bounds.center, bounds.halfExtents)) || new AABB();
      return bounds || new AABB();
    }
    /**
     * account for children in world space
     */;
    _proto.getBounds = function getBounds(element, render) {
      var _this4 = this;
      if (render === void 0) {
        render = false;
      }
      var renderable = element.renderable;
      if (!renderable.boundsDirty && !render && renderable.bounds) {
        return renderable.bounds;
      }
      if (!renderable.renderBoundsDirty && render && renderable.renderBounds) {
        return renderable.renderBounds;
      }
      // reuse existed if possible
      var existedAABB = render ? renderable.renderBounds : renderable.bounds;
      // reset with geometry's aabb
      var aabb = this.getTransformedGeometryBounds(element, render, existedAABB);
      // merge children's aabbs
      var children = element.childNodes;
      children.forEach(function (child) {
        var childBounds = _this4.getBounds(child, render);
        if (childBounds) {
          if (!aabb) {
            aabb = existedAABB || new AABB();
            aabb.update(childBounds.center, childBounds.halfExtents);
          } else {
            aabb.add(childBounds);
          }
        }
      });
      if (render) {
        // FIXME: account for clip path
        var clipped = findClosestClipPathTarget(element);
        if (clipped) {
          // use bounds under world space
          var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render);
          if (!aabb) {
            aabb = clipPathBounds;
          } else if (clipPathBounds) {
            aabb = clipPathBounds.intersection(aabb);
          }
        }
      }
      if (!aabb) {
        aabb = new AABB();
      }
      if (aabb) {
        if (render) {
          renderable.renderBounds = aabb;
        } else {
          renderable.bounds = aabb;
        }
      }
      if (render) {
        renderable.renderBoundsDirty = false;
      } else {
        renderable.boundsDirty = false;
      }
      return aabb;
    }
    /**
     * account for children in local space
     */;
    _proto.getLocalBounds = function getLocalBounds(element) {
      if (element.parentNode) {
        var parentInvert = create$1();
        if (element.parentNode.transformable) {
          parentInvert = invert(create$1(), this.getWorldTransform(element.parentNode));
        }
        var bounds = this.getBounds(element);
        if (!AABB.isEmpty(bounds)) {
          var localBounds = new AABB();
          localBounds.setFromTransformedAABB(bounds, parentInvert);
          return localBounds;
        }
      }
      return this.getBounds(element);
    };
    _proto.getBoundingClientRect = function getBoundingClientRect(element) {
      var _element$ownerDocumen, _element$ownerDocumen2;
      var aabb;
      var bounds = this.getGeometryBounds(element);
      if (!AABB.isEmpty(bounds)) {
        aabb = new AABB();
        // apply transformation to aabb
        aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
      }
      // calc context's offset
      var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : (_element$ownerDocumen2 = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.getContextService().getBoundingClientRect();
      if (aabb) {
        var _aabb$getMin = aabb.getMin(),
          left = _aabb$getMin[0],
          top = _aabb$getMin[1];
        var _aabb$getMax = aabb.getMax(),
          right = _aabb$getMax[0],
          bottom = _aabb$getMax[1];
        return new Rectangle(left + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right - left, bottom - top);
      }
      return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
    };
    _proto.dirtifyWorldInternal = function dirtifyWorldInternal(element, transform) {
      var _this5 = this;
      if (!transform.dirtyFlag) {
        transform.dirtyFlag = true;
        transform.frozen = false;
        element.childNodes.forEach(function (child) {
          var childTransform = child.transformable;
          if (!childTransform.dirtyFlag) {
            _this5.dirtifyWorldInternal(child, childTransform);
          }
        });
        var renderable = element.renderable;
        if (renderable) {
          renderable.renderBoundsDirty = true;
          renderable.boundsDirty = true;
          renderable.dirty = true;
        }
      }
    };
    _proto.syncHierarchy = function syncHierarchy(element) {
      var transform = element.transformable;
      if (transform.frozen) {
        return;
      }
      transform.frozen = true;
      if (transform.localDirtyFlag || transform.dirtyFlag) {
        this.sync(element, transform);
      }
      var children = element.childNodes;
      for (var i = 0; i < children.length; i++) {
        this.syncHierarchy(children[i]);
      }
    };
    _proto.sync = function sync(element, transform) {
      if (transform.localDirtyFlag) {
        this.calcLocalTransform(transform);
        transform.localDirtyFlag = false;
      }
      if (transform.dirtyFlag) {
        var parent = element.parentNode;
        var parentTransform = parent && parent.transformable;
        if (parent === null || !parentTransform) {
          copy(transform.worldTransform, transform.localTransform);
        } else {
          // TODO: should we support scale compensation?
          // @see https://github.com/playcanvas/engine/issues/1077#issuecomment-359765557
          multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
        }
        transform.dirtyFlag = false;
      }
    };
    _proto.unfreezeParentToRoot = function unfreezeParentToRoot(child) {
      var p = child.parentNode;
      while (p) {
        var transform = p.transformable;
        if (transform) {
          transform.frozen = false;
        }
        p = p.parentNode;
      }
    };
    return DefaultSceneGraphService;
  }();

  var TEXT_METRICS = {
    MetricsString: '|q',
    BaselineSymbol: 'M',
    BaselineMultiplier: 1.4,
    HeightMultiplier: 2,
    Newlines: [0x000a, 0x000d // carriage return
    ],

    BreakingSpaces: [0x0009, 0x0020, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2008, 0x2009, 0x200a, 0x205f, 0x3000 // ideographic space
    ]
  };

  var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
  // Line breaking rules in CJK (Kinsoku Shori)
  // Refer from https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages
  var regexCannotStartZhCn = /[!%),.:;?\]}'""]/;
  var regexCannotEndZhCn = /[$('"]/;
  var regexCannotStartZhTw = /[!),.:;?\]}'""]/;
  var regexCannotEndZhTw = /[([{'"]/;
  var regexCannotStartJaJp = /[)\]'"?!:;,.]/;
  var regexCannotEndJaJp = /[(['"...]/;
  var regexCannotStartKoKr = /[!%),.:;?\]}'"]/;
  var regexCannotEndKoKr = /[$([{'"#]/;
  var regexCannotStart = new RegExp(regexCannotStartZhCn.source + "|" + regexCannotStartZhTw.source + "|" + regexCannotStartJaJp.source + "|" + regexCannotStartKoKr.source);
  var regexCannotEnd = new RegExp(regexCannotEndZhCn.source + "|" + regexCannotEndZhTw.source + "|" + regexCannotEndJaJp.source + "|" + regexCannotEndKoKr.source);
  /**
   * Borrow from pixi/packages/text/src/TextMetrics.ts
   */
  var TextService = /*#__PURE__*/function () {
    function TextService(runtime) {
      var _this = this;
      this.runtime = void 0;
      /**
       * font metrics cache
       */
      this.fontMetricsCache = {};
      this.shouldBreakByKinsokuShorui = function (char, nextChar) {
        if (_this.isBreakingSpace(nextChar)) return false;
        if (char) {
          // Line breaking rules in CJK (Kinsoku Shori)
          if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
            return true;
          }
        }
        return false;
      };
      this.trimByKinsokuShorui = function (prev) {
        var next = [].concat(prev);
        var prevLine = next[next.length - 2];
        if (!prevLine) {
          return prev;
        }
        var lastChar = prevLine[prevLine.length - 1];
        next[next.length - 2] = prevLine.slice(0, -1);
        next[next.length - 1] = lastChar + next[next.length - 1];
        return next;
      };
      this.runtime = runtime;
    }
    var _proto = TextService.prototype;
    /**
     * Calculates the ascent, descent and fontSize of a given font-style.
     */
    _proto.measureFont = function measureFont(font, offscreenCanvas) {
      // as this method is used for preparing assets, don't recalculate things if we don't need to
      if (this.fontMetricsCache[font]) {
        return this.fontMetricsCache[font];
      }
      var properties = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      };
      var canvas = this.runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
      var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
      context.font = font;
      var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
      var width = Math.ceil(context.measureText(metricsString).width);
      var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
      var height = TEXT_METRICS.HeightMultiplier * baseline;
      baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
      // @ts-ignore
      canvas.width = width;
      // @ts-ignore
      canvas.height = height;
      context.fillStyle = '#f00';
      context.fillRect(0, 0, width, height);
      context.font = font;
      context.textBaseline = 'alphabetic';
      context.fillStyle = '#000';
      context.fillText(metricsString, 0, baseline);
      var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
      var pixels = imagedata.length;
      var line = width * 4;
      var i = 0;
      var idx = 0;
      var stop = false;
      // ascent. scan from top to bottom until we find a non red pixel
      for (i = 0; i < baseline; ++i) {
        for (var j = 0; j < line; j += 4) {
          if (imagedata[idx + j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx += line;
        } else {
          break;
        }
      }
      properties.ascent = baseline - i;
      idx = pixels - line;
      stop = false;
      // descent. scan from bottom to top until we find a non red pixel
      for (i = height; i > baseline; --i) {
        for (var _j = 0; _j < line; _j += 4) {
          if (imagedata[idx + _j] !== 255) {
            stop = true;
            break;
          }
        }
        if (!stop) {
          idx -= line;
        } else {
          break;
        }
      }
      properties.descent = i - baseline;
      properties.fontSize = properties.ascent + properties.descent;
      this.fontMetricsCache[font] = properties;
      return properties;
    };
    _proto.measureText = function measureText(text, parsedStyle, offscreenCanvas) {
      var fontSize = parsedStyle.fontSize,
        wordWrap = parsedStyle.wordWrap,
        strokeHeight = parsedStyle.lineHeight,
        lineWidth = parsedStyle.lineWidth,
        textBaseline = parsedStyle.textBaseline,
        textAlign = parsedStyle.textAlign,
        letterSpacing = parsedStyle.letterSpacing,
        textPath = parsedStyle.textPath,
        textPathSide = parsedStyle.textPathSide,
        textPathStartOffset = parsedStyle.textPathStartOffset,
        _parsedStyle$leading = parsedStyle.leading,
        leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
      var font = toFontString(parsedStyle);
      // if (runtime.enableCSSParsing) {
      var fontProperties = this.measureFont(font, offscreenCanvas);
      // fallback in case UA disallow canvas data extraction
      // (toDataURI, getImageData functions)
      if (fontProperties.fontSize === 0) {
        fontProperties.fontSize = fontSize;
        fontProperties.ascent = fontSize;
      }
      // } else {
      //   fontProperties = {
      //     fontSize,
      //   };
      // }
      var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
      context.font = font;
      // no overflowing by default
      parsedStyle.isOverflowing = false;
      var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
      var lines = outputText.split(/(?:\r\n|\r|\n)/);
      var lineWidths = new Array(lines.length);
      var maxLineWidth = 0;
      // account for textPath
      if (textPath) {
        var totalPathLength = textPath.getTotalLength();
        // const startingPoint = textPath.getPoint(0);
        for (var i = 0; i < lines.length; i++) {
          var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
          // for (
          //   let i = reverse ? lines[0].length - 1 : 0;
          //   reverse ? i >= 0 : i < lines[0].length;
          //   reverse ? i-- : i++
          // ) {
          //   graphemeInfo = lineBounds[i];
          //   if (positionInPath > totalPathLength) {
          //     positionInPath %= totalPathLength;
          //   } else if (positionInPath < 0) {
          //     positionInPath += totalPathLength;
          //   }
          //   // it would probably much faster to send all the grapheme position for a line
          //   // and calculate path position/angle at once.
          //   this.setGraphemeOnPath(
          //     positionInPath,
          //     graphemeInfo,
          //     startingPoint
          //   );
          //   positionInPath += graphemeInfo.kernedWidth;
          // }
        }
      } else {
        for (var _i = 0; _i < lines.length; _i++) {
          // char width + letterSpacing
          var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
          lineWidths[_i] = _lineWidth;
          maxLineWidth = Math.max(maxLineWidth, _lineWidth);
        }
        var _width = maxLineWidth + lineWidth;
        // if (dropShadow) {
        //   width += dropShadowDistance;
        // }
        var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
        var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
        // if (dropShadow) {
        //   height += dropShadowDistance;
        // }
        lineHeight += leading;
        // handle vertical text baseline
        var offsetY = 0;
        if (textBaseline === 'middle') {
          offsetY = -height / 2;
        } else if (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {
          offsetY = -height;
        } else if (textBaseline === 'top' || textBaseline === 'hanging') {
          offsetY = 0;
        }
        return {
          font: font,
          width: _width,
          height: height,
          lines: lines,
          lineWidths: lineWidths,
          lineHeight: lineHeight,
          maxLineWidth: maxLineWidth,
          fontProperties: fontProperties,
          lineMetrics: lineWidths.map(function (width, i) {
            var offsetX = 0;
            // handle horizontal text align
            if (textAlign === 'center' || textAlign === 'middle') {
              offsetX -= width / 2;
            } else if (textAlign === 'right' || textAlign === 'end') {
              offsetX -= width;
            }
            return new Rectangle(offsetX - lineWidth / 2, offsetY + i * lineHeight, width + lineWidth, lineHeight);
          })
        };
      }
    };
    _proto.setGraphemeOnPath = function setGraphemeOnPath() {};
    _proto.wordWrap = function wordWrap(text, parsedStyle, offscreenCanvas) {
      var _this2 = this;
      var _parsedStyle$wordWrap = parsedStyle.wordWrapWidth,
        wordWrapWidth = _parsedStyle$wordWrap === void 0 ? 0 : _parsedStyle$wordWrap,
        letterSpacing = parsedStyle.letterSpacing,
        _parsedStyle$maxLines = parsedStyle.maxLines,
        maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines,
        textOverflow = parsedStyle.textOverflow;
      var context = this.runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
      var maxWidth = wordWrapWidth + letterSpacing;
      var ellipsis = '';
      if (textOverflow === 'ellipsis') {
        ellipsis = '...';
      } else if (textOverflow && textOverflow !== 'clip') {
        ellipsis = textOverflow;
      }
      var lines = [];
      var currentIndex = 0;
      var currentWidth = 0;
      var cache = {};
      var calcWidth = function calcWidth(char) {
        return _this2.getFromCache(char, letterSpacing, cache, context);
      };
      var ellipsisWidth = Array.from(ellipsis).reduce(function (prev, cur) {
        return prev + calcWidth(cur);
      }, 0);
      var chars = Array.from(text);
      for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        var prevChar = text[i - 1];
        var nextChar = text[i + 1];
        var charWidth = calcWidth(char);
        if (this.isNewline(char)) {
          currentIndex++;
          // exceed maxLines, break immediately
          if (currentIndex >= maxLines) {
            parsedStyle.isOverflowing = true;
            break;
          }
          currentWidth = 0;
          lines[currentIndex] = '';
          continue;
        }
        if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
          if (currentIndex + 1 >= maxLines) {
            parsedStyle.isOverflowing = true;
            // If there is not enough space to display the string itself, it is clipped.
            // @see https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow#values
            if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
              // Backspace from line's end.
              var currentLineLength = lines[currentIndex].length;
              var lastLineWidth = 0;
              var lastLineIndex = currentLineLength;
              for (var _i2 = 0; _i2 < currentLineLength; _i2++) {
                var width = calcWidth(lines[currentIndex][_i2]);
                if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                  lastLineIndex = _i2;
                  break;
                }
                lastLineWidth += width;
              }
              lines[currentIndex] = (lines[currentIndex] || '').slice(0, lastLineIndex) + ellipsis;
            }
            break;
          }
          currentIndex++;
          currentWidth = 0;
          lines[currentIndex] = '';
          if (this.isBreakingSpace(char)) {
            continue;
          }
          if (!this.canBreakInLastChar(char)) {
            lines = this.trimToBreakable(lines);
            currentWidth = this.sumTextWidthByCache(lines[currentIndex] || '', cache);
          }
          if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
            lines = this.trimByKinsokuShorui(lines);
            currentWidth += calcWidth(prevChar || '');
          }
        }
        currentWidth += charWidth;
        lines[currentIndex] = (lines[currentIndex] || '') + char;
      }
      return lines.join('\n');
    };
    _proto.isBreakingSpace = function isBreakingSpace(char) {
      if (typeof char !== 'string') {
        return false;
      }
      return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
    };
    _proto.isNewline = function isNewline(char) {
      if (typeof char !== 'string') {
        return false;
      }
      return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
    };
    _proto.trimToBreakable = function trimToBreakable(prev) {
      var next = [].concat(prev);
      var prevLine = next[next.length - 2];
      var index = this.findBreakableIndex(prevLine);
      if (index === -1 || !prevLine) return next;
      var trimmedChar = prevLine.slice(index, index + 1);
      var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
      var trimFrom = index + 1;
      var trimTo = index + (isTrimmedWithSpace ? 0 : 1);
      next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
      next[next.length - 2] = prevLine.slice(0, trimTo);
      return next;
    };
    _proto.canBreakInLastChar = function canBreakInLastChar(char) {
      if (char && LATIN_REGEX.test(char)) return false;
      return true;
    };
    _proto.sumTextWidthByCache = function sumTextWidthByCache(text, cache) {
      return text.split('').reduce(function (sum, c) {
        if (!cache[c]) throw Error('cannot count the word without cache');
        return sum + cache[c];
      }, 0);
    };
    _proto.findBreakableIndex = function findBreakableIndex(line) {
      for (var i = line.length - 1; i >= 0; i--) {
        if (!LATIN_REGEX.test(line[i])) return i;
      }
      return -1;
    };
    _proto.getFromCache = function getFromCache(key, letterSpacing, cache, context) {
      var width = cache[key];
      if (typeof width !== 'number') {
        var spacing = key.length * letterSpacing;
        width = context.measureText(key).width + spacing;
        cache[key] = width;
      }
      return width;
    };
    return TextService;
  }();
  var runtime = {};
  /**
   * Replace with IoC container
   */
  var geometryUpdaterFactory = function () {
    var _ref;
    var rectUpdater = new RectUpdater();
    var polylineUpdater = new PolylineUpdater();
    return _ref = {}, _ref[Shape.CIRCLE] = new CircleUpdater(), _ref[Shape.ELLIPSE] = new EllipseUpdater(), _ref[Shape.RECT] = rectUpdater, _ref[Shape.IMAGE] = rectUpdater, _ref[Shape.GROUP] = rectUpdater, _ref[Shape.LINE] = new LineUpdater(), _ref[Shape.TEXT] = new TextUpdater(runtime), _ref[Shape.POLYLINE] = polylineUpdater, _ref[Shape.POLYGON] = polylineUpdater, _ref[Shape.PATH] = new PathUpdater(), _ref[Shape.HTML] = null, _ref[Shape.MESH] = null, _ref;
  }();
  var CSSPropertySyntaxFactory = function () {
    var _ref2;
    var color = new CSSPropertyColor();
    var length = new CSSPropertyLengthOrPercentage();
    return _ref2 = {}, _ref2[PropertySyntax.PERCENTAGE] = null, _ref2[PropertySyntax.NUMBER] = new CSSPropertyNumber(), _ref2[PropertySyntax.ANGLE] = new CSSPropertyAngle(), _ref2[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _ref2[PropertySyntax.PAINT] = color, _ref2[PropertySyntax.COLOR] = color, _ref2[PropertySyntax.FILTER] = new CSSPropertyFilter(), _ref2[PropertySyntax.LENGTH] = length, _ref2[PropertySyntax.LENGTH_PERCENTAGE] = length, _ref2[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _ref2[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _ref2[PropertySyntax.COORDINATE] = new CSSPropertyLocalPosition(), _ref2[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _ref2[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _ref2[PropertySyntax.PATH] = new CSSPropertyPath(), _ref2[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _ref2[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _ref2[PropertySyntax.TEXT] = new CSSPropertyText(), _ref2[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _ref2[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _ref2[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _ref2[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _ref2[PropertySyntax.MARKER] = new CSSPropertyMarker(), _ref2;
  }();
  var getGlobalThis = function getGlobalThis() {
    if (typeof globalThis !== 'undefined') return globalThis;
    if (typeof self !== 'undefined') return self;
    if (typeof window !== 'undefined') return window;
    // @ts-ignore
    if (typeof global !== 'undefined') return global;
    throw new Error('Unable to locate global `this`');
  };
  /**
   * Camera
   * `g-camera-api` will provide an advanced implementation
   */
  runtime.CameraContribution = Camera;
  /**
   * `g-web-animations-api` will provide an AnimationTimeline
   */
  runtime.AnimationTimeline = null;
  runtime.EasingFunction = null;
  runtime.offscreenCanvas = new OffscreenCanvasCreator();
  runtime.nativeHTMLMap = new WeakMap();
  runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
  runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
  runtime.textService = new TextService(runtime);
  runtime.geometryUpdaterFactory = geometryUpdaterFactory;
  runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
  runtime.styleValueRegistry = new DefaultStyleValueRegistry();
  runtime.layoutRegistry = null;
  runtime.globalThis = getGlobalThis();
  runtime.enableCSSParsing = true;

  var AbstractRendererPlugin = /*#__PURE__*/function () {
    function AbstractRendererPlugin() {
      this.context = void 0;
      this.plugins = [];
    }
    var _proto = AbstractRendererPlugin.prototype;
    _proto.addRenderingPlugin = function addRenderingPlugin(plugin) {
      this.plugins.push(plugin);
      this.context.renderingPlugins.push(plugin);
    };
    _proto.removeAllRenderingPlugins = function removeAllRenderingPlugins() {
      var _this = this;
      this.plugins.forEach(function (plugin) {
        var index = _this.context.renderingPlugins.indexOf(plugin);
        if (index >= 0) {
          _this.context.renderingPlugins.splice(index, 1);
        }
      });
    };
    return AbstractRendererPlugin;
  }();
  var AbstractRenderer = /*#__PURE__*/function () {
    function AbstractRenderer(config) {
      this.plugins = [];
      this.config = void 0;
      this.config = _extends({
        /**
         * only dirty object will cause re-render
         */
        enableDirtyCheck: true,
        enableCulling: false,
        /**
         * enable auto rendering by default
         */
        enableAutoRendering: true,
        /**
         * enable dirty rectangle rendering by default
         */
        enableDirtyRectangleRendering: true,
        enableDirtyRectangleRenderingDebug: false
      }, config);
    }
    var _proto2 = AbstractRenderer.prototype;
    _proto2.registerPlugin = function registerPlugin(plugin) {
      var index = this.plugins.findIndex(function (p) {
        return p === plugin;
      });
      if (index === -1) {
        this.plugins.push(plugin);
      }
    };
    _proto2.unregisterPlugin = function unregisterPlugin(plugin) {
      var index = this.plugins.findIndex(function (p) {
        return p === plugin;
      });
      if (index > -1) {
        this.plugins.splice(index, 1);
      }
    };
    _proto2.getPlugins = function getPlugins() {
      return this.plugins;
    };
    _proto2.getPlugin = function getPlugin(name) {
      return this.plugins.find(function (plugin) {
        return plugin.name === name;
      });
    };
    _proto2.getConfig = function getConfig() {
      return this.config;
    };
    _proto2.setConfig = function setConfig(config) {
      Object.assign(this.config, config);
    };
    return AbstractRenderer;
  }();

  /**
   * apply following rules:
   * 1. `visibility` in scenegraph node
   * 2. other custom culling strategies, eg. frustum culling
   */
  var CullingPlugin = /*#__PURE__*/function () {
    function CullingPlugin(strategies) {
      this.strategies = void 0;
      this.strategies = strategies;
    }
    var _proto = CullingPlugin.prototype;
    _proto.apply = function apply(context) {
      var camera = context.camera,
        renderingService = context.renderingService,
        renderingContext = context.renderingContext;
      var strategies = this.strategies;
      renderingService.hooks.cull.tap(CullingPlugin.tag, function (object) {
        if (object) {
          var cullable = object.cullable;
          // cullable.visible = true;
          // const renderBounds = object.getRenderBounds();
          // if (AABB.isEmpty(renderBounds)) {
          //   cullable.visible = false;
          // } else {
          //   const isShape2D = shape2D.indexOf(object.nodeName as Shape) > -1;
          //   const [p0, p1, p2, p3] = camera.getFrustum().planes;
          //   tmpAABB.setMinMax([-p1.distance, -p3.distance, 0], [p0.distance, p2.distance, 0]);
          //   cullable.visible = isShape2D ? renderBounds.intersects(tmpAABB) : true;
          // }
          if (strategies.length === 0) {
            cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
          } else {
            // eg. implemented by g-webgl(frustum culling)
            cullable.visible = strategies.every(function (strategy) {
              return strategy.isVisible(camera, object);
            });
          }
          if (!object.isCulled() && object.isVisible()) {
            return object;
          } else {
            // if (this.renderingContext.renderListLastFrame.indexOf(object) > -1) {
            object.dispatchEvent(new CustomEvent(ElementEvent.CULLED));
            // }
          }

          return null;
        }
        return object;
      });
      renderingService.hooks.afterRender.tap(CullingPlugin.tag, function (object) {
        object.cullable.visibilityPlaneMask = -1;
      });
    };
    return CullingPlugin;
  }();
  CullingPlugin.tag = 'Culling';

  /**
   * Filter dirty renderables and calculate the "dirty rectangle" which will be clear when frame began
   */
  var DirtyCheckPlugin = /*#__PURE__*/function () {
    function DirtyCheckPlugin() {}
    var _proto = DirtyCheckPlugin.prototype;
    _proto.apply = function apply(context) {
      var renderingService = context.renderingService;
      renderingService.hooks.dirtycheck.tap(DirtyCheckPlugin.tag, function (object) {
        if (object) {
          var renderable = object.renderable;
          var isDirty = renderable.dirty || renderingService.disableDirtyRectangleRendering();
          if (isDirty) {
            return object;
          } else {
            return null;
          }
        }
        return object;
      });
    };
    return DirtyCheckPlugin;
  }();
  DirtyCheckPlugin.tag = 'DirtyCheck';

  /**
   * support mouse & touch events
   * @see https://github.com/pixijs/pixi.js/blob/dev/packages/interaction/README.md
   *
   * also provide some extra events such as `drag`
   */
  var EventPlugin = /*#__PURE__*/function () {
    function EventPlugin() {
      var _this = this;
      this.autoPreventDefault = false;
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.rootWheelEvent = new FederatedWheelEvent(null);
      this.context = void 0;
      this.onPointerMove = function (nativeEvent) {
        var _this$context$renderi, _this$context$renderi2;
        var canvas = (_this$context$renderi = _this.context.renderingContext.root) === null || _this$context$renderi === void 0 ? void 0 : (_this$context$renderi2 = _this$context$renderi.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
        var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
        for (var _iterator = _createForOfIteratorHelperLoose(normalizedEvents), _step; !(_step = _iterator()).done;) {
          var normalizedEvent = _step.value;
          var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this.context.eventService.mapEvent(event);
        }
        _this.setCursor(_this.context.eventService.cursor);
      };
    }
    var _proto = EventPlugin.prototype;
    _proto.apply = function apply(context) {
      var _this2 = this;
      this.context = context;
      var renderingService = context.renderingService;
      var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
      this.context.eventService.setPickHandler(function (position) {
        var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
            position: position,
            picked: [],
            topmost: true // we only concern the topmost element
          }),
          picked = _this2$context$render.picked;
        return picked[0] || null;
      });
      renderingService.hooks.pointerWheel.tap(EventPlugin.tag, function (nativeEvent) {
        var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
        _this2.context.eventService.mapEvent(wheelEvent);
      });
      renderingService.hooks.pointerDown.tap(EventPlugin.tag, function (nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
        var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        if (_this2.autoPreventDefault && events[0].isNormalized) {
          var cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (var _iterator2 = _createForOfIteratorHelperLoose(events), _step2; !(_step2 = _iterator2()).done;) {
          var event = _step2.value;
          var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(federatedEvent);
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerUp.tap(EventPlugin.tag, function (nativeEvent) {
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === 'touch') return;
        // account for element in SVG
        var $element = _this2.context.contextService.getDomElement();
        var outside = 'outside';
        try {
          outside = $element && nativeEvent.target && nativeEvent.target !== $element && $element.contains && !$element.contains(nativeEvent.target) ? 'outside' : '';
        } catch (e) {
          // nativeEvent.target maybe not Node, such as Window
          // @see https://github.com/antvis/G/issues/1235
        }
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        for (var _iterator3 = _createForOfIteratorHelperLoose(normalizedEvents), _step3; !(_step3 = _iterator3()).done;) {
          var normalizedEvent = _step3.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          event.type += outside;
          _this2.context.eventService.mapEvent(event);
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
      renderingService.hooks.pointerMove.tap(EventPlugin.tag, this.onPointerMove);
      renderingService.hooks.pointerOver.tap(EventPlugin.tag, this.onPointerMove);
      renderingService.hooks.pointerOut.tap(EventPlugin.tag, this.onPointerMove);
      renderingService.hooks.click.tap(EventPlugin.tag, this.onPointerMove);
      renderingService.hooks.pointerCancel.tap(EventPlugin.tag, function (nativeEvent) {
        var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
        for (var _iterator4 = _createForOfIteratorHelperLoose(normalizedEvents), _step4; !(_step4 = _iterator4()).done;) {
          var normalizedEvent = _step4.value;
          var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
          _this2.context.eventService.mapEvent(event);
        }
        _this2.setCursor(_this2.context.eventService.cursor);
      });
    };
    _proto.getViewportXY = function getViewportXY(nativeEvent) {
      var x;
      var y;
      /**
       * Should account for CSS Transform applied on container.
       * @see https://github.com/antvis/G/issues/1161
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
       */
      var offsetX = nativeEvent.offsetX,
        offsetY = nativeEvent.offsetY,
        clientX = nativeEvent.clientX,
        clientY = nativeEvent.clientY;
      if (this.context.config.supportsCSSTransform && !isNil(offsetX) && !isNil(offsetY)) {
        x = offsetX;
        y = offsetY;
      } else {
        var point = this.context.eventService.client2Viewport(new Point(clientX, clientY));
        x = point.x;
        y = point.y;
      }
      return {
        x: x,
        y: y
      };
    };
    _proto.bootstrapEvent = function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
      event.view = view;
      event.originalEvent = null;
      event.nativeEvent = nativeEvent;
      event.pointerId = normalizedEvent.pointerId;
      event.width = normalizedEvent.width;
      event.height = normalizedEvent.height;
      event.isPrimary = normalizedEvent.isPrimary;
      event.pointerType = normalizedEvent.pointerType;
      event.pressure = normalizedEvent.pressure;
      event.tangentialPressure = normalizedEvent.tangentialPressure;
      event.tiltX = normalizedEvent.tiltX;
      event.tiltY = normalizedEvent.tiltY;
      event.twist = normalizedEvent.twist;
      this.transferMouseData(event, normalizedEvent);
      var _this$getViewportXY = this.getViewportXY(normalizedEvent),
        x = _this$getViewportXY.x,
        y = _this$getViewportXY.y;
      event.viewport.x = x;
      event.viewport.y = y;
      var _this$context$eventSe = this.context.eventService.viewport2Canvas(event.viewport),
        canvasX = _this$context$eventSe.x,
        canvasY = _this$context$eventSe.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.isTrusted = nativeEvent.isTrusted;
      if (event.type === 'pointerleave') {
        event.type = 'pointerout';
      }
      if (event.type.startsWith('mouse')) {
        event.type = event.type.replace('mouse', 'pointer');
      }
      if (event.type.startsWith('touch')) {
        event.type = TOUCH_TO_POINTER[event.type] || event.type;
      }
      return event;
    };
    _proto.normalizeWheelEvent = function normalizeWheelEvent(nativeEvent) {
      var event = this.rootWheelEvent;
      this.transferMouseData(event, nativeEvent);
      event.deltaMode = nativeEvent.deltaMode;
      event.deltaX = nativeEvent.deltaX;
      event.deltaY = nativeEvent.deltaY;
      event.deltaZ = nativeEvent.deltaZ;
      var _this$getViewportXY2 = this.getViewportXY(nativeEvent),
        x = _this$getViewportXY2.x,
        y = _this$getViewportXY2.y;
      event.viewport.x = x;
      event.viewport.y = y;
      var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport),
        canvasX = _this$context$eventSe2.x,
        canvasY = _this$context$eventSe2.y;
      event.canvas.x = canvasX;
      event.canvas.y = canvasY;
      event.global.copyFrom(event.canvas);
      event.offset.copyFrom(event.canvas);
      event.nativeEvent = nativeEvent;
      event.type = nativeEvent.type;
      return event;
    }
    /**
     * Transfers base & mouse event data from the nativeEvent to the federated event.
     */;
    _proto.transferMouseData = function transferMouseData(event, nativeEvent) {
      event.isTrusted = nativeEvent.isTrusted;
      event.srcElement = nativeEvent.srcElement;
      event.timeStamp = performance.now();
      event.type = nativeEvent.type;
      event.altKey = nativeEvent.altKey;
      event.metaKey = nativeEvent.metaKey;
      event.shiftKey = nativeEvent.shiftKey;
      event.ctrlKey = nativeEvent.ctrlKey;
      event.button = nativeEvent.button;
      event.buttons = nativeEvent.buttons;
      event.client.x = nativeEvent.clientX;
      event.client.y = nativeEvent.clientY;
      event.movement.x = nativeEvent.movementX;
      event.movement.y = nativeEvent.movementY;
      event.page.x = nativeEvent.pageX;
      event.page.y = nativeEvent.pageY;
      event.screen.x = nativeEvent.screenX;
      event.screen.y = nativeEvent.screenY;
      event.relatedTarget = null;
    };
    _proto.setCursor = function setCursor(cursor) {
      this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || 'default');
    };
    _proto.normalizeToPointerEvent = function normalizeToPointerEvent(event, canvas) {
      var normalizedEvents = [];
      if (canvas.isTouchEvent(event)) {
        for (var i = 0; i < event.changedTouches.length; i++) {
          var touch = event.changedTouches[i];
          // use changedTouches instead of touches since touchend has no touches
          // @see https://stackoverflow.com/a/10079076
          if (isUndefined(touch.button)) touch.button = 0;
          if (isUndefined(touch.buttons)) touch.buttons = 1;
          if (isUndefined(touch.isPrimary)) {
            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
          }
          if (isUndefined(touch.width)) touch.width = touch.radiusX || 1;
          if (isUndefined(touch.height)) touch.height = touch.radiusY || 1;
          if (isUndefined(touch.tiltX)) touch.tiltX = 0;
          if (isUndefined(touch.tiltY)) touch.tiltY = 0;
          if (isUndefined(touch.pointerType)) touch.pointerType = 'touch';
          // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier
          if (isUndefined(touch.pointerId)) touch.pointerId = touch.identifier || 0;
          if (isUndefined(touch.pressure)) touch.pressure = touch.force || 0.5;
          if (isUndefined(touch.twist)) touch.twist = 0;
          if (isUndefined(touch.tangentialPressure)) touch.tangentialPressure = 0;
          touch.isNormalized = true;
          touch.type = event.type;
          normalizedEvents.push(touch);
        }
      } else if (canvas.isMouseEvent(event)) {
        var tempEvent = event;
        if (isUndefined(tempEvent.isPrimary)) tempEvent.isPrimary = true;
        if (isUndefined(tempEvent.width)) tempEvent.width = 1;
        if (isUndefined(tempEvent.height)) tempEvent.height = 1;
        if (isUndefined(tempEvent.tiltX)) tempEvent.tiltX = 0;
        if (isUndefined(tempEvent.tiltY)) tempEvent.tiltY = 0;
        if (isUndefined(tempEvent.pointerType)) tempEvent.pointerType = 'mouse';
        if (isUndefined(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
        if (isUndefined(tempEvent.pressure)) tempEvent.pressure = 0.5;
        if (isUndefined(tempEvent.twist)) tempEvent.twist = 0;
        if (isUndefined(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
        tempEvent.isNormalized = true;
        normalizedEvents.push(tempEvent);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    };
    return EventPlugin;
  }();
  EventPlugin.tag = 'Event';

  // group is not a 2d shape
  var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
  var FrustumCullingStrategy = /*#__PURE__*/function () {
    function FrustumCullingStrategy() {}
    var _proto = FrustumCullingStrategy.prototype;
    _proto.isVisible = function isVisible(camera, object) {
      var _object$parentNode, _object$parentNode$cu;
      // return true;
      var cullable = object.cullable;
      if (!cullable.enable) {
        return true;
      }
      var renderBounds = object.getRenderBounds();
      if (AABB.isEmpty(renderBounds)) {
        return false;
      }
      // get VP matrix from camera
      var frustum = camera.getFrustum();
      var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 ? void 0 : (_object$parentNode$cu = _object$parentNode.cullable) === null || _object$parentNode$cu === void 0 ? void 0 : _object$parentNode$cu.visibilityPlaneMask;
      cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum.planes);
      cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
      return cullable.visible;
    }
    /**
     *
     * @seeOptimized View Frustum Culling Algorithms for Bounding Boxes
     * @see https://github.com/antvis/GWebGPUEngine/issues/3
     *
     * *  the basic intersection test
     * *  masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
     * * TODO:  the plane-coherency test
     * * TODO:  mesh  Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
     *
     * @param aabb aabb
     * @param parentPlaneMask mask of parent
     * @param planes planes of frustum
     */;
    _proto.computeVisibilityWithPlaneMask = function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
      if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
        // 
        return parentPlaneMask;
      }
      // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.
      // (Because if there are fewer than 31 planes, the upper bits wont be changed.)
      var mask = Mask.INSIDE;
      var isShape2D = shape2D.indexOf(object.nodeName) > -1;
      // Use viewport culling for 2D shapes
      // @see https://github.com/antvis/g/issues/914
      for (var k = 0, len = planes.length; k < len; ++k) {
        // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.
        var flag = 1 << k;
        if ((parentPlaneMask & flag) === 0) {
          // 
          continue;
        }
        // skip near & far planes when testing 2D shapes
        if (isShape2D && (k === 4 || k === 5)) {
          continue;
        }
        // p-vertex n-vertex <-|plane p-vertex n-vertex
        //  p-vertex  n-vertex  aabb 
        var _planes$k = planes[k],
          normal = _planes$k.normal,
          distance = _planes$k.distance;
        if (dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance < 0) {
          return Mask.OUTSIDE;
        }
        if (dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance < 0) {
          // 1
          mask |= flag;
        }
      }
      return mask;
    };
    return FrustumCullingStrategy;
  }();

  var PrepareRendererPlugin = /*#__PURE__*/function () {
    function PrepareRendererPlugin() {
      this.rBush = void 0;
      /**
       * sync to RBush later
       */
      this.toSync = new Set();
    }
    var _proto = PrepareRendererPlugin.prototype;
    // private isFirstTimeRendering = true;
    // private syncing = false;
    _proto.apply = function apply(context) {
      var _this = this;
      var renderingService = context.renderingService,
        renderingContext = context.renderingContext,
        rBushRoot = context.rBushRoot;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      this.rBush = rBushRoot;
      var handleAttributeChanged = function handleAttributeChanged(e) {
        var object = e.target;
        object.renderable.dirty = true;
        renderingService.dirtify();
      };
      var handleBoundsChanged = function handleBoundsChanged(e) {
        var affectChildren = e.detail.affectChildren;
        var object = e.target;
        if (affectChildren) {
          object.forEach(function (node) {
            _this.toSync.add(node);
          });
        }
        var p = object;
        while (p) {
          if (p.renderable) {
            _this.toSync.add(p);
          }
          p = p.parentElement;
        }
        // this.pushToSync(e.composedPath().slice(0, -2) as DisplayObject[]);
        renderingService.dirtify();
      };
      var handleMounted = function handleMounted(e) {
        var object = e.target;
        if (runtime.enableCSSParsing) {
          // recalc style values
          runtime.styleValueRegistry.recalc(object);
        }
        runtime.sceneGraphService.dirtifyToRoot(object);
        renderingService.dirtify();
      };
      var handleUnmounted = function handleUnmounted(e) {
        var object = e.target;
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          _this.rBush.remove(rBushNode.aabb);
        }
        _this.toSync.delete(object);
        runtime.sceneGraphService.dirtifyToRoot(object);
        renderingService.dirtify();
      };
      renderingService.hooks.init.tapPromise(PrepareRendererPlugin.tag, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
              canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      renderingService.hooks.destroy.tap(PrepareRendererPlugin.tag, function () {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        _this.toSync.clear();
      });
      renderingService.hooks.endFrame.tap(PrepareRendererPlugin.tag, function () {
        // if (this.isFirstTimeRendering) {
        //   this.isFirstTimeRendering = false;
        //   this.syncing = true;
        //   // @see https://github.com/antvis/G/issues/1117
        //   setTimeout(() => {
        //     this.syncRTree();
        //     console.log('fcp...');
        //   });
        // } else {
        //   console.log('next...');
        _this.syncRTree();
        // }
      });
    };
    _proto.syncRTree = function syncRTree() {
      var _this2 = this;
      // if (this.syncing) {
      //   return;
      // }
      // bounds changed, need re-inserting its children
      var bulk = [];
      Array.from(this.toSync)
      // some objects may be removed since last frame
      .filter(function (object) {
        return object.isConnected;
      }).forEach(function (node) {
        var rBushNode = node.rBushNode;
        // clear dirty node
        if (rBushNode && rBushNode.aabb) {
          _this2.rBush.remove(rBushNode.aabb);
        }
        var renderBounds = node.getRenderBounds();
        if (renderBounds) {
          var _renderBounds$getMin = renderBounds.getMin(),
            minX = _renderBounds$getMin[0],
            minY = _renderBounds$getMin[1];
          var _renderBounds$getMax = renderBounds.getMax(),
            maxX = _renderBounds$getMax[0],
            maxY = _renderBounds$getMax[1];
          if (!rBushNode.aabb) {
            rBushNode.aabb = {};
          }
          rBushNode.aabb.displayObject = node;
          rBushNode.aabb.minX = minX;
          rBushNode.aabb.minY = minY;
          rBushNode.aabb.maxX = maxX;
          rBushNode.aabb.maxY = maxY;
        }
        if (rBushNode.aabb) {
          // TODO: NaN occurs when width/height of Rect is 0
          if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
            bulk.push(rBushNode.aabb);
          }
        }
      });
      // use bulk inserting, which is ~2-3 times faster
      // @see https://github.com/mourner/rbush#bulk-inserting-data
      this.rBush.load(bulk);
      bulk.length = 0;
      this.toSync.clear();
      // this.syncing = false;
    };
    return PrepareRendererPlugin;
  }();
  PrepareRendererPlugin.tag = 'Prepare';

  function isCanvas(value) {
    return !!value.document;
  }
  var CanvasEvent;
  (function (CanvasEvent) {
    CanvasEvent["READY"] = "ready";
    CanvasEvent["BEFORE_RENDER"] = "beforerender";
    CanvasEvent["RERENDER"] = "rerender";
    CanvasEvent["AFTER_RENDER"] = "afterrender";
    CanvasEvent["BEFORE_DESTROY"] = "beforedestroy";
    CanvasEvent["AFTER_DESTROY"] = "afterdestroy";
    CanvasEvent["RESIZE"] = "resize";
    CanvasEvent["DIRTY_RECTANGLE"] = "dirtyrectangle";
  })(CanvasEvent || (CanvasEvent = {}));
  var DEFAULT_CAMERA_Z = 500;
  var DEFAULT_CAMERA_NEAR = 0.1;
  var DEFAULT_CAMERA_FAR = 1000;
  /**
   * reuse custom event preventing from re-create them in every frame
   */
  var mountedEvent = new CustomEvent(ElementEvent.MOUNTED);
  var unmountedEvent = new CustomEvent(ElementEvent.UNMOUNTED);
  var beforeRenderEvent = new CustomEvent(CanvasEvent.BEFORE_RENDER);
  var rerenderEvent = new CustomEvent(CanvasEvent.RERENDER);
  var afterRenderEvent = new CustomEvent(CanvasEvent.AFTER_RENDER);
  /**
   * can be treated like Window in DOM
   * provide some extra methods like `window`, such as:
   * * `window.requestAnimationFrame`
   * * `window.devicePixelRatio`
   *
   * prototype chains: Canvas(Window) -> EventTarget
   */
  var Canvas = /*#__PURE__*/function (_EventTarget) {
    _inheritsLoose(Canvas, _EventTarget);
    /**
     * window.document
     */

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry
     */

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
     */

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
     */

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
     */

    /**
     * whether the runtime supports PointerEvent?
     * if not, the event system won't trigger pointer events like `pointerdown`
     */

    /**
     * whether the runtime supports TouchEvent?
     * if not, the event system won't trigger touch events like `touchstart`
     */

    /**
     * is this native event a TouchEvent?
     */

    /**
     * is this native event a MouseEvent?
     */

    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Element
     */

    /**
     * rAF in auto rendering
     */

    function Canvas(config) {
      var _this;
      _this = _EventTarget.call(this) || this;
      // create document
      _this.document = void 0;
      _this.customElements = void 0;
      _this.requestAnimationFrame = void 0;
      _this.cancelAnimationFrame = void 0;
      _this.devicePixelRatio = void 0;
      _this.supportsPointerEvents = void 0;
      _this.supportsTouchEvents = void 0;
      _this.isTouchEvent = void 0;
      _this.isMouseEvent = void 0;
      _this.Element = DisplayObject;
      _this.frameId = void 0;
      _this.inited = false;
      _this.readyPromise = void 0;
      _this.resolveReadyPromise = void 0;
      _this.context = {};
      _this.document = new Document();
      _this.document.defaultView = _assertThisInitialized(_this);
      // create registry of custom elements
      _this.customElements = new CustomElementRegistry();
      var container = config.container,
        canvas = config.canvas,
        offscreenCanvas = config.offscreenCanvas,
        width = config.width,
        height = config.height,
        devicePixelRatio = config.devicePixelRatio,
        renderer = config.renderer,
        background = config.background,
        cursor = config.cursor,
        document = config.document,
        requestAnimationFrame = config.requestAnimationFrame,
        cancelAnimationFrame = config.cancelAnimationFrame,
        createImage = config.createImage,
        supportsPointerEvents = config.supportsPointerEvents,
        supportsTouchEvents = config.supportsTouchEvents,
        supportsCSSTransform = config.supportsCSSTransform,
        useNativeClickEvent = config.useNativeClickEvent,
        isTouchEvent = config.isTouchEvent,
        isMouseEvent = config.isMouseEvent;
      cleanExistedCanvas(container, _assertThisInitialized(_this));
      var canvasWidth = width;
      var canvasHeight = height;
      var dpr = devicePixelRatio;
      // use user-defined <canvas> or OffscreenCanvas
      if (canvas) {
        // infer width & height with dpr
        dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
        canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
        canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
      }
      /**
       * implements `Window` interface
       */
      _this.devicePixelRatio = dpr;
      _this.requestAnimationFrame = requestAnimationFrame !== null && requestAnimationFrame !== void 0 ? requestAnimationFrame : raf.bind(runtime.globalThis);
      _this.cancelAnimationFrame = cancelAnimationFrame !== null && cancelAnimationFrame !== void 0 ? cancelAnimationFrame : caf.bind(runtime.globalThis);
      /**
       * limits query
       */
      // the following feature-detect from hammer.js
      // @see https://github.com/hammerjs/hammer.js/blob/master/src/inputjs/input-consts.js#L5
      _this.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : 'ontouchstart' in runtime.globalThis;
      _this.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
      _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function (event) {
        return _this.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
      };
      _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function (event) {
        return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
      };
      _this.initRenderingContext({
        container: container,
        canvas: canvas,
        width: canvasWidth,
        height: canvasHeight,
        renderer: renderer,
        offscreenCanvas: offscreenCanvas,
        devicePixelRatio: dpr,
        cursor: cursor || 'default',
        background: background || 'transparent',
        createImage: createImage,
        document: document,
        supportsCSSTransform: supportsCSSTransform,
        useNativeClickEvent: useNativeClickEvent
      });
      _this.initDefaultCamera(canvasWidth, canvasHeight);
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _this.initRenderer(renderer);
            case 2:
              _this.dispatchEvent(new CustomEvent(CanvasEvent.READY));
              if (_this.readyPromise) {
                _this.resolveReadyPromise();
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
      return _this;
    }
    var _proto = Canvas.prototype;
    _proto.initRenderingContext = function initRenderingContext(mergedConfig) {
      this.context.config = mergedConfig;
      // bind rendering context, shared by all renderers
      this.context.renderingContext = {
        /**
         * the root node in scene graph
         */
        root: this.document.documentElement,
        renderListCurrentFrame: [],
        unculledEntities: [],
        renderReasons: new Set(),
        force: false,
        dirty: false
      };
    };
    _proto.initDefaultCamera = function initDefaultCamera(width, height) {
      var _this2 = this;
      // set a default ortho camera
      var camera = new runtime.CameraContribution();
      camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
      // keep ref since it will use raf in camera animation
      camera.canvas = this;
      // redraw when camera changed
      camera.eventEmitter.on(CameraEvent.UPDATED, function () {
        _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
      });
      // bind camera
      this.context.camera = camera;
    };
    _proto.getConfig = function getConfig() {
      return this.context.config;
    }
    /**
     * get the root displayObject in scenegraph
     * @alias this.document.documentElement
     */;
    _proto.getRoot = function getRoot() {
      return this.document.documentElement;
    }
    /**
     * get the camera of canvas
     */;
    _proto.getCamera = function getCamera() {
      return this.context.camera;
    };
    _proto.getContextService = function getContextService() {
      return this.context.contextService;
    };
    _proto.getEventService = function getEventService() {
      return this.context.eventService;
    };
    _proto.getRenderingService = function getRenderingService() {
      return this.context.renderingService;
    };
    _proto.getRenderingContext = function getRenderingContext() {
      return this.context.renderingContext;
    };
    _proto.getStats = function getStats() {
      return this.getRenderingService().getStats();
    }
    // /**
    //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
    //  */
    // getComputedStyle(node: DisplayObject) {
    //   return node.computedStyle;
    // }
    ;
    /**
     * `cleanUp` means clean all the internal services of Canvas which happens when calling `canvas.destroy()`.
     */
    _proto.destroy = function destroy(cleanUp, skipTriggerEvent) {
      if (cleanUp === void 0) {
        cleanUp = true;
      }
      if (skipTriggerEvent === void 0) {
        skipTriggerEvent = false;
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.BEFORE_DESTROY));
      }
      if (this.frameId) {
        var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
        cancelRAF(this.frameId);
      }
      // unmount all children
      var root = this.getRoot();
      this.unmountChildren(root);
      if (cleanUp) {
        // destroy Document
        this.document.destroy();
        this.getEventService().destroy();
      }
      // destroy services
      this.getRenderingService().destroy();
      this.getContextService().destroy();
      // clear root after renderservice destroyed
      if (cleanUp && this.context.rBushRoot) {
        // clear rbush
        this.context.rBushRoot.clear();
        this.context.rBushRoot = null;
        this.context.renderingContext.root = null;
      }
      if (!skipTriggerEvent) {
        this.dispatchEvent(new CustomEvent(CanvasEvent.AFTER_DESTROY));
      }
    }
    /**
     * compatible with G 3.0
     * @deprecated
     * @alias resize
     */;
    _proto.changeSize = function changeSize(width, height) {
      this.resize(width, height);
    };
    _proto.resize = function resize(width, height) {
      // update canvas' config
      var canvasConfig = this.context.config;
      canvasConfig.width = width;
      canvasConfig.height = height;
      // resize context
      this.getContextService().resize(width, height);
      // resize camera
      var camera = this.context.camera;
      var projectionMode = camera.getProjectionMode();
      camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
      if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
        camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
      } else {
        camera.setAspect(width / height);
      }
      this.dispatchEvent(new CustomEvent(CanvasEvent.RESIZE, {
        width: width,
        height: height
      }));
    }
    // proxy to document.documentElement
    ;
    _proto.appendChild = function appendChild(child, index) {
      return this.document.documentElement.appendChild(child, index);
    };
    _proto.insertBefore = function insertBefore(newChild, refChild) {
      return this.document.documentElement.insertBefore(newChild, refChild);
    };
    _proto.removeChild = function removeChild(child) {
      return this.document.documentElement.removeChild(child);
    }
    /**
     * Remove all children which can be appended to its original parent later again.
     */;
    _proto.removeChildren = function removeChildren() {
      this.document.documentElement.removeChildren();
    }
    /**
     * Recursively destroy all children which can not be appended to its original parent later again.
     * But the canvas remains running which means display objects can be appended later.
     */;
    _proto.destroyChildren = function destroyChildren() {
      this.document.documentElement.destroyChildren();
    };
    _proto.render = function render() {
      var _this3 = this;
      this.dispatchEvent(beforeRenderEvent);
      var renderingService = this.getRenderingService();
      renderingService.render(this.getConfig(), function () {
        // trigger actual rerender event
        // @see https://github.com/antvis/G/issues/1268
        _this3.dispatchEvent(rerenderEvent);
      });
      this.dispatchEvent(afterRenderEvent);
    };
    _proto.run = function run() {
      var _this4 = this;
      var tick = function tick() {
        _this4.render();
        _this4.frameId = requestAnimationFrame(tick);
      };
      tick();
    };
    _proto.initRenderer = /*#__PURE__*/function () {
      var _initRenderer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(renderer) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (renderer) {
                _context2.next = 2;
                break;
              }
              throw new Error('Renderer is required.');
            case 2:
              // reset
              this.inited = false;
              this.readyPromise = undefined;
              // FIXME: should re-create here?
              this.context.rBushRoot = new rbush();
              // reset rendering plugins
              this.context.renderingPlugins = [];
              this.context.renderingPlugins.push(new EventPlugin(), new PrepareRendererPlugin(), new DirtyCheckPlugin(), new CullingPlugin([new FrustumCullingStrategy()]));
              //
              this.loadRendererContainerModule(renderer);
              // init context service
              this.context.contextService = new this.context.ContextService(_extends({}, runtime, this.context));
              // init rendering service
              this.context.renderingService = new RenderingService(runtime, this.context);
              // init event service
              this.context.eventService = new EventService(runtime, this.context);
              this.context.eventService.init();
              _context2.next = 14;
              return this.context.contextService.init();
            case 14:
              _context2.next = 16;
              return this.context.renderingService.init();
            case 16:
              this.inited = true;
              this.getRoot().forEach(function (node) {
                var renderable = node.renderable;
                if (renderable) {
                  renderable.renderBoundsDirty = true;
                  renderable.boundsDirty = true;
                  renderable.dirty = true;
                }
              });
              // keep current scenegraph unchanged, just trigger mounted event
              this.mountChildren(this.getRoot());
              if (renderer.getConfig().enableAutoRendering) {
                this.run();
              }
            case 20:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function initRenderer(_x) {
        return _initRenderer.apply(this, arguments);
      }
      return initRenderer;
    }();
    _proto.loadRendererContainerModule = function loadRendererContainerModule(renderer) {
      var _this5 = this;
      // load other container modules provided by g-canvas/g-svg/g-webgl
      var plugins = renderer.getPlugins();
      plugins.forEach(function (plugin) {
        plugin.context = _this5.context;
        plugin.init(runtime);
      });
    };
    _proto.setRenderer = /*#__PURE__*/function () {
      var _setRenderer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(renderer) {
        var canvasConfig, oldRenderer;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              // update canvas' config
              canvasConfig = this.getConfig();
              if (!(canvasConfig.renderer === renderer)) {
                _context3.next = 3;
                break;
              }
              return _context3.abrupt("return");
            case 3:
              oldRenderer = canvasConfig.renderer;
              canvasConfig.renderer = renderer;
              // keep all children undestroyed
              this.destroy(false, true);
              // destroy all plugins, reverse will mutate origin array
              [].concat(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()).reverse().forEach(function (plugin) {
                plugin.destroy(runtime);
              });
              _context3.next = 9;
              return this.initRenderer(renderer);
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function setRenderer(_x2) {
        return _setRenderer.apply(this, arguments);
      }
      return setRenderer;
    }();
    _proto.setCursor = function setCursor(cursor) {
      var canvasConfig = this.getConfig();
      canvasConfig.cursor = cursor;
      this.getContextService().applyCursorStyle(cursor);
    };
    _proto.unmountChildren = function unmountChildren(parent) {
      var _this6 = this;
      // unmountChildren recursively
      parent.childNodes.forEach(function (child) {
        _this6.unmountChildren(child);
      });
      if (this.inited) {
        if (parent.isMutationObserved) {
          parent.dispatchEvent(unmountedEvent);
        } else {
          unmountedEvent.target = parent;
          this.dispatchEvent(unmountedEvent, true);
        }
        // skip document.documentElement
        if (parent !== this.document.documentElement) {
          parent.ownerDocument = null;
        }
        parent.isConnected = false;
      }
      // trigger after unmounted
      if (parent.isCustomElement) {
        if (parent.disconnectedCallback) {
          parent.disconnectedCallback();
        }
      }
    };
    _proto.mountChildren = function mountChildren(parent) {
      var _this7 = this;
      if (this.inited) {
        if (!parent.isConnected) {
          parent.ownerDocument = this.document;
          parent.isConnected = true;
          if (parent.isMutationObserved) {
            parent.dispatchEvent(mountedEvent);
          } else {
            mountedEvent.target = parent;
            this.dispatchEvent(mountedEvent, true);
          }
        }
      } else {
        console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", 'appended child: ', parent.nodeName);
      }
      // recursively mount children
      parent.childNodes.forEach(function (child) {
        _this7.mountChildren(child);
      });
      // trigger after mounted
      if (parent.isCustomElement) {
        if (parent.connectedCallback) {
          parent.connectedCallback();
        }
      }
    };
    _proto.client2Viewport = function client2Viewport(client) {
      return this.getEventService().client2Viewport(client);
    };
    _proto.viewport2Client = function viewport2Client(canvas) {
      return this.getEventService().viewport2Client(canvas);
    };
    _proto.viewport2Canvas = function viewport2Canvas(viewport) {
      return this.getEventService().viewport2Canvas(viewport);
    };
    _proto.canvas2Viewport = function canvas2Viewport(canvas) {
      return this.getEventService().canvas2Viewport(canvas);
    }
    /**
     * @deprecated
     * @alias client2Viewport
     */;
    _proto.getPointByClient = function getPointByClient(clientX, clientY) {
      return this.client2Viewport({
        x: clientX,
        y: clientY
      });
    }
    /**
     * @deprecated
     * @alias viewport2Client
     */;
    _proto.getClientByPoint = function getClientByPoint(x, y) {
      return this.viewport2Client({
        x: x,
        y: y
      });
    };
    _createClass(Canvas, [{
      key: "ready",
      get: function get() {
        var _this8 = this;
        if (!this.readyPromise) {
          this.readyPromise = new Promise(function (resolve) {
            _this8.resolveReadyPromise = function () {
              resolve(_this8);
            };
          });
          if (this.inited) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
    }]);
    return Canvas;
  }(EventTarget);

  var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInRadian) {
    return {
      x: centerX + radius * Math.cos(angleInRadian),
      y: centerY + radius * Math.sin(angleInRadian)
    };
  };

  function computeArcSweep(startAngle, endAngle, anticlockwise) {
    // 
    if (!anticlockwise) {
      if (endAngle >= startAngle) {
        return endAngle - startAngle <= Math.PI ? 0 : 1;
      }
      return endAngle - startAngle <= -Math.PI ? 0 : 1;
    }
    // 
    if (endAngle >= startAngle) {
      return endAngle - startAngle <= Math.PI ? 1 : 0;
    }
    return endAngle - startAngle <= -Math.PI ? 1 : 0;
  }
  var Arc = /** @class */function (_super) {
    __extends(Arc, _super);
    function Arc(config) {
      var _this = _super.call(this, config) || this;
      _this.updatePath();
      return _this;
    }
    Arc.prototype.setAttribute = function (name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (['cx', 'cy', 'startAngle', 'endAngle', 'r', 'anticlockwise'].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Arc.prototype.updatePath = function () {
      var _a = this.parsedStyle,
        _b = _a.cx,
        cx = _b === void 0 ? 0 : _b,
        _c = _a.cy,
        cy = _c === void 0 ? 0 : _c,
        startAngle = _a.startAngle,
        endAngle = _a.endAngle,
        r = _a.r,
        anticlockwise = _a.anticlockwise;
      if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, anticlockwise);
      _super.prototype.setAttribute.call(this, 'path', path);
    };
    Arc.prototype.createPath = function (x, y, startAngle, endAngle, r, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var angle = Math.abs(endAngle - startAngle);
      if (angle >= Math.PI * 2 || isNumberEqual(angle, Math.PI * 2)) {
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        return [['M', start.x, start.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, anticlockwise ? 0 : 1, start.x, start.y], ['Z']];
      }
      var arcSweep = computeArcSweep(startAngle, endAngle, anticlockwise);
      return [['M', start.x, start.y], ['A', r, r, 0, arcSweep, anticlockwise ? 0 : 1, end.x, end.y]];
    };
    return Arc;
  }(Path);

  var SYMBOLS = {
    circle: function circle(x, y, r) {
      return [['M', x - r, y], ['A', r, r, 0, 1, 0, x + r, y], ['A', r, r, 0, 1, 0, x - r, y]];
    },
    square: function square(x, y, r) {
      return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
    },
    arrow: function arrow(x, y, r) {
      return [['M', x - r, y + 2 * r / Math.sqrt(3)], ['L', x + r, y + 2 * r / Math.sqrt(3)], ['L', x, y - 2 * r / Math.sqrt(3)], ['Z']];
    }
  };
  var Marker = /** @class */function (_super) {
    __extends(Marker, _super);
    function Marker(config) {
      var _this = _super.call(this, config) || this;
      _this.updatePath();
      return _this;
    }
    Marker.prototype.setAttribute = function (name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (['x', 'y', 'symbol', 'radius'].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Marker.prototype.updatePath = function () {
      var _a = this.parsedStyle,
        _b = _a.x,
        x = _b === void 0 ? 0 : _b,
        _c = _a.y,
        y = _c === void 0 ? 0 : _c;
      var _d = this.attributes,
        radius = _d.radius,
        symbol = _d.symbol;
      if (!symbol) return;
      var method = SYMBOLS[symbol];
      if (!method) return;
      var path = method(x, y, radius);
      _super.prototype.setAttribute.call(this, 'path', path);
    };
    return Marker;
  }(Path);

  var PI = Math.PI;
  var PI2 = PI * 2;
  var mathSin = Math.sin;
  var mathCos = Math.cos;
  var mathACos = Math.acos;
  var mathATan2 = Math.atan2;
  // const mathAbs = Math.abs;
  var mathSqrt = Math.sqrt;
  var mathMax = Math.max;
  var mathMin = Math.min;
  var e = 1e-4;
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx10 = x1 - x0;
    var dy10 = y1 - y0;
    var dx32 = x3 - x2;
    var dy32 = y3 - y2;
    var t = dy32 * dx10 - dx32 * dy10;
    if (t * t < e) {
      return;
    }
    t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
    return [x0 + t * dx10, y0 + t * dy10];
  }
  // Compute perpendicular offset line of length rc.
  function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
    var x01 = x0 - x1;
    var y01 = y0 - y1;
    var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
    var ox = lo * y01;
    var oy = -lo * x01;
    var x11 = x0 + ox;
    var y11 = y0 + oy;
    var x10 = x1 + ox;
    var y10 = y1 + oy;
    var x00 = (x11 + x10) / 2;
    var y00 = (y11 + y10) / 2;
    var dx = x10 - x11;
    var dy = y10 - y11;
    var d2 = dx * dx + dy * dy;
    var r = radius - cr;
    var s = x11 * y10 - x10 * y11;
    var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));
    var cx0 = (s * dy - dx * d) / d2;
    var cy0 = (-s * dx - dy * d) / d2;
    var cx1 = (s * dy + dx * d) / d2;
    var cy1 = (-s * dx + dy * d) / d2;
    var dx0 = cx0 - x00;
    var dy0 = cy0 - y00;
    var dx1 = cx1 - x00;
    var dy1 = cy1 - y00;
    // Pick the closer of the two intersection points
    // TODO: Is there a faster way to determine which intersection to use?
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
      cx0 = cx1;
      cy0 = cy1;
    }
    return {
      cx: cx0,
      cy: cy0,
      x0: -ox,
      y0: -oy,
      x1: cx0 * (radius / r - 1),
      y1: cy0 * (radius / r - 1)
    };
  }
  function computeArcSweep$1(startAngle, endAngle, clockwise) {
    if (clockwise === void 0) {
      clockwise = true;
    }
    if (!clockwise) {
      var replaceAngle = endAngle;
      endAngle = startAngle;
      startAngle = replaceAngle;
    }
    endAngle = endAngle - startAngle < 0 ? endAngle + PI2 : endAngle;
    return Math.abs(endAngle - startAngle) % PI2 <= PI ? 0 : 1;
  }
  var Sector = /** @class */function (_super) {
    __extends(Sector, _super);
    function Sector(config) {
      var _this = _super.call(this, config) || this;
      _this.updatePath();
      return _this;
    }
    Sector.prototype.setAttribute = function (name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (['startAngle', 'endAngle', 'r', 'r0', 'radius', 'cx', 'cy'].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    Sector.prototype.updatePath = function () {
      var _a = this.parsedStyle,
        cx = _a.cx,
        cy = _a.cy,
        startAngle = _a.startAngle,
        endAngle = _a.endAngle,
        r = _a.r,
        r0 = _a.r0,
        radius = _a.radius,
        _b = _a.anticlockwise,
        anticlockwise = _b === void 0 ? false : _b;
      if (isNil(startAngle) || isNil(endAngle) || startAngle === endAngle || isNil(r) || r <= 0) {
        return;
      }
      var path = this.createPath(cx, cy, deg2rad(startAngle), deg2rad(endAngle), r, r0 ? r0 : 0, radius ? radius : [0, 0, 0, 0], anticlockwise);
      _super.prototype.setAttribute.call(this, 'path', path);
    };
    Sector.prototype.createPath = function (x, y, startAngle, endAngle, r, r0, borderRadius, anticlockwise) {
      var start = polarToCartesian(x, y, r, startAngle);
      var end = polarToCartesian(x, y, r, endAngle);
      var innerStart = polarToCartesian(x, y, r0, startAngle);
      var innerEnd = polarToCartesian(x, y, r0, endAngle);
      var clockwise = !anticlockwise;
      var angle = clockwise ? endAngle - startAngle : startAngle - endAngle;
      // 
      if (Math.abs(angle) >= PI2 || isNumberEqual(Math.abs(angle), PI2)) {
        // 
        var middlePoint = polarToCartesian(x, y, r, startAngle + Math.PI);
        var innerMiddlePoint = polarToCartesian(x, y, r0, startAngle + Math.PI);
        var circlePathCommands = [['M', start.x, start.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, middlePoint.x, middlePoint.y], ['A', r, r, 0, 1, clockwise ? 1 : 0, end.x, end.y]];
        if (r0 > 0) {
          circlePathCommands.push(['M', innerStart.x, innerStart.y]);
          circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerMiddlePoint.x, innerMiddlePoint.y]);
          circlePathCommands.push(['A', r0, r0, 0, 1, clockwise ? 0 : 1, innerEnd.x, innerEnd.y]);
        }
        circlePathCommands.push(['M', start.x, start.y]);
        circlePathCommands.push(['Z']);
        return circlePathCommands;
      }
      var xrs = r * mathCos(startAngle);
      var yrs = r * mathSin(startAngle);
      var xire = r0 * mathCos(endAngle);
      var yire = r0 * mathSin(endAngle);
      var xre = r * mathCos(endAngle);
      var yre = r * mathSin(endAngle);
      var xirs = r0 * mathCos(startAngle);
      var yirs = r0 * mathSin(startAngle);
      //  radius
      var outStartRadius = borderRadius[0],
        outEndRadius = borderRadius[1],
        innerEndRadius = borderRadius[2],
        innerStartRadius = borderRadius[3];
      var halfRadius = (r - r0) / 2;
      var outStartBorderRadius = mathMin(halfRadius, outStartRadius);
      var outEndBorderRadius = mathMin(halfRadius, outEndRadius);
      var innerEndBorderRadius = mathMin(halfRadius, innerEndRadius);
      var innerStartBorderRadius = mathMin(halfRadius, innerStartRadius);
      var outBorderRadiusMax = mathMax(outStartBorderRadius, outEndBorderRadius);
      var innerBorderRadiusMax = mathMax(innerEndBorderRadius, innerStartBorderRadius);
      var limitedOutBorderRadiusMax = outBorderRadiusMax;
      var limitedInnerBorderRadiusMax = innerBorderRadiusMax;
      // draw corner radius
      if (outBorderRadiusMax > e || innerBorderRadiusMax > e) {
        // restrict the max value of corner radius
        if (angle < PI) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOutBorderRadiusMax = mathMin(outBorderRadiusMax, (r - b) / (a + 1));
            limitedInnerBorderRadiusMax = mathMin(innerBorderRadiusMax, (r0 - b) / (a - 1));
          }
        }
      }
      var arcSweep = computeArcSweep$1(startAngle, endAngle, clockwise);
      var sectorPathCommands = [];
      if (limitedOutBorderRadiusMax > e) {
        var crStart = mathMin(outStartRadius, limitedOutBorderRadiusMax);
        var crEnd = mathMin(outEndRadius, limitedOutBorderRadiusMax);
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, r, crStart, clockwise);
        var ct1 = computeCornerTangents(xre, yre, xire, yire, r, crEnd, clockwise);
        sectorPathCommands.push(['M', x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        // Have the corners merged?
        if (limitedOutBorderRadiusMax < outBorderRadiusMax && crStart === crEnd) {
          var outStartBorderRadiusStartAngle = mathATan2(ct0.cy + ct0.y0, ct0.cx + ct0.x0);
          var outStartBorderRadiusEndAngle = mathATan2(ct1.cy + ct1.y0, ct1.cx + ct1.x0);
          sectorPathCommands.push(['A', limitedOutBorderRadiusMax, limitedOutBorderRadiusMax, 0, computeArcSweep$1(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, !clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          // draw the two corners and the ring
          if (crStart > 0) {
            var outStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var outStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            var outStartBorderRadiusEndPoint = polarToCartesian(x, y, r, outStartBorderRadiusEndAngle);
            sectorPathCommands.push(['A', crStart, crStart, 0, computeArcSweep$1(outStartBorderRadiusStartAngle, outStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, outStartBorderRadiusEndPoint.x, outStartBorderRadiusEndPoint.y]);
          }
          var outRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var outRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var outRadiusEndPoint = polarToCartesian(x, y, r, outRadiusEndAngle);
          sectorPathCommands.push(['A', r, r, 1, computeArcSweep$1(outRadiusStartAngle, outRadiusEndAngle, clockwise), clockwise ? 1 : 0, outRadiusEndPoint.x, outRadiusEndPoint.y]);
          if (crEnd > 0) {
            var outEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var outEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(['A', crEnd, crEnd, 0, computeArcSweep$1(outEndBorderRadiusStartAngle, outEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      } else {
        sectorPathCommands.push(['M', start.x, start.y]);
        sectorPathCommands.push(['A', r, r, 0, arcSweep, clockwise ? 1 : 0, end.x, end.y]);
      }
      // no inner ring, is a circular sector
      if (r0 < e) {
        sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
      } else if (limitedInnerBorderRadiusMax > e) {
        var crStart = mathMin(innerStartRadius, limitedInnerBorderRadiusMax);
        var crEnd = mathMin(innerEndRadius, limitedInnerBorderRadiusMax);
        var ct0 = computeCornerTangents(0, 0, xire, yire, r0, -crEnd, clockwise);
        var ct1 = computeCornerTangents(xirs, yirs, 0, 0, r0, -crStart, clockwise);
        sectorPathCommands.push(['L', x + ct0.cx + ct0.x0, y + ct0.cy + ct0.y0]);
        // Have the corners merged?
        if (limitedInnerBorderRadiusMax < innerBorderRadiusMax && crStart === crEnd) {
          var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
          var innerStartBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
          sectorPathCommands.push(['A', limitedInnerBorderRadiusMax, limitedInnerBorderRadiusMax, 0, computeArcSweep$1(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle), 1, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
        } else {
          // draw the two corners and the ring
          if (crEnd > 0) {
            var innerStartBorderRadiusStartAngle = mathATan2(ct0.y0, ct0.x0);
            var innerStartBorderRadiusEndAngle = mathATan2(ct0.y1, ct0.x1);
            sectorPathCommands.push(['A', crEnd, crEnd, 0, computeArcSweep$1(innerStartBorderRadiusStartAngle, innerStartBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct0.cx + ct0.x1, y + ct0.cy + ct0.y1]);
          }
          var innerRadiusStartAngle = mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1);
          var innerRadiusEndAngle = mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1);
          var innerRadiusEndPoint = polarToCartesian(x, y, r0, innerRadiusEndAngle);
          sectorPathCommands.push(['A', r0, r0, 0, computeArcSweep$1(innerRadiusEndAngle, innerRadiusStartAngle, clockwise), clockwise ? 0 : 1, innerRadiusEndPoint.x, innerRadiusEndPoint.y]);
          if (crStart > 0) {
            var innerEndBorderRadiusStartAngle = mathATan2(ct1.y1, ct1.x1);
            var innerEndBorderRadiusEndAngle = mathATan2(ct1.y0, ct1.x0);
            sectorPathCommands.push(['A', crStart, crStart, 0, computeArcSweep$1(innerEndBorderRadiusStartAngle, innerEndBorderRadiusEndAngle, clockwise), clockwise ? 1 : 0, x + ct1.cx + ct1.x0, y + ct1.cy + ct1.y0]);
          }
        }
      }
      // the inner ring is just a circular arc
      else {
        sectorPathCommands.push(['L', innerEnd.x, innerEnd.y]);
        sectorPathCommands.push(['A', r0, r0, 0, arcSweep, clockwise ? 0 : 1, innerStart.x, innerStart.y]);
      }
      sectorPathCommands.push(['Z']);
      return sectorPathCommands;
    };
    return Sector;
  }(Path);

  /**
   * @fileOverview convert the line to curve
   * @author dxq613@gmail.com
   */
  function getPoint$1(v) {
    return [v.x, v.y];
  }
  function smoothBezier(points, smooth, isLoop, constraint) {
    var cps = [];
    var prevPoint;
    var nextPoint;
    var hasConstraint = !!constraint;
    var min$1;
    var max$1;
    var point;
    var len;
    var l;
    var i;
    if (hasConstraint) {
      min$1 = [Infinity, Infinity];
      max$1 = [-Infinity, -Infinity];
      for (i = 0, l = points.length; i < l; i++) {
        point = getPoint$1(points[i]);
        min(min$1, min$1, point);
        max(max$1, max$1, point);
      }
      min(min$1, min$1, constraint[0]);
      max(max$1, max$1, constraint[1]);
    }
    for (i = 0, len = points.length; i < len; i++) {
      point = getPoint$1(points[i]);
      if (isLoop) {
        prevPoint = getPoint$1(points[i ? i - 1 : len - 1]);
        nextPoint = getPoint$1(points[(i + 1) % len]);
      } else {
        if (i === 0 || i === len - 1) {
          cps.push([point[0], point[1]]);
          continue;
        } else {
          prevPoint = getPoint$1(points[i - 1]);
          nextPoint = getPoint$1(points[i + 1]);
        }
      }
      var v = sub$1([], nextPoint, prevPoint);
      scale$2(v, v, smooth);
      var d0 = distance(point, prevPoint);
      var d1 = distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$2([], v, -d0);
      var v2 = scale$2([], v, d1);
      var cp0 = add$2([], point, v1);
      var cp1 = add$2([], point, v2);
      if (hasConstraint) {
        max(cp0, cp0, min$1);
        min(cp0, cp0, max$1);
        max(cp1, cp1, min$1);
        min(cp1, cp1, max$1);
      }
      cps.push([cp0[0], cp0[1]]);
      cps.push([cp1[0], cp1[1]]);
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2bezier(pointList, z, constraint) {
    var isLoop = !!z;
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p;
    for (var i = 0; i < len - 1; i++) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p = pointList[i + 1];
      d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
    }
    if (isLoop) {
      cp1 = controlPointList[len];
      cp2 = controlPointList[len + 1];
      p = pointList[0];
      d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);
    }
    return d1;
  }

  var smooth = /*#__PURE__*/Object.freeze({
      __proto__: null,
      smooth: catmullRom2bezier
  });

  var SmoothPolyline = /** @class */function (_super) {
    __extends(SmoothPolyline, _super);
    function SmoothPolyline(config) {
      var _this = _super.call(this, config) || this;
      _this.updatePath();
      return _this;
    }
    SmoothPolyline.prototype.setAttribute = function (name, value, force) {
      _super.prototype.setAttribute.call(this, name, value, force);
      if (['smooth', 'points'].indexOf(name) > -1) {
        this.updatePath();
      }
    };
    SmoothPolyline.prototype.updatePath = function () {
      var _a = this.parsedStyle,
        smooth$1 = _a.smooth,
        points = _a.points;
      var pos = points.points;
      var d = [['M', pos[0][0], pos[0][1]]];
      if (smooth$1) {
        var constaint = [[0, 0], [1, 1]];
        var sps = catmullRom2bezier(pos.map(function (d) {
          return {
            x: d[0],
            y: d[1]
          };
        }), false, constaint);
        for (var i = 0, n = sps.length; i < n; i++) {
          var sp = sps[i];
          d.push(['C', sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);
        }
      } else {
        var i = void 0;
        var l = void 0;
        for (i = 1, l = pos.length - 1; i < l; i++) {
          d.push(['L', pos[i][0], pos[i][1]]);
        }
        d.push(['L', pos[l][0], pos[l][1]]);
      }
      _super.prototype.setAttribute.call(this, 'path', d);
    };
    SmoothPolyline.tag = 'smooth-polyline';
    return SmoothPolyline;
  }(Path);

  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1(o, p);
  }
  function _assertThisInitialized$1(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }

  var clock = typeof performance === 'object' && performance.now ? performance : Date;
  var PRESS_DELAY = 250;
  // 
  var calcDirection = function calcDirection(start, end) {
    var xDistance = end.x - start.x;
    var yDistance = end.y - start.y;
    // x y 
    if (Math.abs(xDistance) > Math.abs(yDistance)) {
      return xDistance > 0 ? 'right' : 'left';
    }
    return yDistance > 0 ? 'down' : 'up';
  };
  // 2
  var calcDistance = function calcDistance(point1, point2) {
    var xDistance = Math.abs(point2.x - point1.x);
    var yDistance = Math.abs(point2.y - point1.y);
    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  };
  var getCenter = function getCenter(point1, point2) {
    var x = point1.x + (point2.x - point1.x) / 2;
    var y = point1.y + (point2.y - point1.y) / 2;
    return {
      x: x,
      y: y
    };
  };
  var Gesture = /*#__PURE__*/function (_EE) {
    _inheritsLoose$1(Gesture, _EE);
    // 

    function Gesture(el) {
      var _this;
      _this = _EE.call(this) || this;
      _this.el = void 0;
      _this.evCache = [];
      _this.startTime = void 0;
      _this.pressTimeout = void 0;
      _this.startPoints = [];
      _this.processEvent = {};
      _this.startDistance = void 0;
      _this.center = void 0;
      _this.eventType = void 0;
      _this.direction = void 0;
      _this.lastMoveTime = void 0;
      _this.prevMovePoint = void 0;
      _this.prevMoveTime = void 0;
      _this.lastMovePoint = void 0;
      _this.throttleTimer = 0;
      _this.emitThrottles = [];
      _this._start = function (ev) {
        // 
        _this.reset();
        // touch start 
        _this.startTime = clock.now();
        var _assertThisInitialize = _assertThisInitialized$1(_this),
          evCache = _assertThisInitialize.evCache,
          startPoints = _assertThisInitialize.startPoints;
        if (ev) {
          var pointerId = ev.pointerId,
            x = ev.x,
            y = ev.y;
          evCache.push({
            pointerId: pointerId,
            x: x,
            y: y,
            ev: ev
          });
        }
        //  startPoints
        startPoints.length = evCache.length;
        for (var i = 0; i < evCache.length; i++) {
          var _evCache$i = evCache[i],
            _x = _evCache$i.x,
            _y = _evCache$i.y;
          var point = {
            x: _x,
            y: _y
          };
          startPoints[i] = point;
        }
        // 
        if (startPoints.length === 1) {
          var event = evCache[0].ev;
          // touchstart250ms, press
          // @ts-ignore
          _this.pressTimeout = setTimeout(function () {
            // press
            var eventType = 'press';
            var direction = 'none';
            event.direction = direction;
            event.deltaX = 0;
            event.deltaY = 0;
            event.points = startPoints;
            _this.emitStart(eventType, event);
            _this.emit(eventType, event);
            _this.eventType = eventType;
            _this.direction = direction;
          }, PRESS_DELAY);
          return;
        }
        // 
        _this.startDistance = calcDistance(startPoints[0], startPoints[1]);
        _this.center = getCenter(startPoints[0], startPoints[1]);
      };
      _this._move = function (ev) {
        _this.clearPressTimeout();
        var _assertThisInitialize2 = _assertThisInitialized$1(_this),
          startPoints = _assertThisInitialize2.startPoints,
          evCache = _assertThisInitialize2.evCache;
        if (!startPoints.length) return;
        var x = ev.x,
          y = ev.y,
          pointerId = ev.pointerId;
        var isTriggerStart = false;
        // Find this event in the cache and update its record with this event
        for (var i = 0, len = evCache.length; i < len; i++) {
          if (pointerId === evCache[i].pointerId) {
            evCache[i] = {
              pointerId: pointerId,
              x: x,
              y: y,
              ev: ev
            };
            isTriggerStart = true;
            break;
          }
        }
        // start startPointsstart
        if (!isTriggerStart) {
          var _point = {
            x: x,
            y: y
          };
          startPoints.push(_point);
          evCache.push({
            pointerId: pointerId,
            x: x,
            y: y,
            ev: ev
          });
          // 
          _this.startDistance = calcDistance(startPoints[0], startPoints[1]);
          _this.center = getCenter(startPoints[0], startPoints[1]);
        }
        var point = {
          x: x,
          y: y
        };
        var points = evCache.map(function (ev) {
          return {
            x: ev.x,
            y: ev.y
          };
        });
        // 2moveswipe
        var now = clock.now();
        _this.prevMoveTime = _this.lastMoveTime;
        _this.prevMovePoint = _this.lastMovePoint;
        _this.lastMoveTime = now;
        _this.lastMovePoint = point;
        if (startPoints.length === 1) {
          var startPoint = startPoints[0];
          var deltaX = x - startPoint.x;
          var deltaY = y - startPoint.y;
          var direction = _this.direction || calcDirection(startPoint, point);
          _this.direction = direction;
          // presspan
          // press , pan
          // startmovepan, press
          var eventType = _this.getEventType(point);
          ev.direction = direction;
          ev.deltaX = deltaX;
          ev.deltaY = deltaY;
          ev.points = points;
          _this.emitStart(eventType, ev);
          _this.emit(eventType, ev);
          return;
        }
        // 
        var _assertThisInitialize3 = _assertThisInitialized$1(_this),
          startDistance = _assertThisInitialize3.startDistance;
        var currentDistance = calcDistance(points[0], points[1]);
        // 
        ev.zoom = currentDistance / startDistance;
        ev.center = _this.center;
        ev.points = points;
        // 
        _this.emitStart('pinch', ev);
        // touch  move,  move
        _this._throttleEmit('pinch', ev);
      };
      _this._end = function (ev) {
        var _assertThisInitialize4 = _assertThisInitialized$1(_this),
          evCache = _assertThisInitialize4.evCache,
          startPoints = _assertThisInitialize4.startPoints;
        var points = evCache.map(function (ev) {
          return {
            x: ev.x,
            y: ev.y
          };
        });
        ev.points = points;
        _this.emitEnd(ev);
        // 
        if (evCache.length === 1) {
          // swipe, end
          var now = clock.now();
          var lastMoveTime = _this.lastMoveTime;
          // touchmoveend
          // 100 10ms
          if (now - lastMoveTime < 100) {
            var prevMoveTime = _this.prevMoveTime || _this.startTime;
            var intervalTime = lastMoveTime - prevMoveTime;
            // 0, 
            if (intervalTime > 0) {
              var prevMovePoint = _this.prevMovePoint || startPoints[0];
              var lastMovePoint = _this.lastMovePoint || startPoints[0];
              // move
              var velocity = calcDistance(prevMovePoint, lastMovePoint) / intervalTime;
              // 0.3 hammerjs
              if (velocity > 0.3) {
                ev.velocity = velocity;
                ev.direction = calcDirection(prevMovePoint, lastMovePoint);
                _this.emit('swipe', ev);
              }
            }
          }
        }
        // remove event from cache
        for (var i = 0, len = evCache.length; i < len; i++) {
          if (evCache[i].pointerId === ev.pointerId) {
            evCache.splice(i, 1);
            startPoints.splice(i, 1);
            break;
          }
        }
        _this.reset();
        //  1 start
        if (evCache.length > 0) {
          _this._start();
        }
      };
      _this._cancel = function (ev) {
        var _assertThisInitialize5 = _assertThisInitialized$1(_this),
          evCache = _assertThisInitialize5.evCache;
        var points = evCache.map(function (ev) {
          return {
            x: ev.x,
            y: ev.y
          };
        });
        ev.points = points;
        _this.emitEnd(ev);
        _this.evCache = [];
        _this.reset();
      };
      _this.el = el;
      _this._initEvent();
      return _this;
    }
    var _proto = Gesture.prototype;
    _proto._initEvent = function _initEvent() {
      var el = this.el;
      el.addEventListener('pointerdown', this._start);
      el.addEventListener('pointermove', this._move);
      el.addEventListener('pointerup', this._end);
      el.addEventListener('pointercancel', this._cancel);
      el.addEventListener('pointerupoutside', this._end);
    };
    _proto.getEventType = function getEventType(point) {
      var eventType = this.eventType,
        startTime = this.startTime,
        startPoints = this.startPoints;
      if (eventType) {
        return eventType;
      }
      var type;
      // @ts-ignore
      var panEventListeners = this._events.pan;
      // panpress
      if (!panEventListeners) {
        type = 'press';
      } else {
        // panpress250ms, 10
        var now = clock.now();
        if (now - startTime > PRESS_DELAY && calcDistance(startPoints[0], point) < 10) {
          type = 'press';
        } else {
          type = 'pan';
        }
      }
      this.eventType = type;
      return type;
    };
    _proto.enable = function enable(eventType) {
      this.processEvent[eventType] = true;
    }
    // 
    ;
    _proto.isProcess = function isProcess(eventType) {
      return this.processEvent[eventType];
    }
    // start
    ;
    _proto.emitStart = function emitStart(type, ev) {
      if (this.isProcess(type)) {
        return;
      }
      this.enable(type);
      this.emit(type + "start", ev);
    }
    // 
    ;
    _proto._throttleEmit = function _throttleEmit(type, ev) {
      var _el$ownerDocument,
        _el$document,
        _this2 = this;
      // 
      this.pushEvent(type, ev);
      var el = this.el,
        throttleTimer = this.throttleTimer,
        emitThrottles = this.emitThrottles,
        processEvent = this.processEvent;
      if (throttleTimer) {
        return;
      }
      // @ts-ignore
      var global = ((_el$ownerDocument = el.ownerDocument) === null || _el$ownerDocument === void 0 ? void 0 : _el$ownerDocument.defaultView) || ((_el$document = el.document) === null || _el$document === void 0 ? void 0 : _el$document.defaultView);
      this.throttleTimer = global.requestAnimationFrame(function () {
        for (var i = 0, len = emitThrottles.length; i < len; i++) {
          var _emitThrottles$i = emitThrottles[i],
            _type = _emitThrottles$i.type,
            _ev = _emitThrottles$i.ev;
          if (processEvent[_type]) {
            _this2.emit(_type, _ev);
          }
        }
        // 
        _this2.throttleTimer = 0;
        _this2.emitThrottles.length = 0;
      });
    }
    // end
    ;
    _proto.emitEnd = function emitEnd(ev) {
      var _this3 = this;
      var processEvent = this.processEvent;
      Object.keys(processEvent).forEach(function (type) {
        _this3.emit(type + "end", ev);
        delete processEvent[type];
      });
    };
    _proto.pushEvent = function pushEvent(type, ev) {
      var emitThrottles = this.emitThrottles;
      var newEvent = {
        type: type,
        ev: ev
      };
      for (var i = 0, len = emitThrottles.length; i < len; i++) {
        if (emitThrottles[i].type === type) {
          emitThrottles.splice(i, 1, newEvent);
          return;
        }
      }
      emitThrottles.push(newEvent);
    };
    _proto.clearPressTimeout = function clearPressTimeout() {
      if (this.pressTimeout) {
        clearTimeout(this.pressTimeout);
        this.pressTimeout = null;
      }
    };
    _proto.reset = function reset() {
      this.clearPressTimeout();
      this.startTime = 0;
      this.startDistance = 0;
      this.direction = null;
      this.eventType = null;
      this.prevMoveTime = 0;
      this.prevMovePoint = null;
      this.lastMoveTime = 0;
      this.lastMovePoint = null;
    };
    return Gesture;
  }(eventemitter3);

  var G_SHAPE_EVENT = {
    click: true,
    touchstart: true,
    touchmove: true,
    touchend: true,
    touchendoutside: true,
    dragenter: true,
    dragleave: true,
    dragover: true,
    drop: true,
    dragstart: true,
    drag: true,
    dragend: true
  };
  var GESTURE_EVENT = {
    panstart: true,
    pan: true,
    panend: true,
    pressstart: true,
    press: true,
    pressend: true,
    swipe: true,
    pinchstart: true,
    pinch: true,
    pinchend: true
  };
  var Gesture$1 = /** @class */function () {
    function Gesture$1(element) {
      this.el = element;
      this.gesture = new Gesture(element);
    }
    Gesture$1.prototype.on = function (eventName, listener) {
      var _a = this,
        el = _a.el,
        gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.addEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.on(eventName, listener);
      }
    };
    Gesture$1.prototype.off = function (eventName, listener) {
      var _a = this,
        el = _a.el,
        gesture = _a.gesture;
      if (G_SHAPE_EVENT[eventName]) {
        el.removeEventListener(eventName, listener);
        return;
      }
      if (GESTURE_EVENT[eventName]) {
        gesture.off(eventName, listener);
      }
    };
    return Gesture$1;
  }();

  var SHAPE_TAG = {};
  /**
   * 
   */
  var registerTag = function registerTag(name, ShapeConstructor) {
    SHAPE_TAG[name] = ShapeConstructor;
  };
  var getTag = function getTag(type) {
    return SHAPE_TAG[type];
  };

  var EVENT_LIST = [['click', 'onClick'], ['touchstart', 'onTouchStart'], ['touchmove', 'onTouchMove'], ['touchend', 'onTouchEnd'], ['touchendoutside', 'onTouchEndOutside'],
  // drage 
  ['dragenter', 'onDragEnter'], ['dragleave', 'onDragLeave'], ['dragover', 'onDragOver'], ['drop', 'onDrop'], ['dragstart', 'onDragStart'], ['drag', 'onDrag'], ['dragend', 'onDragEnd'],
  // pan
  ['panstart', 'onPanStart'], ['pan', 'onPan'], ['panend', 'onPanEnd'],
  // press
  ['pressstart', 'onPressStart'], ['press', 'onPress'], ['pressend', 'onPressEnd'],
  // swipe
  ['swipe', 'onSwipe'],
  // pinch
  ['pinchstart', 'onPinchStart'], ['pinch', 'onPinch'], ['pinchend', 'onPinchEnd']];
  // 
  var TagElements = [['group', Rect], ['text', Text], ['circle', Circle], ['path', Path], ['ellipse', Ellipse], ['rect', Rect], ['image', Image], ['line', Line], ['polyline', SmoothPolyline], ['polygon', Polygon], ['arc', Arc], ['marker', Marker], ['sector', Sector]];
  TagElements.map(function (_a) {
    var type = _a[0],
      ShapeClass = _a[1];
    registerTag(type, ShapeClass);
  });
  //  css  r width
  var SECTOR_CSS_PROPERTY = [{
    name: 'r0',
    inherits: false,
    interpolable: true,
    syntax: PropertySyntax.LENGTH_PERCENTAGE
  }, {
    name: 'startAngle',
    inherits: false,
    interpolable: true,
    syntax: PropertySyntax.ANGLE
  }, {
    name: 'endAngle',
    inherits: false,
    interpolable: true,
    syntax: PropertySyntax.ANGLE
  }];
  SECTOR_CSS_PROPERTY.forEach(function (property) {
    CSS.registerProperty(property);
  });
  function createShape(type, props) {
    if (!type) return null;
    var ShapeClass = getTag(type);
    if (!ShapeClass) return null;
    // const result = checkCSSRule(type, originStyle);
    var shape = new ShapeClass(props);
    addEvent(shape, props);
    return shape;
  }
  function addEvent(shape, props) {
    var gesture = new Gesture$1(shape);
    EVENT_LIST.forEach(function (_a) {
      var eventName = _a[0],
        handlerName = _a[1];
      if (!props[handlerName]) return;
      gesture.on(eventName, props[handlerName]);
    });
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function objToString(obj) {
    return Object.prototype.toString.call(obj);
  }
  function objectKeys(obj) {
    return Object.keys(obj);
  }
  function equal(a, b) {
    if (a === b) return true;
    if (_typeof(a) !== _typeof(b)) {
      return false;
    }
    // null  undefined
    if (a == null || b == null) {
      return false;
    }
    // NaN
    if (Number.isNaN(a) && Number.isNaN(b)) {
      return true;
    }
    if (objToString(a) !== objToString(b)) {
      return false;
    }
    // function 
    if (isFunction(a)) {
      return true;
    }
    // Number String Boolean
    if (_typeof(a) !== 'object') {
      return false;
    }
    if (isArray(a)) {
      if (a.length !== b.length) {
        return false;
      }
      for (var i = a.length - 1; i >= 0; i--) {
        if (!equal(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (!isPlainObject(a)) {
      return false;
    }
    var ka = objectKeys(a);
    var kb = objectKeys(b);
    // having the same number of owned properties (keys incorporates hasOwnProperty)
    if (ka.length !== kb.length) {
      return false;
    }
    // the same set of keys (although not necessarily the same order),
    ka.sort();
    kb.sort();
    // ~~~cheap key test
    for (var i = ka.length - 1; i >= 0; i--) {
      if (ka[i] != kb[i]) {
        return false;
      }
    }
    // equivalent values for every corresponding key, and ~~~possibly expensive deep test
    for (var i = ka.length - 1; i >= 0; i--) {
      var key = ka[i];
      if (!equal(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }

  var FunctionComponent = 0;
  var ClassComponent = 1;
  var Shape$1 = 2;
  function getWorkTag(type) {
    if (isString(type)) {
      return Shape$1;
    }
    if (type.prototype && type.prototype.isF2Component) {
      return ClassComponent;
    }
    return FunctionComponent;
  }

  //  transform  shape 
  function findClosestShapeNode(vNode) {
    var tag = vNode.tag,
      children = vNode.children;
    if (tag === Shape$1) {
      return vNode;
    }
    var shapeNode;
    Children.map(children, function (child) {
      if (shapeNode) return;
      shapeNode = findClosestShapeNode(child);
    });
    return shapeNode;
  }

  function applyStyle(shape, style) {
    if (!style) return;
    Object.keys(style).forEach(function (key) {
      //  clip  offset
      if (key === 'clip' || key === 'offset') {
        var effect = style[key];
        // value  ref
        if (isDisplayObject(effect === null || effect === void 0 ? void 0 : effect.current)) {
          shape.setAttribute("".concat(key, "Path"), effect.current);
          return;
        }
        var effectConfig = isFunction(effect) ? effect(style) : effect;
        if (effectConfig) {
          var type = effectConfig.type,
            style_1 = effectConfig.style;
          var effectShape = createShape(type, {
            style: style_1
          });
          shape.setAttribute("".concat(key, "Path"), effectShape);
        }
      } else {
        shape.setAttribute(key, style[key]);
      }
    });
  }

  var Animator = /** @class */function (_super) {
    __extends(Animator, _super);
    function Animator() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Animator.prototype.animate = function (shape, start, end, effect) {
      this.shape = shape;
      this.start = start;
      this.end = end;
      this.effect = effect;
    };
    // 
    Animator.prototype.loadPlay = function () {
      var _a = this,
        shape = _a.shape,
        start = _a.start,
        end = _a.end,
        effect = _a.effect,
        children = _a.children;
      var animations = [];
      if (effect) {
        var _b = effect.property,
          property = _b === void 0 ? [] : _b,
          easing = effect.easing,
          duration = effect.duration,
          delay = effect.delay,
          iterations = effect.iterations,
          clip = effect.clip,
          _c = effect.onFrame,
          onFrame = _c === void 0 ? function () {} : _c,
          _d = effect.onEnd,
          onEnd = _d === void 0 ? function () {} : _d;
        // shape 
        if (property.length && duration > 0) {
          // 
          var style = __assign(__assign({}, omit(start, property)), omit(end, property));
          applyStyle(shape, style);
          // 
          var keyframeStart = property.reduce(function (prev, cur) {
            prev[cur] = start[cur];
            return prev;
          }, {});
          // 
          var keyframeEnd = pick(end, property);
          var animation = shape.animate([keyframeStart, keyframeEnd], {
            fill: 'both',
            easing: easing,
            duration: duration,
            delay: delay,
            iterations: iterations
          });
          if (animation) {
            animation.onframe = onFrame;
            animation.onfinish = onEnd;
            // 
            if (iterations !== Infinity) {
              animations.push(animation);
            }
            this.animation = animation;
          } else {
            // 
            applyStyle(shape, end);
          }
        } else {
          // 
          applyStyle(shape, end);
        }
        // clip 
        if (clip) {
          var clipConfig = isFunction(clip) ? clip(end) : clip;
          if (clipConfig) {
            var clipType = clipConfig.type,
              clipStyle = clipConfig.style,
              _e = clipConfig.property,
              clipProperty = _e === void 0 ? [] : _e,
              clipEasing = clipConfig.easing,
              clipDuration = clipConfig.duration,
              clipDelay = clipConfig.delay,
              clipIterations = clipConfig.iterations,
              clipStart = clipConfig.start,
              clipEnd = clipConfig.end;
            if (clipProperty.length && (clipDuration || duration) > 0) {
              var clipStartStyle_1 = __assign(__assign({}, clipStyle), clipStart);
              var clipEndStyle = __assign(__assign({}, clipStyle), clipEnd);
              // 
              var clipKeyframeStart = clipProperty.reduce(function (prev, cur) {
                prev[cur] = clipStartStyle_1[cur];
                return prev;
              }, {});
              // 
              var clipKeyframeEnd = pick(clipEndStyle, clipProperty);
              var clipShape_1 = createShape(clipType, {
                style: clipStartStyle_1
              });
              shape.setAttribute('clipPath', clipShape_1);
              // g  clip  clipcanvas
              shape.ownerDocument.documentElement.appendChild(clipShape_1);
              var clipAnimation = clipShape_1.animate([clipKeyframeStart, clipKeyframeEnd], {
                fill: 'both',
                easing: clipEasing || easing,
                duration: clipDuration || duration,
                delay: clipDelay || delay,
                iterations: clipIterations || iterations
              });
              // 
              if (clipAnimation) {
                var clipFinished = clipAnimation.finished;
                this.animation = clipAnimation;
                clipFinished.then(function () {
                  //  clip
                  shape.setAttribute('clipPath', null);
                  clipShape_1.destroy();
                });
                if ((clipIterations || iterations) !== Infinity) {
                  animations.push(clipAnimation);
                }
              } else {
                //  clip
                shape.setAttribute('clipPath', null);
                clipShape_1.destroy();
              }
            }
          }
        }
      }
      if (children && children.length) {
        children.forEach(function (child) {
          if (!child) return;
          var childAnimator = child.loadPlay();
          if (childAnimator) {
            animations.push.apply(animations, childAnimator);
          }
        });
      }
      this.endEmit(animations);
      return animations;
    };
    Animator.prototype.pause = function () {
      var _a = this,
        children = _a.children,
        animation = _a.animation;
      if (animation) {
        animation.pause();
      }
      if (children && children.length) {
        children.forEach(function (child) {
          if (!child) return;
          child.pause();
        });
      }
    };
    Animator.prototype.endEmit = function (animations) {
      var _this = this;
      if (!animations.length) {
        this.emit('end');
        return null;
      }
      var finished = Promise.all(animations.map(function (d) {
        return d.finished;
      }));
      finished.then(function () {
        _this.emit('end');
      });
    };
    Animator.prototype.play = function () {
      var _a = this,
        children = _a.children,
        animation = _a.animation;
      if (animation) {
        animation.play();
      }
      if (children && children.length) {
        children.forEach(function (child) {
          if (!child) return;
          child.play();
        });
      }
    };
    Animator.prototype.reset = function (shape) {
      this.shape = shape;
      this.start = null;
      this.end = null;
      this.effect = null;
      this.children = null;
    };
    return Animator;
  }(eventemitter3);

  function findAllShapeNode(vNode) {
    var shapeNodes = [];
    Children.map(vNode, function (node) {
      if (!node) return;
      var tag = node.tag,
        type = node.type,
        children = node.children;
      if (tag === Shape$1 && type !== 'group') {
        shapeNodes.push(node);
      }
      if (children) {
        shapeNodes.push.apply(shapeNodes, findAllShapeNode(children));
      }
    });
    return shapeNodes;
  }
  function morphShape(lastNode, nextNode, animator) {
    var nextProps = nextNode.props,
      nextShape = nextNode.shape,
      nextStyle = nextNode.style;
    var lastShape = lastNode.shape,
      lastStyle = lastNode.style;
    //  shape 
    lastShape.destroy();
    var animate = nextProps.animate,
      animation = nextProps.animation;
    var animationEffect = animation ? animation.update : null;
    if (animate === false || !animationEffect) {
      return animator;
    }
    animator = animator || new Animator();
    // shape 
    var start = animationEffect.start,
      end = animationEffect.end,
      _a = animationEffect.property,
      property = _a === void 0 ? [] : _a;
    var nextParsedStyle = nextShape.parsedStyle;
    var lastParsedStyle = lastShape.parsedStyle;
    var lastPath = convertToPath(lastShape);
    var nextPath = convertToPath(nextShape);
    var startStyle = __assign(__assign(__assign({}, lastStyle), start), {
      path: lastPath
    });
    var endStyle = __assign(__assign(__assign({}, nextStyle), end), {
      path: nextPath
    });
    var pathShape = createShape('path', {
      style: __assign(__assign({}, startStyle), {
        path: ''
      })
    });
    // 
    var animateProperty = property.filter(function (key) {
      return nextParsedStyle.hasOwnProperty(key) && lastParsedStyle.hasOwnProperty(key);
    }).concat('path');
    animator.animate(pathShape, startStyle, endStyle, __assign(__assign({}, animationEffect), {
      property: animateProperty
    }));
    animator.once('end', function () {
      applyStyle(nextShape, endStyle);
      pathShape.replaceWith(nextShape);
    });
    return animator;
  }
  function appearAnimation(vNode) {
    return Children.map(vNode, function (node) {
      if (!node) return;
      var tag = node.tag,
        shape = node.shape,
        style = node.style,
        children = node.children,
        animate = node.animate,
        props = node.props,
        animator = node.animator;
      animator.reset(shape);
      // 
      animator.children = children ? createAnimation(node, children, null) : null;
      // 
      if (animate === false || tag !== Shape$1) {
        applyStyle(shape, style);
        return animator;
      }
      var animation = props.animation;
      var animationEffect = animation ? animation.appear : null;
      if (!animationEffect) {
        // 
        applyStyle(shape, style);
        return animator;
      }
      var _a = animationEffect.start,
        start = _a === void 0 ? {} : _a,
        end = animationEffect.end;
      var endStyle = __assign(__assign({}, style), end);
      animator.animate(shape, start, endStyle, animationEffect);
      return animator;
    });
  }
  function updateAnimation(nextNode, lastNode) {
    var nextTag = nextNode.tag,
      nextType = nextNode.type,
      nextStyle = nextNode.style,
      nextChildren = nextNode.children,
      nextProps = nextNode.props,
      nextShape = nextNode.shape,
      animator = nextNode.animator,
      animate = nextNode.animate;
    var lastTag = lastNode.tag,
      lastType = lastNode.type,
      lastStyle = lastNode.style,
      lastChildren = lastNode.children,
      lastShape = lastNode.shape;
    animator.reset(nextShape);
    // 
    animator.children = createAnimation(nextNode, nextChildren, lastChildren);
    var animation = nextProps.animation;
    var animationEffect = animation ? animation.update : null;
    // 
    if (nextType === lastType) {
      // 
      var resetStyle = lastStyle ? Object.keys(lastStyle).reduce(function (prev, cur) {
        prev[cur] = '';
        return prev;
      }, {}) : null;
      // 
      var style = __assign(__assign({}, resetStyle), nextStyle);
      // 
      if (nextTag !== Shape$1) {
        applyStyle(nextShape, style);
        return animator;
      }
      // 
      if (animate === false || !animationEffect) {
        applyStyle(nextShape, style);
        return animator;
      }
      var start = animationEffect.start,
        end = animationEffect.end;
      var startStyle = __assign(__assign({}, lastStyle), start);
      var endStyle = __assign(__assign({}, style), end);
      animator.animate(nextShape, startStyle, endStyle, animationEffect);
      return animator;
    }
    // 
    if (nextTag !== Shape$1 || lastTag !== Shape$1) {
      lastShape.destroy();
      return animator;
    }
    //  shape  group
    if (nextType === 'group') {
      var shapeNodes = findAllShapeNode(nextNode.children);
      return shapeNodes.map(function (node) {
        return morphShape(lastNode, node);
      });
    }
    //  group  shape
    if (lastType === 'group') {
      var shapeNodes = findAllShapeNode(lastNode.children);
      return shapeNodes.map(function (node) {
        return morphShape(node, nextNode);
      });
    }
    // 
    if (animate === false || !animationEffect) {
      applyStyle(nextShape, nextStyle);
      return animator;
    }
    return morphShape(lastNode, nextNode, animator);
  }
  function destroyAnimation(node) {
    return Children.map(node, function (vNode) {
      if (!vNode) return null;
      var tag = vNode.tag,
        shape = vNode.shape,
        children = vNode.children,
        animate = vNode.animate,
        style = vNode.style,
        props = vNode.props,
        animator = vNode.animator;
      if (shape.destroyed) {
        return null;
      }
      // 
      animator.reset(shape);
      // 
      var childrenAnimation = children ? Children.toArray(children).map(function (child) {
        return destroyAnimation(child);
      }).filter(Boolean) : null;
      // 
      if (animate === false) {
        shape.destroy();
        return animator;
      }
      var animation = props.animation;
      var animationEffect = animation ? animation.leave : null;
      //  
      if (!(childrenAnimation && childrenAnimation.length) && !animationEffect) {
        shape.destroy();
        return animator;
      }
      animator.children = childrenAnimation;
      // 
      if (animationEffect && tag === Shape$1) {
        var start = animationEffect.start,
          _a = animationEffect.end,
          end = _a === void 0 ? {} : _a;
        var startStyle = __assign(__assign({}, style), start);
        var endStyle = end;
        animator.animate(shape, startStyle, endStyle, animationEffect);
      }
      // 
      animator.once('end', function () {
        shape.destroy();
      });
      return animator;
    });
  }
  function createAnimator(nextNode, lastNode) {
    if (!nextNode && !lastNode) {
      return null;
    }
    // delete 
    if (!nextNode && lastNode) {
      return destroyAnimation(lastNode);
    }
    //  transform  transform 
    var transform = nextNode.transform;
    if (transform) {
      var closestShapeNode = findClosestShapeNode(nextNode);
      nextNode.transform = null;
      closestShapeNode.transform = transform;
    }
    if (nextNode.transform) {
      if (!lastNode) {
        return updateAnimation(nextNode, nextNode.transform);
      }
      return [updateAnimation(nextNode, nextNode.transform), destroyAnimation(lastNode)];
    }
    // appear 
    if (nextNode && !lastNode) {
      return appearAnimation(nextNode);
    }
    // update 
    return updateAnimation(nextNode, lastNode);
  }
  function insertShape(parent, shape, nextSibling) {
    if (nextSibling) {
      parent.insertBefore(shape, nextSibling);
    } else {
      parent.appendChild(shape);
    }
  }
  function createAnimation(parent, nextChildren, lastChildren) {
    if (!nextChildren && !lastChildren) {
      return;
    }
    var parentShape = parent.shape;
    // 
    var prevSibling;
    var childrenAnimator = [];
    Children.compare(nextChildren, lastChildren, function (nextNode, lastNode) {
      // shape 
      var animator = createAnimator(nextNode, lastNode);
      Children.map(animator, function (item) {
        if (!item) return;
        childrenAnimator.push(item);
        var shape = item.shape;
        if (!shape || shape.destroyed) return;
        var nextSibling;
        // 
        if (!prevSibling) {
          nextSibling = parentShape.firstChild;
        } else {
          nextSibling = prevSibling.nextSibling;
        }
        if (nextSibling !== shape) {
          insertShape(parentShape, shape, nextSibling);
        }
        prevSibling = shape;
      });
    });
    return childrenAnimator;
  }

  var rect = (function (layout) {
    var left = layout.left,
      top = layout.top,
      width = layout.width,
      height = layout.height;
    return {
      x: left,
      y: top,
      width: width,
      height: height
    };
  });

  var line$1 = (function (layout) {
    var left = layout.left,
      top = layout.top,
      width = layout.width,
      height = layout.height;
    return {
      x1: left,
      y1: top,
      x2: left + width,
      y2: top + height
    };
  });

  var text = (function (layout) {
    var height = layout.height,
      left = layout.left,
      top = layout.top;
    return {
      x: left,
      y: top + height / 2,
      // middle + top 
      textBaseline: 'middle'
    };
  });

  var circle = (function (layout) {
    var left = layout.left,
      top = layout.top,
      width = layout.width;
    var r = width / 2;
    return {
      cx: left + r,
      cy: top + r,
      r: r
    };
  });

  var marker = (function (layout) {
    var left = layout.left,
      top = layout.top,
      width = layout.width;
    var r = width / 2;
    return {
      x: left + r,
      y: top,
      radius: r
    };
  });

  var map$2 = {
    rect: rect,
    line: line$1,
    text: text,
    circle: circle,
    marker: marker,
    group: rect
  };
  var getShapeAttrs = (function (type, layout) {
    if (!layout) return null;
    var fn = map$2[type] || rect;
    return fn(layout);
  });

  /* eslint-disable */
  // @ts-nocheck
  // from css-layout
  var CSS_UNDEFINED;
  var CSS_DIRECTION_INHERIT = 'inherit';
  var CSS_DIRECTION_LTR = 'ltr';
  var CSS_DIRECTION_RTL = 'rtl';
  var CSS_FLEX_DIRECTION_ROW = 'row';
  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';
  var CSS_FLEX_DIRECTION_COLUMN = 'column';
  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';
  var CSS_JUSTIFY_FLEX_START = 'flex-start';
  var CSS_JUSTIFY_CENTER = 'center';
  var CSS_JUSTIFY_FLEX_END = 'flex-end';
  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';
  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';
  var CSS_ALIGN_FLEX_START = 'flex-start';
  var CSS_ALIGN_CENTER = 'center';
  var CSS_ALIGN_FLEX_END = 'flex-end';
  var CSS_ALIGN_STRETCH = 'stretch';
  var CSS_POSITION_RELATIVE = 'relative';
  var CSS_POSITION_ABSOLUTE = 'absolute';
  var leading = {
    row: 'left',
    'row-reverse': 'right',
    column: 'top',
    'column-reverse': 'bottom'
  };
  var trailing = {
    row: 'right',
    'row-reverse': 'left',
    column: 'bottom',
    'column-reverse': 'top'
  };
  var pos = {
    row: 'left',
    'row-reverse': 'right',
    column: 'top',
    'column-reverse': 'bottom'
  };
  var dim = {
    row: 'width',
    'row-reverse': 'width',
    column: 'height',
    'column-reverse': 'height'
  };
  // When transpiled to Java / C the node type has layout, children and style
  // properties. For the JavaScript version this function adds these properties
  // if they don't already exist.
  function fillNodes(node) {
    if (!node.layout || node.isDirty) {
      node.layout = {
        width: undefined,
        height: undefined,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      };
    }
    if (!node.style) {
      node.style = {};
    }
    if (!node.children) {
      node.children = [];
    }
    node.children.forEach(fillNodes);
    return node;
  }
  function isUndefined$1(value) {
    return value === undefined;
  }
  function isRowDirection(flexDirection) {
    return flexDirection === CSS_FLEX_DIRECTION_ROW || flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;
  }
  function isColumnDirection(flexDirection) {
    return flexDirection === CSS_FLEX_DIRECTION_COLUMN || flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;
  }
  function getLeadingMargin(node, axis) {
    if (node.style.marginStart !== undefined && isRowDirection(axis)) {
      return node.style.marginStart;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.marginLeft;
        break;
      case 'row-reverse':
        value = node.style.marginRight;
        break;
      case 'column':
        value = node.style.marginTop;
        break;
      case 'column-reverse':
        value = node.style.marginBottom;
        break;
    }
    if (value !== undefined) {
      return value;
    }
    if (node.style.margin !== undefined) {
      return node.style.margin;
    }
    return 0;
  }
  function getTrailingMargin(node, axis) {
    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {
      return node.style.marginEnd;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.marginRight;
        break;
      case 'row-reverse':
        value = node.style.marginLeft;
        break;
      case 'column':
        value = node.style.marginBottom;
        break;
      case 'column-reverse':
        value = node.style.marginTop;
        break;
    }
    if (value != null) {
      return value;
    }
    if (node.style.margin !== undefined) {
      return node.style.margin;
    }
    return 0;
  }
  function getLeadingPadding(node, axis) {
    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0 && isRowDirection(axis)) {
      return node.style.paddingStart;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.paddingLeft;
        break;
      case 'row-reverse':
        value = node.style.paddingRight;
        break;
      case 'column':
        value = node.style.paddingTop;
        break;
      case 'column-reverse':
        value = node.style.paddingBottom;
        break;
    }
    if (value != null && value >= 0) {
      return value;
    }
    if (node.style.padding !== undefined && node.style.padding >= 0) {
      return node.style.padding;
    }
    return 0;
  }
  function getTrailingPadding(node, axis) {
    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0 && isRowDirection(axis)) {
      return node.style.paddingEnd;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.paddingRight;
        break;
      case 'row-reverse':
        value = node.style.paddingLeft;
        break;
      case 'column':
        value = node.style.paddingBottom;
        break;
      case 'column-reverse':
        value = node.style.paddingTop;
        break;
    }
    if (value != null && value >= 0) {
      return value;
    }
    if (node.style.padding !== undefined && node.style.padding >= 0) {
      return node.style.padding;
    }
    return 0;
  }
  function getLeadingBorder(node, axis) {
    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0 && isRowDirection(axis)) {
      return node.style.borderStartWidth;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.borderLeftWidth;
        break;
      case 'row-reverse':
        value = node.style.borderRightWidth;
        break;
      case 'column':
        value = node.style.borderTopWidth;
        break;
      case 'column-reverse':
        value = node.style.borderBottomWidth;
        break;
    }
    if (value != null && value >= 0) {
      return value;
    }
    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
      return node.style.borderWidth;
    }
    return 0;
  }
  function getTrailingBorder(node, axis) {
    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0 && isRowDirection(axis)) {
      return node.style.borderEndWidth;
    }
    var value = null;
    switch (axis) {
      case 'row':
        value = node.style.borderRightWidth;
        break;
      case 'row-reverse':
        value = node.style.borderLeftWidth;
        break;
      case 'column':
        value = node.style.borderBottomWidth;
        break;
      case 'column-reverse':
        value = node.style.borderTopWidth;
        break;
    }
    if (value != null && value >= 0) {
      return value;
    }
    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {
      return node.style.borderWidth;
    }
    return 0;
  }
  function getLeadingPaddingAndBorder(node, axis) {
    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);
  }
  function getTrailingPaddingAndBorder(node, axis) {
    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);
  }
  function getBorderAxis(node, axis) {
    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);
  }
  function getMarginAxis(node, axis) {
    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);
  }
  function getPaddingAndBorderAxis(node, axis) {
    return getLeadingPaddingAndBorder(node, axis) + getTrailingPaddingAndBorder(node, axis);
  }
  function getJustifyContent(node) {
    if (node.style.justifyContent) {
      return node.style.justifyContent;
    }
    return 'flex-start';
  }
  function getAlignContent(node) {
    if (node.style.alignContent) {
      return node.style.alignContent;
    }
    return 'flex-start';
  }
  function getAlignItem(node, child) {
    if (child.style.alignSelf) {
      return child.style.alignSelf;
    }
    if (node.style.alignItems) {
      return node.style.alignItems;
    }
    return 'stretch';
  }
  function resolveAxis(axis, direction) {
    if (direction === CSS_DIRECTION_RTL) {
      if (axis === CSS_FLEX_DIRECTION_ROW) {
        return CSS_FLEX_DIRECTION_ROW_REVERSE;
      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {
        return CSS_FLEX_DIRECTION_ROW;
      }
    }
    return axis;
  }
  function resolveDirection(node, parentDirection) {
    var direction;
    if (node.style.direction) {
      direction = node.style.direction;
    } else {
      direction = CSS_DIRECTION_INHERIT;
    }
    if (direction === CSS_DIRECTION_INHERIT) {
      direction = parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection;
    }
    return direction;
  }
  function getFlexDirection(node) {
    if (node.style.flexDirection) {
      return node.style.flexDirection;
    }
    return CSS_FLEX_DIRECTION_COLUMN;
  }
  function getCrossFlexDirection(flexDirection, direction) {
    if (isColumnDirection(flexDirection)) {
      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
    } else {
      return CSS_FLEX_DIRECTION_COLUMN;
    }
  }
  function getPositionType(node) {
    if (node.style.position) {
      return node.style.position;
    }
    return 'relative';
  }
  function isFlex(node) {
    return getPositionType(node) === CSS_POSITION_RELATIVE && node.style.flex > 0;
  }
  function isFlexWrap(node) {
    return node.style.flexWrap === 'wrap';
  }
  function getDimWithMargin(node, axis) {
    return node.layout[dim[axis]] + getMarginAxis(node, axis);
  }
  function isDimDefined(node, axis) {
    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;
  }
  function isPosDefined(node, pos) {
    return node.style[pos] !== undefined;
  }
  function isMeasureDefined(node) {
    return node.style.measure !== undefined;
  }
  function getPosition(node, pos) {
    if (node.style[pos] !== undefined) {
      return node.style[pos];
    }
    return 0;
  }
  function boundAxis(node, axis, value) {
    var min = {
      row: node.style.minWidth,
      'row-reverse': node.style.minWidth,
      column: node.style.minHeight,
      'column-reverse': node.style.minHeight
    }[axis];
    var max = {
      row: node.style.maxWidth,
      'row-reverse': node.style.maxWidth,
      column: node.style.maxHeight,
      'column-reverse': node.style.maxHeight
    }[axis];
    var boundValue = value;
    if (max !== undefined && max >= 0 && boundValue > max) {
      boundValue = max;
    }
    if (min !== undefined && min >= 0 && boundValue < min) {
      boundValue = min;
    }
    return boundValue;
  }
  function fmaxf(a, b) {
    if (a > b) {
      return a;
    }
    return b;
  }
  // When the user specifically sets a value for width or height
  function setDimensionFromStyle(node, axis) {
    // The parent already computed us a width or height. We just skip it
    if (node.layout[dim[axis]] !== undefined) {
      return;
    }
    // We only run if there's a width or height defined
    if (!isDimDefined(node, axis)) {
      return;
    }
    // The dimensions can never be smaller than the padding and border
    node.layout[dim[axis]] = fmaxf(boundAxis(node, axis, node.style[dim[axis]]), getPaddingAndBorderAxis(node, axis));
  }
  function setTrailingPosition(node, child, axis) {
    child.layout[trailing[axis]] = node.layout[dim[axis]] - child.layout[dim[axis]] - child.layout[pos[axis]];
  }
  // If both left and right are defined, then use left. Otherwise return
  // +left or -right depending on which is defined.
  function getRelativePosition(node, axis) {
    if (node.style[leading[axis]] !== undefined) {
      return getPosition(node, leading[axis]);
    }
    return -getPosition(node, trailing[axis]);
  }
  function layoutNodeImpl(node, parentMaxWidth, /*css_direction_t*/parentDirection) {
    var /*css_direction_t*/direction = resolveDirection(node, parentDirection);
    var /*(c)!css_flex_direction_t*/ /*(java)!int*/mainAxis = resolveAxis(getFlexDirection(node), direction);
    var /*(c)!css_flex_direction_t*/ /*(java)!int*/crossAxis = getCrossFlexDirection(mainAxis, direction);
    var /*(c)!css_flex_direction_t*/ /*(java)!int*/resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);
    // Handle width and height style attributes
    setDimensionFromStyle(node, mainAxis);
    setDimensionFromStyle(node, crossAxis);
    // Set the resolved resolution in the node's layout
    node.layout.direction = direction;
    // The position is set by the parent, but we need to complete it with a
    // delta composed of the margin and left/top/right/bottom
    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) + getRelativePosition(node, mainAxis);
    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) + getRelativePosition(node, crossAxis);
    // Inline immutable values from the target node to avoid excessive method
    // invocations during the layout calculation.
    var /*int*/childCount = node.children.length;
    var /*float*/paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);
    if (isMeasureDefined(node)) {
      var /*bool*/isResolvedRowDimDefined = !isUndefined$1(node.layout[dim[resolvedRowAxis]]);
      var /*float*/width = CSS_UNDEFINED;
      if (isDimDefined(node, resolvedRowAxis)) {
        width = node.style.width;
      } else if (isResolvedRowDimDefined) {
        width = node.layout[dim[resolvedRowAxis]];
      } else {
        width = parentMaxWidth - getMarginAxis(node, resolvedRowAxis);
      }
      width -= paddingAndBorderAxisResolvedRow;
      // We only need to give a dimension for the text if we haven't got any
      // for it computed yet. It can either be from the style attribute or because
      // the element is flexible.
      var /*bool*/isRowUndefined = !isDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;
      var /*bool*/isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) && isUndefined$1(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);
      // Let's not measure the text if we already know both dimensions
      if (isRowUndefined || isColumnUndefined) {
        var /*css_dim_t*/measureDim = node.style.measure( /*(c)!node->context,*/
        /*(java)!layoutContext.measureOutput,*/
        width);
        if (isRowUndefined) {
          node.layout.width = measureDim.width + paddingAndBorderAxisResolvedRow;
        }
        if (isColumnUndefined) {
          node.layout.height = measureDim.height + getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);
        }
      }
      if (childCount === 0) {
        return;
      }
    }
    var /*bool*/isNodeFlexWrap = isFlexWrap(node);
    var /*css_justify_t*/justifyContent = getJustifyContent(node);
    var /*float*/leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);
    var /*float*/leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);
    var /*float*/paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);
    var /*float*/paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);
    var /*bool*/isMainDimDefined = !isUndefined$1(node.layout[dim[mainAxis]]);
    var /*bool*/isCrossDimDefined = !isUndefined$1(node.layout[dim[crossAxis]]);
    var /*bool*/isMainRowDirection = isRowDirection(mainAxis);
    var /*int*/i;
    var /*int*/ii;
    var /*css_node_t**/child;
    var /*(c)!css_flex_direction_t*/ /*(java)!int*/axis;
    var /*css_node_t**/firstAbsoluteChild = null;
    var /*css_node_t**/currentAbsoluteChild = null;
    var /*float*/definedMainDim = CSS_UNDEFINED;
    if (isMainDimDefined) {
      definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;
    }
    // We want to execute the next two loops one per line with flex-wrap
    var /*int*/startLine = 0;
    var /*int*/endLine = 0;
    // var/*int*/ nextOffset = 0;
    var /*int*/alreadyComputedNextLayout = 0;
    // We aggregate the total dimensions of the container in those two variables
    var /*float*/linesCrossDim = 0;
    var /*float*/linesMainDim = 0;
    var /*int*/linesCount = 0;
    while (endLine < childCount) {
      // <Loop A> Layout non flexible children and count children by type
      // mainContentDim is accumulation of the dimensions and margin of all the
      // non flexible children. This will be used in order to either set the
      // dimensions of the node if none already exist, or to compute the
      // remaining space left for the flexible children.
      var /*float*/mainContentDim = 0;
      // There are three kind of children, non flexible, flexible and absolute.
      // We need to know how many there are in order to distribute the space.
      var /*int*/flexibleChildrenCount = 0;
      var /*float*/totalFlexible = 0;
      var /*int*/nonFlexibleChildrenCount = 0;
      // Use the line loop to position children in the main axis for as long
      // as they are using a simple stacking behaviour. Children that are
      // immediately stacked in the initial loop will not be touched again
      // in <Loop C>.
      var /*bool*/isSimpleStackMain = isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START || !isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER;
      var /*int*/firstComplexMain = isSimpleStackMain ? childCount : startLine;
      // Use the initial line loop to position children in the cross axis for
      // as long as they are relatively positioned with alignment STRETCH or
      // FLEX_START. Children that are immediately stacked in the initial loop
      // will not be touched again in <Loop D>.
      var /*bool*/isSimpleStackCross = true;
      var /*int*/firstComplexCross = childCount;
      var /*css_node_t**/firstFlexChild = null;
      var /*css_node_t**/currentFlexChild = null;
      var /*float*/mainDim = leadingPaddingAndBorderMain;
      var /*float*/crossDim = 0;
      var /*float*/maxWidth;
      for (i = startLine; i < childCount; ++i) {
        child = node.children[i];
        child.lineIndex = linesCount;
        child.nextAbsoluteChild = null;
        child.nextFlexChild = null;
        var /*css_align_t*/alignItem = getAlignItem(node, child);
        // Pre-fill cross axis dimensions when the child is using stretch before
        // we call the recursive layout pass
        if (alignItem === CSS_ALIGN_STRETCH && getPositionType(child) === CSS_POSITION_RELATIVE && isCrossDimDefined && !isDimDefined(child, crossAxis)) {
          child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, node.layout[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(child, crossAxis));
        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {
          // Store a private linked list of absolutely positioned children
          // so that we can efficiently traverse them later.
          if (firstAbsoluteChild === null) {
            firstAbsoluteChild = child;
          }
          if (currentAbsoluteChild !== null) {
            currentAbsoluteChild.nextAbsoluteChild = child;
          }
          currentAbsoluteChild = child;
          // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both
          // left and right or top and bottom).
          for (ii = 0; ii < 2; ii++) {
            axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
            if (!isUndefined$1(node.layout[dim[axis]]) && !isDimDefined(child, axis) && isPosDefined(child, leading[axis]) && isPosDefined(child, trailing[axis])) {
              child.layout[dim[axis]] = fmaxf(boundAxis(child, axis, node.layout[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])),
              // You never want to go smaller than padding
              getPaddingAndBorderAxis(child, axis));
            }
          }
        }
        var /*float*/nextContentDim = 0;
        // It only makes sense to consider a child flexible if we have a computed
        // dimension for the node.
        if (isMainDimDefined && isFlex(child)) {
          flexibleChildrenCount++;
          totalFlexible += child.style.flex;
          // Store a private linked list of flexible children so that we can
          // efficiently traverse them later.
          if (firstFlexChild === null) {
            firstFlexChild = child;
          }
          if (currentFlexChild !== null) {
            currentFlexChild.nextFlexChild = child;
          }
          currentFlexChild = child;
          // Even if we don't know its exact size yet, we already know the padding,
          // border and margin. We'll use this partial information, which represents
          // the smallest possible size for the child, to compute the remaining
          // available space.
          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);
        } else {
          maxWidth = CSS_UNDEFINED;
          if (!isMainRowDirection) {
            if (isDimDefined(node, resolvedRowAxis)) {
              maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
            } else {
              maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
            }
          }
          // This is the main recursive call. We layout non flexible children.
          if (alreadyComputedNextLayout === 0) {
            layoutNode( /*(java)!layoutContext, */child, maxWidth, direction);
          }
          // Absolute positioned elements do not take part of the layout, so we
          // don't use them to compute mainContentDim
          if (getPositionType(child) === CSS_POSITION_RELATIVE) {
            nonFlexibleChildrenCount++;
            // At this point we know the final size and margin of the element.
            nextContentDim = getDimWithMargin(child, mainAxis);
          }
        }
        // The element we are about to add would make us go to the next line
        if (isNodeFlexWrap && isMainDimDefined && mainContentDim + nextContentDim > definedMainDim &&
        // If there's only one element, then it's bigger than the content
        // and needs its own line
        i !== startLine) {
          nonFlexibleChildrenCount--;
          alreadyComputedNextLayout = 1;
          break;
        }
        // Disable simple stacking in the main axis for the current line as
        // we found a non-trivial child. The remaining children will be laid out
        // in <Loop C>.
        if (isSimpleStackMain && (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {
          isSimpleStackMain = false;
          firstComplexMain = i;
        }
        // Disable simple stacking in the cross axis for the current line as
        // we found a non-trivial child. The remaining children will be laid out
        // in <Loop D>.
        if (isSimpleStackCross && (getPositionType(child) !== CSS_POSITION_RELATIVE || alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START || isUndefined$1(child.layout[dim[crossAxis]]))) {
          isSimpleStackCross = false;
          firstComplexCross = i;
        }
        if (isSimpleStackMain) {
          child.layout[pos[mainAxis]] += mainDim;
          if (isMainDimDefined) {
            setTrailingPosition(node, child, mainAxis);
          }
          mainDim += getDimWithMargin(child, mainAxis);
          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
        }
        if (isSimpleStackCross) {
          child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;
          if (isCrossDimDefined) {
            setTrailingPosition(node, child, crossAxis);
          }
        }
        alreadyComputedNextLayout = 0;
        mainContentDim += nextContentDim;
        endLine = i + 1;
      }
      // <Loop B> Layout flexible children and allocate empty space
      // In order to position the elements in the main axis, we have two
      // controls. The space between the beginning and the first element
      // and the space between each two elements.
      var /*float*/leadingMainDim = 0;
      var /*float*/betweenMainDim = 0;
      // The remaining available space that needs to be allocated
      var /*float*/remainingMainDim = 0;
      if (isMainDimDefined) {
        remainingMainDim = definedMainDim - mainContentDim;
      } else {
        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;
      }
      // If there are flexible children in the mix, they are going to fill the
      // remaining space
      if (flexibleChildrenCount !== 0) {
        var /*float*/flexibleMainDim = remainingMainDim / totalFlexible;
        var /*float*/baseMainDim;
        var /*float*/boundMainDim;
        // If the flex share of remaining space doesn't meet min/max bounds,
        // remove this child from flex calculations.
        currentFlexChild = firstFlexChild;
        while (currentFlexChild !== null) {
          baseMainDim = flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis);
          boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);
          if (baseMainDim !== boundMainDim) {
            remainingMainDim -= boundMainDim;
            totalFlexible -= currentFlexChild.style.flex;
          }
          currentFlexChild = currentFlexChild.nextFlexChild;
        }
        flexibleMainDim = remainingMainDim / totalFlexible;
        // The non flexible children can overflow the container, in this case
        // we should just assume that there is no space available.
        if (flexibleMainDim < 0) {
          flexibleMainDim = 0;
        }
        currentFlexChild = firstFlexChild;
        while (currentFlexChild !== null) {
          // At this point we know the final size of the element in the main
          // dimension
          currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild.style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis));
          maxWidth = CSS_UNDEFINED;
          if (isDimDefined(node, resolvedRowAxis)) {
            maxWidth = node.layout[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow;
          } else if (!isMainRowDirection) {
            maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow;
          }
          // And we recursively call the layout algorithm for this child
          layoutNode( /*(java)!layoutContext, */currentFlexChild, maxWidth, direction);
          child = currentFlexChild;
          currentFlexChild = currentFlexChild.nextFlexChild;
          child.nextFlexChild = null;
        }
        // We use justifyContent to figure out how to allocate the remaining
        // space available
      } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {
        if (justifyContent === CSS_JUSTIFY_CENTER) {
          leadingMainDim = remainingMainDim / 2;
        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {
          leadingMainDim = remainingMainDim;
        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {
          remainingMainDim = fmaxf(remainingMainDim, 0);
          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {
            betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1);
          } else {
            betweenMainDim = 0;
          }
        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {
          // Space on the edges is half of the space between elements
          betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount);
          leadingMainDim = betweenMainDim / 2;
        }
      }
      // <Loop C> Position elements in the main axis and compute dimensions
      // At this point, all the children have their dimensions set. We need to
      // find their position. In order to do that, we accumulate data in
      // variables that are also useful to compute the total dimensions of the
      // container!
      mainDim += leadingMainDim;
      for (i = firstComplexMain; i < endLine; ++i) {
        child = node.children[i];
        if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[mainAxis])) {
          // In case the child is position absolute and has left/top being
          // defined, we override the position to whatever the user said
          // (and margin/border).
          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis);
        } else {
          // If the child is position absolute (without top/left) or relative,
          // we put it at the current accumulated offset.
          child.layout[pos[mainAxis]] += mainDim;
          // Define the trailing position accordingly.
          if (isMainDimDefined) {
            setTrailingPosition(node, child, mainAxis);
          }
          // Now that we placed the element, we need to update the variables
          // We only need to do that for relative elements. Absolute elements
          // do not take part in that phase.
          if (getPositionType(child) === CSS_POSITION_RELATIVE) {
            // The main dimension is the sum of all the elements dimension plus
            // the spacing.
            mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);
            // The cross dimension is the max of the elements dimension since there
            // can only be one element in that cross dimension.
            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));
          }
        }
      }
      var /*float*/containerCrossAxis = node.layout[dim[crossAxis]];
      if (!isCrossDimDefined) {
        containerCrossAxis = fmaxf(
        // For the cross dim, we add both sides at the end because the value
        // is aggregate via a max function. Intermediate negative values
        // can mess this computation otherwise
        boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
      }
      // <Loop D> Position elements in the cross axis
      for (i = firstComplexCross; i < endLine; ++i) {
        child = node.children[i];
        if (getPositionType(child) === CSS_POSITION_ABSOLUTE && isPosDefined(child, leading[crossAxis])) {
          // In case the child is absolutely positionned and has a
          // top/left/bottom/right being set, we override all the previously
          // computed positions to set it correctly.
          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis);
        } else {
          var /*float*/leadingCrossDim = leadingPaddingAndBorderCross;
          // For a relative children, we're either using alignItems (parent) or
          // alignSelf (child) in order to determine the position in the cross axis
          if (getPositionType(child) === CSS_POSITION_RELATIVE) {
            // This variable is intentionally re-defined as the code is transpiled to a block scope language
            var /*css_align_t*/alignItem = getAlignItem(node, child);
            if (alignItem === CSS_ALIGN_STRETCH) {
              // You can only stretch if the dimension has not already been set
              // previously.
              if (isUndefined$1(child.layout[dim[crossAxis]])) {
                child.layout[dim[crossAxis]] = fmaxf(boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),
                // You never want to go smaller than padding
                getPaddingAndBorderAxis(child, crossAxis));
              }
            } else if (alignItem !== CSS_ALIGN_FLEX_START) {
              // The remaining space between the parent dimensions+padding and child
              // dimensions+margin.
              var /*float*/remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);
              if (alignItem === CSS_ALIGN_CENTER) {
                leadingCrossDim += remainingCrossDim / 2;
              } else {
                // CSS_ALIGN_FLEX_END
                leadingCrossDim += remainingCrossDim;
              }
            }
          }
          // And we apply the position
          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;
          // Define the trailing position accordingly.
          if (isCrossDimDefined) {
            setTrailingPosition(node, child, crossAxis);
          }
        }
      }
      linesCrossDim += crossDim;
      linesMainDim = fmaxf(linesMainDim, mainDim);
      linesCount += 1;
      startLine = endLine;
    }
    // <Loop E>
    //
    // Note(prenaux): More than one line, we need to layout the crossAxis
    // according to alignContent.
    //
    // Note that we could probably remove <Loop D> and handle the one line case
    // here too, but for the moment this is safer since it won't interfere with
    // previously working code.
    //
    // See specs:
    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm
    // section 9.4
    //
    if (linesCount > 1 && isCrossDimDefined) {
      var /*float*/nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] - paddingAndBorderAxisCross;
      var /*float*/remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;
      var /*float*/crossDimLead = 0;
      var /*float*/currentLead = leadingPaddingAndBorderCross;
      var /*css_align_t*/alignContent = getAlignContent(node);
      if (alignContent === CSS_ALIGN_FLEX_END) {
        currentLead += remainingAlignContentDim;
      } else if (alignContent === CSS_ALIGN_CENTER) {
        currentLead += remainingAlignContentDim / 2;
      } else if (alignContent === CSS_ALIGN_STRETCH) {
        if (nodeCrossAxisInnerSize > linesCrossDim) {
          crossDimLead = remainingAlignContentDim / linesCount;
        }
      }
      var /*int*/endIndex = 0;
      for (i = 0; i < linesCount; ++i) {
        var /*int*/startIndex = endIndex;
        // compute the line's height and find the endIndex
        var /*float*/lineHeight = 0;
        for (ii = startIndex; ii < childCount; ++ii) {
          child = node.children[ii];
          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
            continue;
          }
          if (child.lineIndex !== i) {
            break;
          }
          if (!isUndefined$1(child.layout[dim[crossAxis]])) {
            lineHeight = fmaxf(lineHeight, child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis));
          }
        }
        endIndex = ii;
        lineHeight += crossDimLead;
        for (ii = startIndex; ii < endIndex; ++ii) {
          child = node.children[ii];
          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {
            continue;
          }
          var /*css_align_t*/alignContentAlignItem = getAlignItem(node, child);
          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {
            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {
            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];
          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {
            var /*float*/childHeight = child.layout[dim[crossAxis]];
            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;
          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {
            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);
            // TODO(prenaux): Correctly set the height of items with undefined
            //                (auto) crossAxis dimension.
          }
        }

        currentLead += lineHeight;
      }
    }
    var /*bool*/needsMainTrailingPos = false;
    var /*bool*/needsCrossTrailingPos = false;
    // If the user didn't specify a width or height, and it has not been set
    // by the container, then we set it via the children.
    if (!isMainDimDefined) {
      node.layout[dim[mainAxis]] = fmaxf(
      // We're missing the last padding at this point to get the final
      // dimension
      boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),
      // We can never assign a width smaller than the padding and borders
      paddingAndBorderAxisMain);
      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
        needsMainTrailingPos = true;
      }
    }
    if (!isCrossDimDefined) {
      node.layout[dim[crossAxis]] = fmaxf(
      // For the cross dim, we add both sides at the end because the value
      // is aggregate via a max function. Intermediate negative values
      // can mess this computation otherwise
      boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross);
      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {
        needsCrossTrailingPos = true;
      }
    }
    // <Loop F> Set trailing position if necessary
    if (needsMainTrailingPos || needsCrossTrailingPos) {
      for (i = 0; i < childCount; ++i) {
        child = node.children[i];
        if (needsMainTrailingPos) {
          setTrailingPosition(node, child, mainAxis);
        }
        if (needsCrossTrailingPos) {
          setTrailingPosition(node, child, crossAxis);
        }
      }
    }
    // <Loop G> Calculate dimensions for absolutely positioned elements
    currentAbsoluteChild = firstAbsoluteChild;
    while (currentAbsoluteChild !== null) {
      // Pre-fill dimensions when using absolute position and both offsets for
      // the axis are defined (either both left and right or top and bottom).
      for (ii = 0; ii < 2; ii++) {
        axis = ii !== 0 ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;
        if (!isUndefined$1(node.layout[dim[axis]]) && !isDimDefined(currentAbsoluteChild, axis) && isPosDefined(currentAbsoluteChild, leading[axis]) && isPosDefined(currentAbsoluteChild, trailing[axis])) {
          currentAbsoluteChild.layout[dim[axis]] = fmaxf(boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis])),
          // You never want to go smaller than padding
          getPaddingAndBorderAxis(currentAbsoluteChild, axis));
        }
        if (isPosDefined(currentAbsoluteChild, trailing[axis]) && !isPosDefined(currentAbsoluteChild, leading[axis])) {
          currentAbsoluteChild.layout[leading[axis]] = node.layout[dim[axis]] - currentAbsoluteChild.layout[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]);
        }
      }
      child = currentAbsoluteChild;
      currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;
      child.nextAbsoluteChild = null;
    }
  }
  // margin
  function saveMargin(node) {
    var style = node.style;
    var margin = {};
    ['marginTop', 'marginRight', 'marginBottom', 'marginLeft' // marginLeft
    ].forEach(function (key) {
      // 
      var value = style[key];
      if (value && /^-?\d+%$/.test(value)) {
        margin[key] = value;
        style[key] = 0;
      }
    });
    node.margin = margin;
  }
  function percent2Num(value) {
    var percent = Number(value.substr(0, value.length - 1));
    return percent / 100;
  }
  function layoutMargin(node) {
    var margin = node.margin,
      layout = node.layout;
    Object.keys(margin).forEach(function (key) {
      var percent = percent2Num(margin[key]);
      if ((key === 'marginLeft' || key === 'marginRight') && layout.width) {
        layout.left += layout.width * percent;
      } else if ((key === 'marginTop' || key === 'marginBottom') && layout.height) {
        layout.top += layout.height * percent;
      }
    });
  }
  function layoutNode(node, parentMaxWidth, parentDirection) {
    node.shouldUpdate = true;
    // hack
    saveMargin(node);
    var direction = node.style.direction || CSS_DIRECTION_LTR;
    var skipLayout = !node.isDirty && node.lastLayout && node.lastLayout.requestedHeight === node.layout.height && node.lastLayout.requestedWidth === node.layout.width && node.lastLayout.parentMaxWidth === parentMaxWidth && node.lastLayout.direction === direction;
    if (skipLayout) {
      node.layout.width = node.lastLayout.width;
      node.layout.height = node.lastLayout.height;
      node.layout.top = node.lastLayout.top;
      node.layout.left = node.lastLayout.left;
    } else {
      if (!node.lastLayout) {
        node.lastLayout = {};
      }
      node.lastLayout.requestedWidth = node.layout.width;
      node.lastLayout.requestedHeight = node.layout.height;
      node.lastLayout.parentMaxWidth = parentMaxWidth;
      node.lastLayout.direction = direction;
      // Reset child layouts
      node.children.forEach(function (child) {
        child.layout.width = undefined;
        child.layout.height = undefined;
        child.layout.top = 0;
        child.layout.left = 0;
      });
      layoutNodeImpl(node, parentMaxWidth, parentDirection);
      node.lastLayout.width = node.layout.width;
      node.lastLayout.height = node.layout.height;
      node.lastLayout.top = node.layout.top;
      node.lastLayout.left = node.layout.left;
    }
    // hack
    layoutMargin(node);
  }
  /* eslint-enable */
  function computeLayout(node) {
    if (!node) return node;
    fillNodes(node);
    layoutNode(node, null, null);
    return node;
  }

  function createMeasure(style, measureText) {
    return function /* width */
    () {
      var text = style.text,
        width = style.width,
        height = style.height;
      var outputWidth = width;
      var outputHeight = height;
      if (!isNumber(width) || !isNumber(height)) {
        var _a = measureText(text, style),
          measureWidth = _a.width,
          measureHeight = _a.height;
        if (!isNumber(width)) {
          outputWidth = measureWidth;
        }
        if (!isNumber(height)) {
          outputHeight = measureHeight;
        }
      }
      return {
        width: outputWidth,
        height: outputHeight
      };
    };
  }
  function getChildrenLayout(nodeTree) {
    if (!nodeTree) return;
    var left = 0;
    var top = 0;
    var right = 0;
    var bottom = 0;
    var width = 0;
    var height = 0;
    nodeTree.forEach(function (node) {
      var layout = node.layout;
      if (!layout) return;
      left = Math.min(left, layout.left);
      top = Math.min(top, layout.top);
      right = Math.min(right, layout.left + layout.width);
      bottom = Math.min(bottom, layout.top + layout.height);
      width = Math.max(width, layout.width);
      height = Math.max(height, layout.height);
    });
    return {
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      width: width,
      height: height
    };
  }
  var NodeTree = /** @class */function () {
    function NodeTree(node) {
      var className = node.className,
        children = node.children,
        layout = node.layout;
      var nodeChildren = children && children.length ? children.map(function (child) {
        return new NodeTree(child);
      }) : undefined;
      var nodeLayout = layout ? layout : getChildrenLayout(nodeChildren);
      this.children = nodeChildren;
      this.layout = nodeLayout;
      this.className = className;
    }
    NodeTree.prototype.getElementsByClassName = function (targetClassName) {
      var result = [];
      var _a = this,
        className = _a.className,
        children = _a.children;
      if (className === targetClassName) {
        result.push(this);
      }
      if (children) {
        children.forEach(function (child) {
          result.push.apply(result, child.getElementsByClassName(targetClassName));
        });
      }
      return result;
    };
    return NodeTree;
  }();
  // 
  function extendMap(arr, fn) {
    if (!arr) {
      return arr;
    }
    var newArray = [];
    if (!isArray(arr)) {
      var rst = fn(arr);
      if (!rst) {
        return newArray;
      }
      if (isArray(rst)) {
        newArray = newArray.concat(rst);
      } else {
        newArray.push(rst);
      }
      return newArray;
    }
    for (var i = 0; i < arr.length; i++) {
      var element = arr[i];
      if (isArray(element)) {
        newArray = newArray.concat(extendMap(element, fn));
      } else if (element) {
        var rst = fn(element);
        if (!rst) {
          continue;
        }
        if (isArray(rst)) {
          newArray = newArray.concat(rst);
        } else {
          newArray.push(rst);
        }
      }
    }
    return newArray;
  }
  // functionstring
  function renderJSXElement(element, context, updater) {
    if (!element) return element;
    var px2hd = context.px2hd,
      measureText = context.measureText;
    var type = element.type,
      props = element.props;
    var tag = getWorkTag(type);
    //  function 
    if (tag === FunctionComponent) {
      // @ts-ignore
      var newElement = type(element.props, context, updater);
      // return element if type is string
      return renderJSXElement(newElement, context, updater);
    }
    var className = props.className,
      _a = props.style,
      customStyle = _a === void 0 ? {} : _a,
      attrs = props.attrs,
      newChildren = props.children;
    var style = px2hd(__assign(__assign({}, customStyle), attrs));
    // flex
    if (type === 'text') {
      style.measure = createMeasure(style, measureText);
    }
    // render children first
    var nextChildren = newChildren ? Children.toArray(newChildren).map(function (child) {
      return renderJSXElement(child, context, updater);
    }) : [];
    return {
      type: type,
      className: className,
      children: nextChildren.filter(Boolean),
      style: style
    };
  }
  // 
  function computeLayout$1(component, newChildren) {
    var context = component.context,
      updater = component.updater;
    var nodeTree = renderJSXElement(newChildren, context, updater);
    computeLayout(nodeTree);
    //  NodeTree, 
    return new NodeTree(nodeTree);
  }
  function createChildNodeTree(parent, vNodeChildren) {
    var tag = parent.tag;
    var children = extendMap(vNodeChildren, function (child) {
      var childTag = child.tag,
        childStyle = child.style,
        childChildren = child.children;
      //  flex,  flex 
      if (tag !== Shape$1 && childTag === Shape$1 && childStyle.display !== 'flex') {
        return null;
      }
      //  shape
      if (childTag !== Shape$1) {
        return createChildNodeTree(child, childChildren);
      }
      return createNodeTree(child);
    });
    return children;
  }
  // 
  function createNodeTree(vNode) {
    var tag = vNode.tag,
      type = vNode.type,
      style = vNode.style,
      context = vNode.context,
      vNodeChildren = vNode.children;
    var measureText = context.measureText;
    var children = createChildNodeTree(vNode, vNodeChildren);
    // flex
    if (type === 'text') {
      style.measure = createMeasure(style, measureText);
    }
    return {
      tag: tag,
      type: type,
      style: style,
      children: children,
      //  vNode 
      vNode: vNode
    };
  }
  function fillElementLayout(node) {
    var type = node.type,
      style = node.style,
      vNode = node.vNode,
      children = node.children,
      layout = node.layout;
    var attrs = getShapeAttrs(type, layout);
    if (style.measure) {
      delete style.measure;
    }
    // 
    vNode.layout = layout;
    vNode.style = __assign(__assign({}, attrs), style);
    if (!children || !children.length) {
      return;
    }
    for (var i = 0, len = children.length; i < len; i++) {
      var child = children[i];
      fillElementLayout(child);
    }
  }
  function fillComponentLayout(vNode) {
    var layout = vNode.layout,
      vNodeChildren = vNode.children;
    Children.map(vNodeChildren, function (child) {
      if (!child) {
        return;
      }
      var childTag = child.tag,
        childLayout = child.layout,
        style = child.style;
      if (childTag !== Shape$1 && layout && !childLayout) {
        child.layout = layout;
        child.style = __assign({
          width: layout.width,
          height: layout.height
        }, style);
      }
      fillComponentLayout(child);
    });
  }

  function pickElement(element) {
    if (!element) return element;
    return Children.map(element, function (item) {
      if (!item) return item;
      // 
      return pick(item, ['key', 'ref', 'type', 'props']);
    });
  }
  function getStyle$1(tagType, props, context) {
    var _a = props.style,
      customStyle = _a === void 0 ? {} : _a,
      attrs = props.attrs,
      zIndex = props.zIndex;
    if (tagType === Shape$1) {
      return context.px2hd(__assign(__assign({}, customStyle), attrs));
    }
    if (isNumber(zIndex)) {
      return {
        zIndex: zIndex
      };
    }
    return {};
  }
  function createVNode(parent, vNode) {
    var canvas = parent.canvas,
      context = parent.context,
      updater = parent.updater,
      parentAnimate = parent.animate;
    var ref = vNode.ref,
      type = vNode.type,
      originProps = vNode.props;
    var animate = originProps.animate,
      transformFrom = originProps.transformFrom,
      props = __rest(originProps, ["animate", "transformFrom"]);
    var tag = getWorkTag(type);
    var animator = new Animator();
    var style = getStyle$1(tag, props, context);
    vNode.parent = parent;
    vNode.tag = tag;
    vNode.style = style;
    vNode.context = context;
    vNode.updater = updater;
    vNode.canvas = canvas;
    vNode.animate = isBoolean(animate) ? animate : parentAnimate;
    vNode.animator = animator;
    // shape 
    if (tag === Shape$1) {
      var shape = createShape(type, __assign(__assign({}, props), {
        style: style
      }));
      if (ref) {
        ref.current = shape;
      }
      // @ts-ignore
      shape._vNode = vNode; // shape  vNode 
      vNode.shape = shape;
    } else {
      // 
      var component = void 0;
      if (tag === ClassComponent) {
        // @ts-ignore
        component = new type(props, context, updater);
      } else {
        component = new Component(props, context, updater);
        component.render = function () {
          // @ts-ignore
          return type(this.props, context, updater);
        };
      }
      var group = new Group();
      component.container = group;
      // ref
      if (ref) {
        ref.current = component;
      }
      component.context = context;
      component.updater = updater;
      component.animator = animator;
      component._vNode = vNode;
      vNode.shape = group;
      vNode.component = component;
    }
    if (transformFrom && transformFrom.current) {
      var transformVNode = transformFrom.current._vNode;
      vNode.transform = findClosestShapeNode(transformVNode);
      if (vNode.transform) {
        vNode.transform.parent.children = null;
      }
    }
    return vNode;
  }
  function updateVNode(parent, nextNode, lastNode) {
    var canvas = parent.canvas,
      context = parent.context,
      updater = parent.updater,
      parentAnimate = parent.animate;
    var tag = lastNode.tag,
      animator = lastNode.animator,
      component = lastNode.component,
      shape = lastNode.shape,
      children = lastNode.children;
    var props = nextNode.props;
    var animate = props.animate;
    nextNode.parent = parent;
    nextNode.tag = tag;
    nextNode.canvas = canvas;
    nextNode.context = context;
    nextNode.updater = updater;
    nextNode.component = component;
    nextNode.shape = shape;
    nextNode.parent = parent;
    nextNode.children = children;
    nextNode.animate = isBoolean(animate) ? animate : parentAnimate;
    nextNode.animator = animator;
    nextNode.style = getStyle$1(tag, props, context);
    //  vNode 
    if (component) {
      component._vNode = nextNode;
    } else {
      //  shape 
      // @ts-ignore
      shape._vNode = nextNode;
    }
    return nextNode;
  }
  function createElement(parent, element) {
    return Children.map(element, function (el) {
      if (!el) return el;
      return createVNode(parent, el);
    });
  }
  function destroyElement(vNode) {
    Children.map(vNode, function (node) {
      if (!node) return;
      var component = node.component,
        children = node.children;
      if (component) {
        component.willUnmount();
        destroyElement(children);
        component.didUnmount();
        component.destroy();
      } else {
        destroyElement(children);
      }
    });
  }
  function updateElement(parent, nextElement, lastElement) {
    var nextType = nextElement.type,
      nextProps = nextElement.props;
    var lastType = lastElement.type,
      lastProps = lastElement.props;
    if (nextType === lastType) {
      var nextVNode_1 = updateVNode(parent, nextElement, lastElement);
      // props   context 
      if (equal(nextProps, lastProps) && parent.context === lastElement.context) {
        return null;
      }
      return nextVNode_1;
    }
    var nextVNode = createVNode(parent, nextElement);
    destroyElement(lastElement);
    return nextVNode;
  }
  function diffElement(parent, nextElement, lastElement) {
    if (!nextElement && !lastElement) {
      return null;
    }
    // 
    if (!nextElement && lastElement) {
      destroyElement(lastElement);
      return null;
    }
    // 
    if (nextElement && !lastElement) {
      return createElement(parent, nextElement);
    }
    // 
    return updateElement(parent, nextElement, lastElement);
  }
  function renderComponentNodes(componentNodes) {
    if (!componentNodes || !componentNodes.length) {
      return;
    }
    // 1. shouldUpdate & willReceiveProps
    var shouldProcessChildren = componentNodes.filter(function (node) {
      var component = node.component,
        props = node.props,
        context = node.context,
        layout = node.layout;
      //  layout
      component.layout = layout;
      //  component
      if (!component.isMounted) return true;
      // 
      if (component.shouldUpdate(props) === false) {
        return false;
      }
      component.willReceiveProps(props, context);
      component.props = props;
      component.context = context;
      return true;
    });
    if (!shouldProcessChildren.length) {
      return;
    }
    // 2. willMount / willUpdate
    shouldProcessChildren.forEach(function (child) {
      var component = child.component;
      if (!component.isMounted) {
        component.willMount();
      } else {
        component.willUpdate();
      }
    });
    // 3. render
    shouldProcessChildren.forEach(function (child) {
      var canvas = child.canvas,
        component = child.component,
        children = child.children;
      var newChildren = canvas.toRawChildren(component.render());
      renderChildren(child, newChildren, children);
      if (!component.isMounted) {
        component.didMount();
        component.isMounted = true;
      } else {
        component.didUpdate();
      }
    });
  }
  function renderVNode(node, nextChildren, lastChildren) {
    var component = node.component;
    //  pick 
    var newChildren = pickElement(nextChildren);
    //  children
    node.children = newChildren;
    //  children
    //  node.tag === ClassComponent || node.tag === FunctionComponent
    if (component) {
      component.children = newChildren;
    }
    var componentNodeChildren = [];
    Children.compare(newChildren, lastChildren, function (next, last) {
      var element = diffElement(node, next, last);
      Children.map(element, function (child) {
        if (!child) return;
        var tag = child.tag,
          childProps = child.props,
          childLastChildren = child.children;
        var childrenNode = [];
        if (tag === Shape$1) {
          childrenNode = renderVNode(child, childProps.children, childLastChildren);
        } else {
          childrenNode = [child];
        }
        componentNodeChildren = componentNodeChildren.concat(childrenNode);
      });
    });
    return componentNodeChildren;
  }
  function renderChildren(parent, nextChildren, lastChildren) {
    //  classComponent 
    var componentNodeChildren = renderVNode(parent, nextChildren, lastChildren);
    //  flex 
    var nodeTree = createNodeTree(parent);
    computeLayout(nodeTree);
    fillElementLayout(nodeTree);
    fillComponentLayout(parent);
    var newChildren = parent.children;
    if (!componentNodeChildren.length) {
      return newChildren;
    }
    renderComponentNodes(componentNodeChildren);
    return newChildren;
  }
  function render(vNode) {
    var lastChildren = vNode.children,
      props = vNode.props;
    var nextChildren = props.children;
    // render 
    var children = renderChildren(vNode, nextChildren, lastChildren);
    // 
    var childrenAnimation = createAnimation(vNode, children, lastChildren);
    // 
    if (childrenAnimation.length) {
      childrenAnimation.forEach(function (animator) {
        animator.loadPlay();
      });
    }
  }
  // setState 
  function updateComponents(components) {
    if (!components.length) return;
    components.forEach(function (component) {
      var vNode = component._vNode,
        lastChildren = component.children,
        props = component.props,
        animator = component.animator;
      // 
      if (component.shouldUpdate(props) === false) {
        return false;
      }
      component.willUpdate();
      var canvas = vNode.canvas;
      var newChildren = canvas.toRawChildren(component.render());
      var nextChildren = renderChildren(vNode, newChildren, lastChildren);
      //  children
      component.children = nextChildren;
      vNode.children = nextChildren;
      // 
      var childrenAnimation = createAnimation(vNode, nextChildren, lastChildren);
      if (childrenAnimation && childrenAnimation.length) {
        animator.children = childrenAnimation;
      }
      // 
      animator.loadPlay();
      component.didUpdate();
    });
  }

  function _inheritsLoose$2(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$2(subClass, superClass);
  }
  function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$2(o, p);
  }

  function generatePath(context, parsedStyle) {
    var r = parsedStyle.r;
    context.arc(r, r, r, 0, Math.PI * 2, false);
  }

  function generatePath$1(context, parsedStyle) {
    var rxInPixels = parsedStyle.rx,
      ryInPixels = parsedStyle.ry;
    var rx = rxInPixels;
    var ry = ryInPixels;
    // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
    if (context.ellipse) {
      context.ellipse(rx, ry, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      // 
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r, 0, Math.PI * 2);
    }
  }

  function generatePath$2(context, parsedStyle) {
    var x1 = parsedStyle.x1,
      y1 = parsedStyle.y1,
      x2 = parsedStyle.x2,
      y2 = parsedStyle.y2,
      _parsedStyle$defX = parsedStyle.defX,
      defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX,
      _parsedStyle$defY = parsedStyle.defY,
      defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY,
      markerStart = parsedStyle.markerStart,
      markerEnd = parsedStyle.markerEnd,
      markerStartOffset = parsedStyle.markerStartOffset,
      markerEndOffset = parsedStyle.markerEndOffset;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x = x2 - x1;
      y = y2 - y1;
      rad = Math.atan2(y, x);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x = x1 - x2;
      y = y1 - y2;
      rad = Math.atan2(y, x);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 - defX + startOffsetX, y1 - defY + startOffsetY);
    context.lineTo(x2 - defX + endOffsetX, y2 - defY + endOffsetY);
  }

  function generatePath$3(context, parsedStyle) {
    var _parsedStyle$defX = parsedStyle.defX,
      defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX,
      _parsedStyle$defY = parsedStyle.defY,
      defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY,
      markerStart = parsedStyle.markerStart,
      markerEnd = parsedStyle.markerEnd,
      markerStartOffset = parsedStyle.markerStartOffset,
      markerEndOffset = parsedStyle.markerEndOffset;
    var _parsedStyle$path = parsedStyle.path,
      absolutePath = _parsedStyle$path.absolutePath,
      segments = _parsedStyle$path.segments;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      var _markerStart$parentNo = markerStart.parentNode.getStartTangent(),
        p1 = _markerStart$parentNo[0],
        p2 = _markerStart$parentNo[1];
      x = p1[0] - p2[0];
      y = p1[1] - p2[1];
      rad = Math.atan2(y, x);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      var _markerEnd$parentNode = markerEnd.parentNode.getEndTangent(),
        _p = _markerEnd$parentNode[0],
        _p2 = _markerEnd$parentNode[1];
      x = _p[0] - _p2[0];
      y = _p[1] - _p2[1];
      rad = Math.atan2(y, x);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    for (var i = 0; i < absolutePath.length; i++) {
      var params = absolutePath[i];
      var command = params[0];
      var nextSegment = absolutePath[i + 1];
      var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
      var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === 'M' || nextSegment[0] === 'Z')) && endOffsetX !== 0 && endOffsetY !== 0;
      switch (command) {
        case 'M':
          // Use start marker offset
          if (useStartOffset) {
            context.moveTo(params[1] - defX + startOffsetX, params[2] - defY + startOffsetY);
            context.lineTo(params[1] - defX, params[2] - defY);
          } else {
            context.moveTo(params[1] - defX, params[2] - defY);
          }
          break;
        case 'L':
          if (useEndOffset) {
            context.lineTo(params[1] - defX + endOffsetX, params[2] - defY + endOffsetY);
          } else {
            context.lineTo(params[1] - defX, params[2] - defY);
          }
          break;
        case 'Q':
          context.quadraticCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY);
          if (useEndOffset) {
            context.lineTo(params[3] - defX + endOffsetX, params[4] - defY + endOffsetY);
          }
          break;
        case 'C':
          context.bezierCurveTo(params[1] - defX, params[2] - defY, params[3] - defX, params[4] - defY, params[5] - defX, params[6] - defY);
          if (useEndOffset) {
            context.lineTo(params[5] - defX + endOffsetX, params[6] - defY + endOffsetY);
          }
          break;
        case 'A':
          {
            var arcParams = segments[i].arcParams;
            var cx = arcParams.cx,
              cy = arcParams.cy,
              rx = arcParams.rx,
              ry = arcParams.ry,
              startAngle = arcParams.startAngle,
              endAngle = arcParams.endAngle,
              xRotation = arcParams.xRotation,
              sweepFlag = arcParams.sweepFlag;
            // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
            if (context.ellipse) {
              context.ellipse(cx - defX, cy - defY, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
            } else {
              // @see https://stackoverflow.com/a/47494351
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              context.translate(cx - defX, cy - defY);
              context.rotate(xRotation);
              context.scale(scaleX, scaleY);
              context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
              context.scale(1 / scaleX, 1 / scaleY);
              context.rotate(-xRotation);
              context.translate(-(cx - defX), -(cy - defY));
            }
            if (useEndOffset) {
              context.lineTo(params[6] - defX + endOffsetX, params[7] - defY + endOffsetY);
            }
            break;
          }
        case 'Z':
          context.closePath();
          break;
      }
    }
  }

  function generatePath$4(context, parsedStyle) {
    var _parsedStyle$defX = parsedStyle.defX,
      defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX,
      _parsedStyle$defY = parsedStyle.defY,
      defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY,
      markerStart = parsedStyle.markerStart,
      markerEnd = parsedStyle.markerEnd,
      markerStartOffset = parsedStyle.markerStartOffset,
      markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0] - defX;
    var y1 = points[0][1] - defY;
    var x2 = points[length - 1][0] - defX;
    var y2 = points[length - 1][1] - defY;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x = points[1][0] - points[0][0];
      y = points[1][1] - points[0][1];
      rad = Math.atan2(y, x);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x = points[length - 1][0] - points[0][0];
      y = points[length - 1][1] - points[0][1];
      rad = Math.atan2(y, x);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
    for (var i = 1; i < length - 1; i++) {
      var point = points[i];
      context.lineTo(point[0] - defX, point[1] - defY);
    }
    context.lineTo(x2, y2);
  }

  function generatePath$5(context, parsedStyle) {
    var _parsedStyle$defX = parsedStyle.defX,
      defX = _parsedStyle$defX === void 0 ? 0 : _parsedStyle$defX,
      _parsedStyle$defY = parsedStyle.defY,
      defY = _parsedStyle$defY === void 0 ? 0 : _parsedStyle$defY,
      markerStart = parsedStyle.markerStart,
      markerEnd = parsedStyle.markerEnd,
      markerStartOffset = parsedStyle.markerStartOffset,
      markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0] - defX;
    var y1 = points[0][1] - defY;
    var x2 = points[length - 1][0] - defX;
    var y2 = points[length - 1][1] - defY;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x = points[1][0] - points[0][0];
      y = points[1][1] - points[0][1];
      rad = Math.atan2(y, x);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x = points[length - 2][0] - points[length - 1][0];
      y = points[length - 2][1] - points[length - 1][1];
      rad = Math.atan2(y, x);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
    for (var i = 1; i < length - 1; i++) {
      var point = points[i];
      context.lineTo(point[0] - defX, point[1] - defY);
    }
    context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
  }

  function generatePath$6(context, parsedStyle) {
    var radius = parsedStyle.radius,
      width = parsedStyle.width,
      height = parsedStyle.height;
    var w = width;
    var h = height;
    var hasRadius = radius && radius.some(function (r) {
      return r !== 0;
    });
    if (!hasRadius) {
      // Canvas support negative width/height of rect
      context.rect(0, 0, w, h);
    } else {
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY === 0;
      var _radius$map = radius.map(function (r) {
          return clamp(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
        }),
        tlr = _radius$map[0],
        trr = _radius$map[1],
        brr = _radius$map[2],
        blr = _radius$map[3];
      context.moveTo(signX * tlr, 0);
      context.lineTo(w - signX * trr, 0);
      if (trr !== 0) {
        context.arc(w - signX * trr, signY * trr, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
      }
      context.lineTo(w, h - signY * brr);
      if (brr !== 0) {
        context.arc(w - signX * brr, h - signY * brr, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
      }
      context.lineTo(signX * blr, h);
      if (blr !== 0) {
        context.arc(signX * blr, h - signY * blr, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
      }
      context.lineTo(0, signY * tlr);
      if (tlr !== 0) {
        context.arc(signX * tlr, signY * tlr, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
      }
    }
  }

  var Plugin = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$2(Plugin, _AbstractRendererPlug);
    function Plugin() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
      _this.name = 'canvas-path-generator';
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      var _pathGeneratorFactory;
      var pathGeneratorFactory = (_pathGeneratorFactory = {}, _pathGeneratorFactory[Shape.CIRCLE] = generatePath, _pathGeneratorFactory[Shape.ELLIPSE] = generatePath$1, _pathGeneratorFactory[Shape.RECT] = generatePath$6, _pathGeneratorFactory[Shape.LINE] = generatePath$2, _pathGeneratorFactory[Shape.POLYLINE] = generatePath$5, _pathGeneratorFactory[Shape.POLYGON] = generatePath$4, _pathGeneratorFactory[Shape.PATH] = generatePath$3, _pathGeneratorFactory[Shape.TEXT] = undefined, _pathGeneratorFactory[Shape.GROUP] = undefined, _pathGeneratorFactory[Shape.IMAGE] = undefined, _pathGeneratorFactory[Shape.HTML] = undefined, _pathGeneratorFactory[Shape.MESH] = undefined, _pathGeneratorFactory);
      // @ts-ignore
      this.context.pathGeneratorFactory = pathGeneratorFactory;
    };
    _proto.destroy = function destroy() {
      // @ts-ignore
      delete this.context.pathGeneratorFactory;
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function _regeneratorRuntime$1() {
    _regeneratorRuntime$1 = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$1(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _inheritsLoose$3(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$3(subClass, superClass);
  }
  function _setPrototypeOf$3(o, p) {
    _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$3(o, p);
  }
  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var tmpVec3a = create$2();
  var tmpVec3b = create$2();
  var tmpVec3c = create$2();
  var tmpMat4$1 = create$1();
  /**
   * pick shape(s) with Mouse/Touch event
   *
   * 1. find AABB with r-tree
   * 2. do math calculation with geometry in an accurate way
   */
  var CanvasPickerPlugin = /*#__PURE__*/function () {
    function CanvasPickerPlugin() {
      var _this = this;
      this.canvasConfig = void 0;
      this.pathGeneratorFactory = void 0;
      this.pointInPathPickerFactory = void 0;
      this.isHit = function (displayObject, position, worldTransform, isClipPath, runtime) {
        // use picker for current shape's type
        var pick = _this.pointInPathPickerFactory[displayObject.nodeName];
        if (pick) {
          // invert with world matrix
          var invertWorldMat = invert(tmpMat4$1, worldTransform);
          // transform client position to local space, do picking in local space
          var localPosition = transformMat4(tmpVec3b, set$1(tmpVec3c, position[0], position[1], 0), invertWorldMat);
          // account for anchor
          var _displayObject$getGeo = displayObject.getGeometryBounds(),
            halfExtents = _displayObject$getGeo.halfExtents;
          var anchor = displayObject.parsedStyle.anchor;
          localPosition[0] += (anchor && anchor[0] || 0) * halfExtents[0] * 2;
          localPosition[1] += (anchor && anchor[1] || 0) * halfExtents[1] * 2;
          if (pick(displayObject, new Point(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, runtime)) {
            return true;
          }
        }
        return false;
      };
      /**
       * use native picking method
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/isPointInPath
       */
      this.isPointInPath = function (runtime, displayObject, position) {
        var context = runtime.offscreenCanvas.getOrCreateContext(_this.canvasConfig.offscreenCanvas);
        var generatePath = _this.pathGeneratorFactory[displayObject.nodeName];
        if (generatePath) {
          context.beginPath();
          generatePath(context, displayObject.parsedStyle);
          context.closePath();
        }
        return context.isPointInPath(position.x, position.y);
      };
    }
    var _proto = CanvasPickerPlugin.prototype;
    _proto.apply = function apply(context, runtime) {
      var _renderingContext$roo,
        _this2 = this;
      var config = context.config,
        renderingService = context.renderingService,
        renderingContext = context.renderingContext,
        pathGeneratorFactory = context.pathGeneratorFactory,
        pointInPathPickerFactory = context.pointInPathPickerFactory;
      this.canvasConfig = config;
      this.pathGeneratorFactory = pathGeneratorFactory;
      this.pointInPathPickerFactory = pointInPathPickerFactory;
      var document = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
      renderingService.hooks.pick.tapPromise(CanvasPickerPlugin.tag, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator$1( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee(result) {
          return _regeneratorRuntime$1().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", _this2.pick(document, result, runtime));
              case 1:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      renderingService.hooks.pickSync.tap(CanvasPickerPlugin.tag, function (result) {
        return _this2.pick(document, result, runtime);
      });
    };
    _proto.pick = function pick(document, result, runtime) {
      var topmost = result.topmost,
        _result$position = result.position,
        x = _result$position.x,
        y = _result$position.y;
      // position in world space
      var position = set$1(tmpVec3a, x, y, 0);
      // query by AABB first with spatial index(r-tree)
      var hitTestList = document.elementsFromBBox(position[0], position[1], position[0], position[1]);
      // test with clip path & origin shape
      // @see https://github.com/antvis/g/issues/1064
      var pickedDisplayObjects = [];
      for (var _iterator = _createForOfIteratorHelperLoose$1(hitTestList), _step; !(_step = _iterator()).done;) {
        var displayObject = _step.value;
        var worldTransform = displayObject.getWorldTransform();
        var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false, runtime);
        if (isHitOriginShape) {
          // should look up in the ancestor node
          var clipped = findClosestClipPathTarget(displayObject);
          if (clipped) {
            var clipPath = clipped.parsedStyle.clipPath;
            var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true, runtime);
            if (isHitClipPath) {
              if (topmost) {
                result.picked = [displayObject];
                return result;
              } else {
                pickedDisplayObjects.push(displayObject);
              }
            }
          } else {
            if (topmost) {
              result.picked = [displayObject];
              return result;
            } else {
              pickedDisplayObjects.push(displayObject);
            }
          }
        }
      }
      result.picked = pickedDisplayObjects;
      return result;
    };
    return CanvasPickerPlugin;
  }();
  CanvasPickerPlugin.tag = 'CanvasPicker';

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  function distance$2(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function isNumberEqual$2(v1, v2) {
    return Math.abs(v1 - v2) < 0.001;
  }
  function getBBoxByArray$1(xArr, yArr) {
    var minX = Math.min.apply(Math, xArr);
    var minY = Math.min.apply(Math, yArr);
    var maxX = Math.max.apply(Math, xArr);
    var maxY = Math.max.apply(Math, yArr);
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function piMod$1(angle) {
    return (angle + Math.PI * 2) % (Math.PI * 2);
  }
  var line$2 = {
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {object} 
     */
    box: function box(x1, y1, x2, y2) {
      return getBBoxByArray$1([x1, x2], [y1, y2]);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {number} 
     */
    length: function length(x1, y1, x2, y2) {
      return distance$2(x1, y1, x2, y2);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} t 
     * @return {object}  x, y 
     */
    pointAt: function pointAt(x1, y1, x2, y2, t) {
      return {
        x: (1 - t) * x1 + t * x2,
        y: (1 - t) * y1 + t * y2
      };
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} x   x
     * @param {number} y   y
     * @return {number} 
     */
    pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
      //  x1, y1  p, p1, p2  a
      // p1a = p1p.p1p2/|p1p2| * (p1p )
      var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
      if (cross < 0) {
        return distance$2(x1, y1, x, y);
      }
      var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (cross > lengthSquare) {
        return distance$2(x2, y2, x, y);
      }
      return this.pointToLine(x1, y1, x2, y2, x, y);
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @param {number} x   x
     * @param {number} y   y
     * @return {number} 
     */
    pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
      var d = [x2 - x1, y2 - y1];
      // 
      if (exactEquals$1(d, [0, 0])) {
        return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      }
      var u = [-d[1], d[0]];
      normalize$3(u, u);
      var a = [x - x1, y - y1];
      return Math.abs(dot$1(a, u));
    },
    /**
     * 
     * @param {number} x1  x
     * @param {number} y1  y
     * @param {number} x2  x
     * @param {number} y2  y
     * @return {number} 
     */
    tangentAngle: function tangentAngle(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    }
  };
  var EPSILON$2 = 0.0001;
  /**
   * 
   * @param {number[]} xArr       x 
   * @param {number[]} yArr       y 
   * @param {number}   x          x
   * @param {number}   y          y
   * @param {Function} tCallback 
   */
  function nearestPoint$1(xArr, yArr, x, y, tCallback, length) {
    var t = -1;
    var d = Infinity;
    var v0 = [x, y];
    var segNum = 20;
    if (length && length > 200) {
      segNum = length / 10;
    }
    var increaseRate = 1 / segNum;
    var interval = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [tCallback.apply(void 0, xArr.concat([_t])), tCallback.apply(void 0, yArr.concat([_t]))];
      var d1 = distance$2(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    // 
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count = xArr.length;
      return {
        x: xArr[count - 1],
        y: yArr[count - 1]
      };
    }
    d = Infinity;
    for (var _i = 0; _i < 32; _i++) {
      if (interval < EPSILON$2) {
        break;
      }
      var prev = t - interval;
      var next = t + interval;
      var _v = [tCallback.apply(void 0, xArr.concat([prev])), tCallback.apply(void 0, yArr.concat([prev]))];
      var _d = distance$2(v0[0], v0[1], _v[0], _v[1]);
      if (prev >= 0 && _d < d) {
        t = prev;
        d = _d;
      } else {
        var v2 = [tCallback.apply(void 0, xArr.concat([next])), tCallback.apply(void 0, yArr.concat([next]))];
        var d2 = distance$2(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(void 0, xArr.concat([t])),
      y: tCallback.apply(void 0, yArr.concat([t]))
    };
  }
  //  https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2
  function snapLength$1(xArr, yArr) {
    var totalLength = 0;
    var count = xArr.length;
    for (var i = 0; i < count; i++) {
      var x = xArr[i];
      var y = yArr[i];
      var nextX = xArr[(i + 1) % count];
      var nextY = yArr[(i + 1) % count];
      totalLength += distance$2(x, y, nextX, nextY);
    }
    return totalLength / 2;
  }

  // 
  function quadraticAt$1(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  // 
  function extrema$2(p0, p1, p2) {
    var a = p0 + p2 - 2 * p1;
    if (isNumberEqual$2(a, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function derivativeAt$2(p0, p1, p2, t) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
  }
  // 
  function divideQuadratic$1(x1, y1, x2, y2, x3, y3, t) {
    // 
    var xt = quadraticAt$1(x1, x2, x3, t);
    var yt = quadraticAt$1(y1, y2, y3, t);
    // 
    var controlPoint1 = line$2.pointAt(x1, y1, x2, y2, t);
    // 
    var controlPoint2 = line$2.pointAt(x2, y2, x3, y3, t);
    return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
  }
  // 
  function quadraticLength$1(x1, y1, x2, y2, x3, y3, iterationCount) {
    if (iterationCount === 0) {
      return (distance$2(x1, y1, x2, y2) + distance$2(x2, y2, x3, y3) + distance$2(x1, y1, x3, y3)) / 2;
    }
    var quadratics = divideQuadratic$1(x1, y1, x2, y2, x3, y3, 0.5);
    var left = quadratics[0];
    var right = quadratics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return quadraticLength$1.apply(void 0, left) + quadraticLength$1.apply(void 0, right);
  }
  var quadratic$1 = {
    box: function box(x1, y1, x2, y2, x3, y3) {
      var xExtrema = extrema$2(x1, x2, x3)[0];
      var yExtrema = extrema$2(y1, y2, y3)[0];
      //  box 
      var xArr = [x1, x3];
      var yArr = [y1, y3];
      if (xExtrema !== undefined) {
        xArr.push(quadraticAt$1(x1, x2, x3, xExtrema));
      }
      if (yExtrema !== undefined) {
        yArr.push(quadraticAt$1(y1, y2, y3, yExtrema));
      }
      return getBBoxByArray$1(xArr, yArr);
    },
    length: function length(x1, y1, x2, y2, x3, y3) {
      return quadraticLength$1(x1, y1, x2, y2, x3, y3, 3);
    },
    nearestPoint: function nearestPoint$1$1(x1, y1, x2, y2, x3, y3, x0, y0) {
      return nearestPoint$1([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt$1);
    },
    pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
      return distance$2(point.x, point.y, x0, y0);
    },
    interpolationAt: quadraticAt$1,
    pointAt: function pointAt(x1, y1, x2, y2, x3, y3, t) {
      return {
        x: quadraticAt$1(x1, x2, x3, t),
        y: quadraticAt$1(y1, y2, y3, t)
      };
    },
    divide: function divide(x1, y1, x2, y2, x3, y3, t) {
      return divideQuadratic$1(x1, y1, x2, y2, x3, y3, t);
    },
    tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, t) {
      var dx = derivativeAt$2(x1, x2, x3, t);
      var dy = derivativeAt$2(y1, y2, y3, t);
      var angle = Math.atan2(dy, dx);
      return piMod$1(angle);
    }
  };
  function cubicAt$1(p0, p1, p2, p3, t) {
    var onet = 1 - t; // t * t * t  Math.pow(t, 3) 
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function derivativeAt$1$1(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
  }
  function extrema$1$1(p0, p1, p2, p3) {
    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual$2(a, 0)) {
      if (!isNumberEqual$2(b, 0)) {
        t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isNumberEqual$2(disc, 0)) {
        extremas.push(-b / (2 * a));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a);
        t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  // 
  function divideCubic$1(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    // 
    var xt = cubicAt$1(x1, x2, x3, x4, t);
    var yt = cubicAt$1(y1, y2, y3, y4, t);
    // 
    var c1 = line$2.pointAt(x1, y1, x2, y2, t);
    var c2 = line$2.pointAt(x2, y2, x3, y3, t);
    var c3 = line$2.pointAt(x3, y3, x4, y4, t);
    var c12 = line$2.pointAt(c1.x, c1.y, c2.x, c2.y, t);
    var c23 = line$2.pointAt(c2.x, c2.y, c3.x, c3.y, t);
    return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
  }
  // 
  function cubicLength$1(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
    if (iterationCount === 0) {
      return snapLength$1([x1, x2, x3, x4], [y1, y2, y3, y4]);
    }
    var cubics = divideCubic$1(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
    var left = [].concat(cubics[0], [iterationCount - 1]);
    var right = [].concat(cubics[1], [iterationCount - 1]);
    return cubicLength$1.apply(void 0, left) + cubicLength$1.apply(void 0, right);
  }
  var cubic$1 = {
    extrema: extrema$1$1,
    box: function box(x1, y1, x2, y2, x3, y3, x4, y4) {
      var xArr = [x1, x4];
      var yArr = [y1, y4];
      var xExtrema = extrema$1$1(x1, x2, x3, x4);
      var yExtrema = extrema$1$1(y1, y2, y3, y4);
      for (var i = 0; i < xExtrema.length; i++) {
        xArr.push(cubicAt$1(x1, x2, x3, x4, xExtrema[i]));
      }
      for (var _i = 0; _i < yExtrema.length; _i++) {
        yArr.push(cubicAt$1(y1, y2, y3, y4, yExtrema[_i]));
      }
      return getBBoxByArray$1(xArr, yArr);
    },
    length: function length(x1, y1, x2, y2, x3, y3, x4, y4) {
      //  8 
      return cubicLength$1(x1, y1, x2, y2, x3, y3, x4, y4, 3);
    },
    nearestPoint: function nearestPoint$1$1(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
      return nearestPoint$1([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt$1, length);
    },
    pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
      return distance$2(point.x, point.y, x0, y0);
    },
    interpolationAt: cubicAt$1,
    pointAt: function pointAt(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return {
        x: cubicAt$1(x1, x2, x3, x4, t),
        y: cubicAt$1(y1, y2, y3, y4, t)
      };
    },
    divide: function divide(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return divideCubic$1(x1, y1, x2, y2, x3, y3, x4, y4, t);
    },
    tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      var dx = derivativeAt$1$1(x1, x2, x3, x4, t);
      var dy = derivativeAt$1$1(y1, y2, y3, y4, t);
      return piMod$1(Math.atan2(dy, dx));
    }
  };

  function distance$1$1(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function inBox(minX, minY, width, height, x, y) {
    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
  }
  function inRect(minX, minY, width, height, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    // 
    return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) ||
    // 
    inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) ||
    // 
    inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) ||
    // 
    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y); // 
  }

  function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
    var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); //  0 - 2 * Math.PI 
    // if (angle < startAngle || angle > endAngle) {
    //   return false;
    // }
    var point = {
      x: cx + r * Math.cos(angle),
      y: cy + r * Math.sin(angle)
    };
    return distance$1$1(point.x, point.y, x, y) <= lineWidth / 2;
  }
  function inLine(x1, y1, x2, y2, lineWidth, x, y) {
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var halfWidth = lineWidth / 2;
    // 
    //  lineWidth 
    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
      return false;
    }
    // 
    return line$2.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
  }
  function inPolyline(points, lineWidth, x, y, isClose) {
    var count = points.length;
    if (count < 2) {
      return false;
    }
    for (var i = 0; i < count - 1; i++) {
      var x1 = points[i][0];
      var y1 = points[i][1];
      var x2 = points[i + 1][0];
      var y2 = points[i + 1][1];
      if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
        return true;
      }
    }
    // 
    if (isClose) {
      var first = points[0];
      var last = points[count - 1];
      if (inLine(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
        return true;
      }
    }
    return false;
  }
  // https://blog.csdn.net/WilliamSun0122/article/details/77994526
  var tolerance = 1e-6;
  // doubleeps
  function dcmp(x) {
    if (Math.abs(x) < tolerance) {
      return 0;
    }
    return x < 0 ? -1 : 1;
  }
  // Qp1p2
  function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  // P-
  function inPolygon(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      // svg  3 
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n];
      if (onSegment(p1, p2, [x, y])) {
        // 
        return true;
      }
      // min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
      //    
      if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }
  function inPolygons(polygons, x, y) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = inPolygon(points, x, y);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }

  function isPointInPath(displayObject, position, isClipPath) {
    var _displayObject$parsed = displayObject.parsedStyle,
      r = _displayObject$parsed.r,
      fill = _displayObject$parsed.fill,
      stroke = _displayObject$parsed.stroke,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      pointerEvents = _displayObject$parsed.pointerEvents;
    var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
    var absDistance = distance$1$1(r, r, position.x, position.y);
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasFill = _isFillOrStrokeAffect[0],
      hasStroke = _isFillOrStrokeAffect[1];
    if (hasFill && hasStroke || isClipPath) {
      return absDistance <= r + halfLineWidth;
    }
    if (hasFill) {
      return absDistance <= r;
    }
    if (hasStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  }

  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  function isPointInPath$1(displayObject, position, isClipPath) {
    var _displayObject$parsed = displayObject.parsedStyle,
      rx = _displayObject$parsed.rx,
      ry = _displayObject$parsed.ry,
      fill = _displayObject$parsed.fill,
      stroke = _displayObject$parsed.stroke,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      pointerEvents = _displayObject$parsed.pointerEvents;
    var x = position.x,
      y = position.y;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasFill = _isFillOrStrokeAffect[0],
      hasStroke = _isFillOrStrokeAffect[1];
    var halfLineWith = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) / 2;
    var squareX = (x - rx) * (x - rx);
    var squareY = (y - ry) * (y - ry);
    //  x*x/rx*rx + y*y/ry*ry = 1;
    if (hasFill && hasStroke || isClipPath) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (hasFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (hasStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  }

  function isPointInPath$2(displayObject, position, isClipPath) {
    var _displayObject$parsed = displayObject.parsedStyle,
      x1 = _displayObject$parsed.x1,
      y1 = _displayObject$parsed.y1,
      x2 = _displayObject$parsed.x2,
      y2 = _displayObject$parsed.y2,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      _displayObject$parsed2 = _displayObject$parsed.defX,
      x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2,
      _displayObject$parsed3 = _displayObject$parsed.defY,
      y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3,
      pointerEvents = _displayObject$parsed.pointerEvents,
      fill = _displayObject$parsed.fill,
      stroke = _displayObject$parsed.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasStroke = _isFillOrStrokeAffect[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inLine(x1, y1, x2, y2, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y);
  }

  // TODO: replace it with method in @antv/util
  function isPointInStroke(segments, lineWidth, px, py, length) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint,
        box = segment.box;
      // 
      if (box && !inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, px, py)) {
        continue;
      }
      switch (segment.command) {
        // L  Z  M 
        case 'L':
        case 'Z':
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
          if (isHit) {
            return true;
          }
          break;
        case 'Q':
          var qDistance = quadratic$1.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
          isHit = qDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case 'C':
          var cDistance = cubic$1.pointDistance(prePoint[0],
          // ,  C 
          prePoint[1], params[1],
          // 'C' 12 34 56 
          params[2], params[3], params[4], params[5], params[6], px, py, length);
          isHit = cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case 'A':
          // cache conversion result
          if (!segment.cubicParams) {
            segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], undefined);
          }
          var args = segment.cubicParams;
          // fixArc
          var prePointInCubic = prePoint;
          for (var _i = 0; _i < args.length; _i += 6) {
            var _cDistance = cubic$1.pointDistance(prePointInCubic[0],
            // ,  C 
            prePointInCubic[1], args[_i], args[_i + 1], args[_i + 2], args[_i + 3], args[_i + 4], args[_i + 5], px, py, length);
            prePointInCubic = [args[_i + 4], args[_i + 5]];
            isHit = _cDistance <= lineWidth / 2;
            if (isHit) {
              return true;
            }
          }
          break;
      }
    }
    return isHit;
  }
  function isPointInPath$3(displayObject, position, isClipPath, isPointInPath, runtime) {
    var _displayObject$parsed = displayObject.parsedStyle,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      stroke = _displayObject$parsed.stroke,
      fill = _displayObject$parsed.fill,
      _displayObject$parsed2 = _displayObject$parsed.defX,
      x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2,
      _displayObject$parsed3 = _displayObject$parsed.defY,
      y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3,
      path = _displayObject$parsed.path,
      pointerEvents = _displayObject$parsed.pointerEvents;
    var segments = path.segments,
      hasArc = path.hasArc,
      polylines = path.polylines,
      polygons = path.polygons;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents,
      // Only a closed path can be filled.
      (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill, stroke),
      hasFill = _isFillOrStrokeAffect[0],
      hasStroke = _isFillOrStrokeAffect[1];
    var totalLength = getOrCalculatePathTotalLength(displayObject);
    var isHit = false;
    if (hasFill || isClipPath) {
      if (hasArc) {
        //  canvas  api 
        isHit = isPointInPath(runtime, displayObject, position);
      } else {
        // 
        isHit = inPolygons(polygons, position.x + x, position.y + y) || inPolygons(polylines, position.x + x, position.y + y);
      }
      return isHit;
    } else if (hasStroke || isClipPath) {
      isHit = isPointInStroke(segments, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, totalLength);
    }
    return isHit;
  }

  function isPointInPath$4(displayObject, position, isClipPath) {
    var _displayObject$parsed = displayObject.parsedStyle,
      stroke = _displayObject$parsed.stroke,
      fill = _displayObject$parsed.fill,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      points = _displayObject$parsed.points,
      _displayObject$parsed2 = _displayObject$parsed.defX,
      x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2,
      _displayObject$parsed3 = _displayObject$parsed.defY,
      y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3,
      pointerEvents = _displayObject$parsed.pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasFill = _isFillOrStrokeAffect[0],
      hasStroke = _isFillOrStrokeAffect[1];
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, true);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = inPolygon(points.points, position.x + x, position.y + y);
    }
    return isHit;
  }

  function isPointInPath$5(displayObject, position, isClipPath) {
    var _displayObject$parsed = displayObject.parsedStyle,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      points = _displayObject$parsed.points,
      _displayObject$parsed2 = _displayObject$parsed.defX,
      x = _displayObject$parsed2 === void 0 ? 0 : _displayObject$parsed2,
      _displayObject$parsed3 = _displayObject$parsed.defY,
      y = _displayObject$parsed3 === void 0 ? 0 : _displayObject$parsed3,
      pointerEvents = _displayObject$parsed.pointerEvents,
      fill = _displayObject$parsed.fill,
      stroke = _displayObject$parsed.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasStroke = _isFillOrStrokeAffect[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inPolyline(points.points, (lineWidth || 0) + (increasedLineWidthForHitTesting || 0), position.x + x, position.y + y, false);
  }

  function isPointInPath$6(displayObject, position, isClipPath, isPointInPath, runtime) {
    var _displayObject$parsed = displayObject.parsedStyle,
      radius = _displayObject$parsed.radius,
      fill = _displayObject$parsed.fill,
      stroke = _displayObject$parsed.stroke,
      lineWidth = _displayObject$parsed.lineWidth,
      increasedLineWidthForHitTesting = _displayObject$parsed.increasedLineWidthForHitTesting,
      width = _displayObject$parsed.width,
      height = _displayObject$parsed.height,
      pointerEvents = _displayObject$parsed.pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke),
      hasFill = _isFillOrStrokeAffect[0],
      hasStroke = _isFillOrStrokeAffect[1];
    var hasRadius = radius && radius.some(function (r) {
      return r !== 0;
    });
    var lineWidthForHitTesting = (lineWidth || 0) + (increasedLineWidthForHitTesting || 0);
    // 
    if (!hasRadius) {
      var halfWidth = lineWidthForHitTesting / 2;
      // 
      if (hasFill && hasStroke || isClipPath) {
        return inBox(0 - halfWidth, 0 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
      }
      // 
      if (hasFill) {
        return inBox(0, 0, width, height, position.x, position.y);
      }
      if (hasStroke) {
        return inRect(0, 0, width, height, lineWidthForHitTesting, position.x, position.y);
      }
    } else {
      var isHit = false;
      if (hasStroke || isClipPath) {
        isHit = inRectWithRadius(0, 0, width, height, radius.map(function (r) {
          return clamp(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
        }), lineWidthForHitTesting, position.x, position.y);
      }
      // 
      // 
      if (!isHit && (hasFill || isClipPath)) {
        isHit = isPointInPath(runtime, displayObject, position);
      }
      return isHit;
    }
    return false;
  }
  function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x, y) {
    var tlr = radiusArray[0],
      trr = radiusArray[1],
      brr = radiusArray[2],
      blr = radiusArray[3];
    return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x, y) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x, y) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x, y) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x, y) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x, y) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
  }

  var Plugin$1 = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$3(Plugin, _AbstractRendererPlug);
    function Plugin() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
      _this.name = 'canvas-picker';
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      var _pointInPathPickerFac;
      var trueFunc = function trueFunc() {
        return true;
      };
      var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _pointInPathPickerFac[Shape.CIRCLE] = isPointInPath, _pointInPathPickerFac[Shape.ELLIPSE] = isPointInPath$1, _pointInPathPickerFac[Shape.RECT] = isPointInPath$6, _pointInPathPickerFac[Shape.LINE] = isPointInPath$2, _pointInPathPickerFac[Shape.POLYLINE] = isPointInPath$5, _pointInPathPickerFac[Shape.POLYGON] = isPointInPath$4, _pointInPathPickerFac[Shape.PATH] = isPointInPath$3, _pointInPathPickerFac[Shape.TEXT] = trueFunc, _pointInPathPickerFac[Shape.GROUP] = null, _pointInPathPickerFac[Shape.IMAGE] = trueFunc, _pointInPathPickerFac[Shape.HTML] = null, _pointInPathPickerFac[Shape.MESH] = null, _pointInPathPickerFac);
      // @ts-ignore
      this.context.pointInPathPickerFactory = pointInPathPickerFactory;
      this.addRenderingPlugin(new CanvasPickerPlugin());
    };
    _proto.destroy = function destroy() {
      // @ts-ignore
      delete this.context.pointInPathPickerFactory;
      this.removeAllRenderingPlugins();
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function _regeneratorRuntime$2() {
    _regeneratorRuntime$2 = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$2(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function _inheritsLoose$4(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$4(subClass, superClass);
  }
  function _setPrototypeOf$4(o, p) {
    _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$4(o, p);
  }

  /**
   * support 2 modes in rendering:
   * * immediate
   * * delayed: render at the end of frame with dirty-rectangle
   */
  var CanvasRendererPlugin = /*#__PURE__*/function () {
    /**
     * RBush used in dirty rectangle rendering
     */

    function CanvasRendererPlugin(canvasRendererPluginOptions) {
      this.canvasRendererPluginOptions = void 0;
      this.context = void 0;
      this.pathGeneratorFactory = void 0;
      this.rBush = void 0;
      this.removedRBushNodeAABBs = [];
      this.renderQueue = [];
      /**
       * This stack is only used by clipPath for now.
       */
      this.restoreStack = [];
      this.clearFullScreen = false;
      /**
       * view projection matrix
       */
      this.vpMatrix = create$1();
      this.dprMatrix = create$1();
      this.tmpMat4 = create$1();
      this.vec3a = create$2();
      this.vec3b = create$2();
      this.vec3c = create$2();
      this.vec3d = create$2();
      this.canvasRendererPluginOptions = canvasRendererPluginOptions;
    }
    var _proto = CanvasRendererPlugin.prototype;
    _proto.apply = function apply(context, runtime) {
      var _this = this;
      this.context = context;
      var config = context.config,
        camera = context.camera,
        renderingService = context.renderingService,
        renderingContext = context.renderingContext,
        rBushRoot = context.rBushRoot,
        pathGeneratorFactory = context.pathGeneratorFactory;
      this.rBush = rBushRoot;
      this.pathGeneratorFactory = pathGeneratorFactory;
      var contextService = context.contextService;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleUnmounted = function handleUnmounted(e) {
        var object = e.target;
        // remove r-bush node
        // @ts-ignore
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          // save removed aabbs for dirty-rectangle rendering later
          _this.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      var handleCulled = function handleCulled(e) {
        var object = e.target;
        // @ts-ignore
        var rBushNode = object.rBushNode;
        if (rBushNode.aabb) {
          // save removed aabbs for dirty-rectangle rendering later
          _this.removedRBushNodeAABBs.push(rBushNode.aabb);
        }
      };
      renderingService.hooks.init.tapPromise(CanvasRendererPlugin.tag, /*#__PURE__*/_asyncToGenerator$2( /*#__PURE__*/_regeneratorRuntime$2().mark(function _callee() {
        var dpr, width, height, context;
        return _regeneratorRuntime$2().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
              canvas.addEventListener(ElementEvent.CULLED, handleCulled);
              // clear fullscreen
              dpr = contextService.getDPR();
              width = config.width, height = config.height;
              context = contextService.getContext();
              _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      renderingService.hooks.destroy.tap(CanvasRendererPlugin.tag, function () {
        canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
        canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
        // this.renderQueue = [];
        // this.removedRBushNodeAABBs = [];
        // this.restoreStack = [];
      });

      renderingService.hooks.beginFrame.tap(CanvasRendererPlugin.tag, function () {
        var context = contextService.getContext();
        var dpr = contextService.getDPR();
        var width = config.width,
          height = config.height;
        var _this$canvasRendererP = _this.canvasRendererPluginOptions,
          dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold,
          dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
        // some heuristic conditions such as 80% object changed
        var _renderingService$get = renderingService.getStats(),
          total = _renderingService$get.total,
          rendered = _renderingService$get.rendered;
        var ratio = rendered / total;
        _this.clearFullScreen = renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
        if (context) {
          context.resetTransform ? context.resetTransform() : context.setTransform(1, 0, 0, 1, 0, 0);
          if (_this.clearFullScreen) {
            _this.clearRect(context, 0, 0, width * dpr, height * dpr, config.background);
          }
        }
      });
      var renderByZIndex = function renderByZIndex(object, context) {
        if (object.isVisible() && !object.isCulled()) {
          _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);
          // if (object.renderable.) {
          // if we did a full screen rendering last frame
          _this.saveDirtyAABB(object);
          // }
        }

        var sorted = object.sortable.sorted || object.childNodes;
        // should account for z-index
        sorted.forEach(function (child) {
          renderByZIndex(child, context);
        });
      };
      // render at the end of frame
      renderingService.hooks.endFrame.tap(CanvasRendererPlugin.tag, function () {
        var context = contextService.getContext();
        // clear & clip dirty rectangle
        var dpr = contextService.getDPR();
        fromScaling(_this.dprMatrix, [dpr, dpr, 1]);
        multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());
        // if (this.clearFullScreen) {
        if (_this.clearFullScreen) {
          // console.log('canvas renderer fcp...');
          renderByZIndex(renderingContext.root, context);
        } else {
          // console.log('canvas renderer next...');
          // merge removed AABB
          var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, [_this.mergeDirtyAABBs(_this.renderQueue)].concat(_this.removedRBushNodeAABBs.map(function (_ref2) {
            var minX = _ref2.minX,
              minY = _ref2.minY,
              maxX = _ref2.maxX,
              maxY = _ref2.maxY;
            var aabb = new AABB();
            aabb.setMinMax(
            // vec3.fromValues(minX, minY, 0),
            // vec3.fromValues(maxX, maxY, 0),
            [minX, minY, 0], [maxX, maxY, 0]);
            return aabb;
          })));
          _this.removedRBushNodeAABBs = [];
          if (AABB.isEmpty(dirtyRenderBounds)) {
            _this.renderQueue = [];
            return;
          }
          var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);
          var x = dirtyRect.x,
            y = dirtyRect.y,
            width = dirtyRect.width,
            height = dirtyRect.height;
          var tl = transformMat4(_this.vec3a, [x, y, 0], _this.vpMatrix);
          var tr = transformMat4(_this.vec3b, [x + width, y, 0], _this.vpMatrix);
          var bl = transformMat4(_this.vec3c, [x, y + height, 0], _this.vpMatrix);
          var br = transformMat4(_this.vec3d, [x + width, y + height, 0], _this.vpMatrix);
          var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
          var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
          var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
          var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
          var ix = Math.floor(minx);
          var iy = Math.floor(miny);
          var iwidth = Math.ceil(maxx - minx);
          var iheight = Math.ceil(maxy - miny);
          context.save();
          _this.clearRect(context, ix, iy, iwidth, iheight, config.background);
          context.beginPath();
          context.rect(ix, iy, iwidth, iheight);
          context.clip();
          // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations
          context.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);
          // draw dirty rectangle
          var _config$renderer$getC = config.renderer.getConfig(),
            enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
          if (enableDirtyRectangleRenderingDebug) {
            canvas.dispatchEvent(new CustomEvent(CanvasEvent.DIRTY_RECTANGLE, {
              dirtyRect: {
                x: ix,
                y: iy,
                width: iwidth,
                height: iheight
              }
            }));
          }
          // search objects intersect with dirty rectangle
          var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);
          // do rendering
          dirtyObjects
          // sort by z-index
          .sort(function (a, b) {
            return a.sortable.renderOrder - b.sortable.renderOrder;
          }).forEach(function (object) {
            // culled object should not be rendered
            if (object && object.isVisible() && !object.isCulled()) {
              _this.renderDisplayObject(object, context, _this.context, _this.restoreStack, runtime);
            }
          });
          context.restore();
          // save dirty AABBs in last frame
          _this.renderQueue.forEach(function (object) {
            _this.saveDirtyAABB(object);
          });
          // clear queue
          _this.renderQueue = [];
        }
        // pop restore stack, eg. root -> parent -> child
        _this.restoreStack.forEach(function () {
          context.restore();
        });
        // clear restore stack
        _this.restoreStack = [];
      });
      renderingService.hooks.render.tap(CanvasRendererPlugin.tag, function (object) {
        if (!_this.clearFullScreen) {
          // render at the end of frame
          _this.renderQueue.push(object);
        }
      });
    };
    _proto.clearRect = function clearRect(context, x, y, width, height, background) {
      // clearRect is faster than fillRect @see https://stackoverflow.com/a/30830253
      context.clearRect(x, y, width, height);
      if (background) {
        context.fillStyle = background;
        context.fillRect(x, y, width, height);
      }
    };
    _proto.renderDisplayObject = function renderDisplayObject(object, context, canvasContext, restoreStack, runtime) {
      var nodeName = object.nodeName;
      // console.log('canvas render:', object);
      // restore to its ancestor
      var parent = restoreStack[restoreStack.length - 1];
      if (parent && !(object.compareDocumentPosition(parent) & Node.DOCUMENT_POSITION_CONTAINS)) {
        context.restore();
        restoreStack.pop();
      }
      // @ts-ignore
      var styleRenderer = this.context.styleRendererFactory[nodeName];
      var generatePath = this.pathGeneratorFactory[nodeName];
      // clip path
      var clipPath = object.parsedStyle.clipPath;
      if (clipPath) {
        this.applyWorldTransform(context, clipPath);
        // generate path in local space
        var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
        if (_generatePath) {
          context.save();
          // save clip
          restoreStack.push(object);
          context.beginPath();
          _generatePath(context, clipPath.parsedStyle);
          context.closePath();
          context.clip();
        }
      }
      // fill & stroke
      if (styleRenderer) {
        this.applyWorldTransform(context, object);
        context.save();
        // apply attributes to context
        this.applyAttributesToContext(context, object);
      }
      if (generatePath) {
        context.beginPath();
        generatePath(context, object.parsedStyle);
        if (object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
          context.closePath();
        }
      }
      // fill & stroke
      if (styleRenderer) {
        styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime);
        // restore applied attributes, eg. shadowBlur shadowColor...
        context.restore();
      }
      // finish rendering, clear dirty flag
      object.renderable.dirty = false;
    };
    _proto.convertAABB2Rect = function convertAABB2Rect(aabb) {
      var min = aabb.getMin();
      var max = aabb.getMax();
      // expand the rectangle a bit to avoid artifacts
      // @see https://www.yuque.com/antv/ou292n/bi8nix#ExvCu
      var minX = Math.floor(min[0]);
      var minY = Math.floor(min[1]);
      var maxX = Math.ceil(max[0]);
      var maxY = Math.ceil(max[1]);
      var width = maxX - minX;
      var height = maxY - minY;
      return {
        x: minX,
        y: minY,
        width: width,
        height: height
      };
    }
    /**
     * TODO: merge dirty rectangles with some strategies.
     * For now, we just simply merge all the rectangles into one.
     * @see https://idom.me/articles/841.html
     */;
    _proto.mergeDirtyAABBs = function mergeDirtyAABBs(dirtyObjects) {
      // merge into a big AABB
      // TODO: skip descendant if ancestor is caculated, but compareNodePosition is really slow
      var aabb = new AABB();
      dirtyObjects.forEach(function (object) {
        var renderBounds = object.getRenderBounds();
        aabb.add(renderBounds);
        var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
        if (dirtyRenderBounds) {
          aabb.add(dirtyRenderBounds);
        }
      });
      return aabb;
    };
    _proto.searchDirtyObjects = function searchDirtyObjects(dirtyRectangle) {
      // search in r-tree, get all affected nodes
      var _dirtyRectangle$getMi = dirtyRectangle.getMin(),
        minX = _dirtyRectangle$getMi[0],
        minY = _dirtyRectangle$getMi[1];
      var _dirtyRectangle$getMa = dirtyRectangle.getMax(),
        maxX = _dirtyRectangle$getMa[0],
        maxY = _dirtyRectangle$getMa[1];
      var rBushNodes = this.rBush.search({
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
      });
      return rBushNodes.map(function (_ref3) {
        var displayObject = _ref3.displayObject;
        return displayObject;
      });
    };
    _proto.saveDirtyAABB = function saveDirtyAABB(object) {
      var renderable = object.renderable;
      if (!renderable.dirtyRenderBounds) {
        renderable.dirtyRenderBounds = new AABB();
      }
      var renderBounds = object.getRenderBounds();
      if (renderBounds) {
        // save last dirty aabb
        renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
      }
    }
    /**
     * TODO: batch the same global attributes
     */;
    _proto.applyAttributesToContext = function applyAttributesToContext(context, object) {
      var _object$parsedStyle = object.parsedStyle,
        stroke = _object$parsedStyle.stroke,
        fill = _object$parsedStyle.fill,
        opacity = _object$parsedStyle.opacity,
        lineDash = _object$parsedStyle.lineDash,
        lineDashOffset = _object$parsedStyle.lineDashOffset;
      // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/setLineDash
      if (lineDash) {
        context.setLineDash(lineDash);
      }
      // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/lineDashOffset
      if (!isNil(lineDashOffset)) {
        context.lineDashOffset = lineDashOffset;
      }
      if (!isNil(opacity)) {
        context.globalAlpha *= opacity;
      }
      if (!isNil(stroke) && !Array.isArray(stroke) && !stroke.isNone) {
        context.strokeStyle = object.attributes.stroke;
      }
      if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
        context.fillStyle = object.attributes.fill;
      }
    };
    _proto.applyWorldTransform = function applyWorldTransform(context, object, matrix) {
      var tx = 0;
      var ty = 0;
      var _ref4 = object.parsedStyle || {},
        anchor = _ref4.anchor;
      var anchorX = anchor && anchor[0] || 0;
      var anchorY = anchor && anchor[1] || 0;
      if (anchorX !== 0 || anchorY !== 0) {
        // const bounds = object.getGeometryBounds();
        var bounds = object.geometry.contentBounds;
        var width = bounds && bounds.halfExtents[0] * 2 || 0;
        var height = bounds && bounds.halfExtents[1] * 2 || 0;
        tx = -(anchorX * width);
        ty = -(anchorY * height);
      }
      // apply clip shape's RTS
      if (matrix) {
        copy(this.tmpMat4, object.getLocalTransform());
        this.vec3a[0] = tx;
        this.vec3a[1] = ty;
        this.vec3a[2] = 0;
        translate(this.tmpMat4, this.tmpMat4, this.vec3a);
        multiply(this.tmpMat4, matrix, this.tmpMat4);
        multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      } else {
        // apply RTS transformation in world space
        copy(this.tmpMat4, object.getWorldTransform());
        this.vec3a[0] = tx;
        this.vec3a[1] = ty;
        this.vec3a[2] = 0;
        translate(this.tmpMat4, this.tmpMat4, this.vec3a);
        multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
      }
      // @see https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Transformations
      context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
    };
    _proto.safeMergeAABB = function safeMergeAABB() {
      var merged = new AABB();
      for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
        aabbs[_key] = arguments[_key];
      }
      aabbs.forEach(function (aabb) {
        merged.add(aabb);
      });
      return merged;
    };
    return CanvasRendererPlugin;
  }();
  CanvasRendererPlugin.tag = 'CanvasRenderer';

  var DefaultRenderer = /*#__PURE__*/function () {
    function DefaultRenderer(imagePool) {
      this.imagePool = void 0;
      this.imagePool = imagePool;
    }
    var _proto = DefaultRenderer.prototype;
    _proto.render = function render(context, parsedStyle, object, canvasContext, plugin, runtime) {
      var fill = parsedStyle.fill,
        fillRule = parsedStyle.fillRule,
        opacity = parsedStyle.opacity,
        fillOpacity = parsedStyle.fillOpacity,
        stroke = parsedStyle.stroke,
        strokeOpacity = parsedStyle.strokeOpacity,
        lineWidth = parsedStyle.lineWidth,
        lineCap = parsedStyle.lineCap,
        lineJoin = parsedStyle.lineJoin,
        shadowType = parsedStyle.shadowType,
        shadowColor = parsedStyle.shadowColor,
        shadowBlur = parsedStyle.shadowBlur,
        filter = parsedStyle.filter,
        miterLimit = parsedStyle.miterLimit;
      var hasFill = !isNil(fill) && !fill.isNone;
      var hasStroke = !isNil(stroke) && !stroke.isNone && lineWidth > 0;
      var isFillTransparent = fill.alpha === 0;
      var hasFilter = !!(filter && filter.length);
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      var nodeName = object.nodeName;
      var isInnerShadow = shadowType === 'inner';
      var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
      if (hasFill) {
        context.globalAlpha = opacity * fillOpacity;
        if (!shouldDrawShadowWithStroke) {
          setShadowAndFilter(object, context, hasShadow);
        }
        this.fill(context, object, fill, fillRule, canvasContext, plugin, runtime);
        if (!shouldDrawShadowWithStroke) {
          this.clearShadowAndFilter(context, hasFilter, hasShadow);
        }
      }
      if (hasStroke) {
        context.globalAlpha = opacity * strokeOpacity;
        context.lineWidth = lineWidth;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        if (!isNil(lineCap)) {
          context.lineCap = lineCap;
        }
        if (!isNil(lineJoin)) {
          context.lineJoin = lineJoin;
        }
        if (shouldDrawShadowWithStroke) {
          if (isInnerShadow) {
            context.globalCompositeOperation = 'source-atop';
          }
          setShadowAndFilter(object, context, true);
          if (isInnerShadow) {
            this.stroke(context, object, stroke, canvasContext, plugin, runtime);
            context.globalCompositeOperation = 'source-over';
            this.clearShadowAndFilter(context, hasFilter, true);
          }
        }
        this.stroke(context, object, stroke, canvasContext, plugin, runtime);
      }
    };
    _proto.clearShadowAndFilter = function clearShadowAndFilter(context, hasFilter, hasShadow) {
      if (hasShadow) {
        context.shadowColor = 'transparent';
        context.shadowBlur = 0;
      }
      if (hasFilter) {
        // save drop-shadow filter
        var oldFilter = context.filter;
        if (!isNil(oldFilter) && oldFilter.indexOf('drop-shadow') > -1) {
          context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, '').trim() || 'none';
        }
      }
    };
    _proto.fill = function fill(context, object, _fill, fillRule, canvasContext, plugin, runtime) {
      var _this = this;
      if (Array.isArray(_fill)) {
        _fill.forEach(function (gradient) {
          context.fillStyle = _this.getColor(gradient, object, context);
          fillRule ? context.fill(fillRule) : context.fill();
        });
      } else {
        if (isPattern(_fill)) {
          context.fillStyle = this.getPattern(_fill, object, context, canvasContext, plugin, runtime);
        }
        fillRule ? context.fill(fillRule) : context.fill();
      }
    };
    _proto.stroke = function stroke(context, object, _stroke, canvasContext, plugin, runtime) {
      var _this2 = this;
      if (Array.isArray(_stroke)) {
        _stroke.forEach(function (gradient) {
          context.strokeStyle = _this2.getColor(gradient, object, context);
          context.stroke();
        });
      } else {
        if (isPattern(_stroke)) {
          context.strokeStyle = this.getPattern(_stroke, object, context, canvasContext, plugin, runtime);
        }
        context.stroke();
      }
    };
    _proto.getPattern = function getPattern(pattern, object, context, canvasContext, plugin, runtime) {
      var $offscreenCanvas;
      var dpr;
      if (pattern.image.nodeName === 'rect') {
        var _pattern$image$parsed = pattern.image.parsedStyle,
          width = _pattern$image$parsed.width,
          height = _pattern$image$parsed.height;
        dpr = canvasContext.contextService.getDPR();
        var offscreenCanvas = canvasContext.config.offscreenCanvas;
        $offscreenCanvas = runtime.offscreenCanvas.getOrCreateCanvas(offscreenCanvas);
        $offscreenCanvas.width = width * dpr;
        $offscreenCanvas.height = height * dpr;
        var offscreenCanvasContext = runtime.offscreenCanvas.getOrCreateContext(offscreenCanvas);
        var restoreStack = [];
        // offscreenCanvasContext.scale(1 / dpr, 1 / dpr);
        pattern.image.forEach(function (object) {
          plugin.renderDisplayObject(object, offscreenCanvasContext, canvasContext, restoreStack, runtime);
        });
        restoreStack.forEach(function () {
          offscreenCanvasContext.restore();
        });
      }
      var canvasPattern = this.imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, function () {
        // set dirty rectangle flag
        object.renderable.dirty = true;
        canvasContext.renderingService.dirtify();
      });
      return canvasPattern;
    };
    _proto.getColor = function getColor(parsedColor, object, context) {
      var color;
      if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
        var bounds = object.getGeometryBounds();
        var width = bounds && bounds.halfExtents[0] * 2 || 1;
        var height = bounds && bounds.halfExtents[1] * 2 || 1;
        color = this.imagePool.getOrCreateGradient(_extends$1({
          type: parsedColor.type
        }, parsedColor.value, {
          width: width,
          height: height
        }), context);
      }
      return color;
    };
    return DefaultRenderer;
  }();
  /**
   * apply before fill and stroke but only once
   */
  function setShadowAndFilter(object, context, hasShadow) {
    var _object$parsedStyle = object.parsedStyle,
      filter = _object$parsedStyle.filter,
      shadowColor = _object$parsedStyle.shadowColor,
      shadowBlur = _object$parsedStyle.shadowBlur,
      shadowOffsetX = _object$parsedStyle.shadowOffsetX,
      shadowOffsetY = _object$parsedStyle.shadowOffsetY;
    if (filter && filter.length) {
      // use raw filter string
      context.filter = object.style.filter;
    }
    if (hasShadow) {
      context.shadowColor = shadowColor.toString();
      context.shadowBlur = shadowBlur || 0;
      context.shadowOffsetX = shadowOffsetX || 0;
      context.shadowOffsetY = shadowOffsetY || 0;
    }
  }

  var ImageRenderer = /*#__PURE__*/function () {
    function ImageRenderer(imagePool) {
      this.imagePool = void 0;
      this.imagePool = imagePool;
    }
    var _proto = ImageRenderer.prototype;
    _proto.render = function render(context, parsedStyle, object) {
      var width = parsedStyle.width,
        height = parsedStyle.height,
        img = parsedStyle.img,
        shadowColor = parsedStyle.shadowColor,
        shadowBlur = parsedStyle.shadowBlur;
      var image;
      var iw = width;
      var ih = height;
      if (isString(img)) {
        // image has been loaded in `mounted` hook
        image = this.imagePool.getImageSync(img);
      } else {
        iw || (iw = img.width);
        ih || (ih = img.height);
        image = img;
      }
      if (image) {
        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        // node-canvas will throw the following err:
        // Error: Image given has not completed loading
        try {
          context.drawImage(image, 0, 0, iw, ih);
        } catch (e) {}
      }
    };
    return ImageRenderer;
  }();

  var TextRenderer = /*#__PURE__*/function () {
    function TextRenderer() {}
    var _proto = TextRenderer.prototype;
    _proto.render = function render(context, parsedStyle, object) {
      var lineWidth = parsedStyle.lineWidth,
        textAlign = parsedStyle.textAlign,
        textBaseline = parsedStyle.textBaseline,
        lineJoin = parsedStyle.lineJoin,
        miterLimit = parsedStyle.miterLimit,
        letterSpacing = parsedStyle.letterSpacing,
        stroke = parsedStyle.stroke,
        fill = parsedStyle.fill,
        fillOpacity = parsedStyle.fillOpacity,
        strokeOpacity = parsedStyle.strokeOpacity,
        opacity = parsedStyle.opacity,
        metrics = parsedStyle.metrics,
        dx = parsedStyle.dx,
        dy = parsedStyle.dy,
        shadowColor = parsedStyle.shadowColor,
        shadowBlur = parsedStyle.shadowBlur;
      var font = metrics.font,
        lines = metrics.lines,
        height = metrics.height,
        lineHeight = metrics.lineHeight,
        lineMetrics = metrics.lineMetrics;
      context.font = font;
      context.lineWidth = lineWidth;
      context.textAlign = textAlign === 'middle' ? 'center' : textAlign;
      var formattedTextBaseline = textBaseline;
      if (
      // formattedTextBaseline === 'bottom' ||
      !runtime.enableCSSParsing && formattedTextBaseline === 'alphabetic') {
        formattedTextBaseline = 'bottom';
      }
      context.lineJoin = lineJoin;
      if (!isNil(miterLimit)) {
        context.miterLimit = miterLimit;
      }
      var linePositionY = 0;
      // handle vertical text baseline
      if (textBaseline === 'middle') {
        linePositionY = -height / 2 - lineHeight / 2;
      } else if (textBaseline === 'bottom' || textBaseline === 'alphabetic' || textBaseline === 'ideographic') {
        linePositionY = -height;
      } else if (textBaseline === 'top' || textBaseline === 'hanging') {
        linePositionY = -lineHeight;
      }
      // account for dx & dy
      var offsetX = dx || 0;
      linePositionY += dy || 0;
      if (lines.length === 1) {
        if (formattedTextBaseline === 'bottom') {
          formattedTextBaseline = 'middle';
          linePositionY -= 0.5 * height;
        } else if (formattedTextBaseline === 'top') {
          formattedTextBaseline = 'middle';
          linePositionY += 0.5 * height;
        }
      }
      context.textBaseline = formattedTextBaseline;
      var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
      setShadowAndFilter(object, context, hasShadow);
      // draw lines line by line
      for (var i = 0; i < lines.length; i++) {
        var linePositionX = lineWidth / 2 + offsetX;
        linePositionY += lineHeight;
        // no need to re-position X, cause we already set text align
        // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign
        if (!isNil(stroke) && !stroke.isNone && lineWidth) {
          this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity, true);
        }
        if (!isNil(fill)) {
          this.drawLetterSpacing(context, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fillOpacity, strokeOpacity, opacity);
        }
      }
    };
    _proto.drawLetterSpacing = function drawLetterSpacing(context, text, lineMetrics, textAlign, x, y, letterSpacing, fillOpacity, strokeOpacity, opacity, isStroke) {
      if (isStroke === void 0) {
        isStroke = false;
      }
      // letterSpacing of 0 means normal, render all texts directly
      if (letterSpacing === 0) {
        if (isStroke) {
          this.strokeText(context, text, x, y, strokeOpacity);
        } else {
          this.fillText(context, text, x, y, fillOpacity, opacity);
        }
        return;
      }
      // draw text using left align
      var currentTextAlign = context.textAlign;
      context.textAlign = 'left';
      var currentPosition = x;
      if (textAlign === 'center' || textAlign === 'middle') {
        currentPosition = x - lineMetrics.width / 2;
      } else if (textAlign === 'right' || textAlign === 'end') {
        currentPosition = x - lineMetrics.width;
      }
      var stringArray = Array.from(text);
      var previousWidth = context.measureText(text).width;
      var currentWidth = 0;
      for (var i = 0; i < stringArray.length; ++i) {
        var currentChar = stringArray[i];
        if (isStroke) {
          this.strokeText(context, currentChar, currentPosition, y, strokeOpacity);
        } else {
          this.fillText(context, currentChar, currentPosition, y, fillOpacity, opacity);
        }
        currentWidth = context.measureText(text.substring(i + 1)).width;
        currentPosition += previousWidth - currentWidth + letterSpacing;
        previousWidth = currentWidth;
      }
      context.textAlign = currentTextAlign;
    };
    _proto.fillText = function fillText(context, text, x, y, fillOpacity, opacity) {
      var currentGlobalAlpha;
      var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = fillOpacity * opacity;
      }
      context.fillText(text, x, y);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    };
    _proto.strokeText = function strokeText(context, text, x, y, strokeOpacity) {
      var currentGlobalAlpha;
      var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
      if (applyOpacity) {
        currentGlobalAlpha = context.globalAlpha;
        context.globalAlpha = strokeOpacity;
      }
      context.strokeText(text, x, y);
      if (applyOpacity) {
        context.globalAlpha = currentGlobalAlpha;
      }
    };
    return TextRenderer;
  }();

  var Plugin$2 = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$4(Plugin, _AbstractRendererPlug);
    function Plugin(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _AbstractRendererPlug.call(this) || this;
      _this.options = void 0;
      _this.name = 'canvas-renderer';
      _this.options = options;
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      var _defaultStyleRenderer;
      var canvasRendererPluginOptions = _extends$1({
        dirtyObjectNumThreshold: 500,
        dirtyObjectRatioThreshold: 0.8
      }, this.options);
      // @ts-ignore
      var imagePool = this.context.imagePool;
      var defaultRenderer = new DefaultRenderer(imagePool);
      var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defaultStyleRenderer[Shape.CIRCLE] = defaultRenderer, _defaultStyleRenderer[Shape.ELLIPSE] = defaultRenderer, _defaultStyleRenderer[Shape.RECT] = defaultRenderer, _defaultStyleRenderer[Shape.IMAGE] = new ImageRenderer(imagePool), _defaultStyleRenderer[Shape.TEXT] = new TextRenderer(), _defaultStyleRenderer[Shape.LINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYLINE] = defaultRenderer, _defaultStyleRenderer[Shape.POLYGON] = defaultRenderer, _defaultStyleRenderer[Shape.PATH] = defaultRenderer, _defaultStyleRenderer[Shape.GROUP] = undefined, _defaultStyleRenderer[Shape.HTML] = undefined, _defaultStyleRenderer[Shape.MESH] = undefined, _defaultStyleRenderer);
      this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
      this.context.styleRendererFactory = defaultStyleRendererFactory;
      this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
    };
    _proto.destroy = function destroy() {
      this.removeAllRenderingPlugins();
      delete this.context.defaultStyleRendererFactory;
      delete this.context.styleRendererFactory;
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function _regeneratorRuntime$3() {
    _regeneratorRuntime$3 = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$3(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _inheritsLoose$5(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$5(subClass, superClass);
  }
  function _setPrototypeOf$5(o, p) {
    _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$5(o, p);
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  var ARRAY_TYPE$1 = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$6() {
    var out = new ARRAY_TYPE$1(16);

    if (ARRAY_TYPE$1 != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }

  var ImagePool = /*#__PURE__*/function () {
    function ImagePool(canvasConfig) {
      this.canvasConfig = void 0;
      this.imageCache = {};
      this.gradientCache = {};
      this.patternCache = {};
      this.canvasConfig = canvasConfig;
    }
    var _proto = ImagePool.prototype;
    _proto.getImageSync = function getImageSync(src, callback) {
      if (!this.imageCache[src]) {
        this.getOrCreateImage(src).then(function () {
          if (callback) {
            callback();
          }
        });
      } else {
        if (callback) {
          callback();
        }
      }
      return this.imageCache[src];
    };
    _proto.getOrCreateImage = function getOrCreateImage(src) {
      var _this = this;
      if (this.imageCache[src]) {
        return Promise.resolve(this.imageCache[src]);
      }
      // @see https://github.com/antvis/g/issues/938
      var createImage = this.canvasConfig.createImage;
      return new Promise(function (resolve, reject) {
        var image;
        if (createImage) {
          image = createImage(src);
        } else if (isBrowser) {
          image = new window.Image();
        }
        if (image) {
          image.onload = function () {
            resolve(image);
          };
          image.onerror = function (ev) {
            reject(ev);
          };
          image.crossOrigin = 'Anonymous';
          image.src = src;
          _this.imageCache[src] = image;
        }
      });
    };
    _proto.getOrCreatePatternSync = function getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, callback) {
      var patternKey = this.generatePatternKey(pattern);
      if (patternKey && this.patternCache[patternKey]) {
        return this.patternCache[patternKey];
      }
      var image = pattern.image,
        repetition = pattern.repetition,
        transform = pattern.transform;
      var src;
      var needScaleWithDPR = false;
      // Image URL
      if (isString(image)) {
        src = this.getImageSync(image, callback);
      } else if ($offscreenCanvas) {
        src = $offscreenCanvas;
        needScaleWithDPR = true;
      } else {
        src = image;
      }
      // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createPattern
      var canvasPattern = src && context.createPattern(src, repetition);
      if (canvasPattern) {
        var mat;
        // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasPattern/setTransform
        if (transform) {
          mat = parsedTransformToMat4(parseTransform(transform));
        } else {
          mat = identity$2(create$6());
        }
        if (needScaleWithDPR) {
          scale$3(mat, mat, [1 / dpr, 1 / dpr, 1]);
        }
        canvasPattern.setTransform({
          a: mat[0],
          b: mat[1],
          c: mat[4],
          d: mat[5],
          e: mat[12],
          f: mat[13]
        });
      }
      if (patternKey && canvasPattern) {
        this.patternCache[patternKey] = canvasPattern;
      }
      return canvasPattern;
    };
    _proto.getOrCreateGradient = function getOrCreateGradient(params, context) {
      var key = this.generateGradientKey(params);
      var type = params.type,
        steps = params.steps,
        width = params.width,
        height = params.height,
        angle = params.angle,
        cx = params.cx,
        cy = params.cy,
        size = params.size;
      if (this.gradientCache[key]) {
        return this.gradientCache[key];
      }
      var gradient = null;
      if (type === GradientType.LinearGradient) {
        var _computeLinearGradien = computeLinearGradient(width, height, angle),
          x1 = _computeLinearGradien.x1,
          y1 = _computeLinearGradien.y1,
          x2 = _computeLinearGradien.x2,
          y2 = _computeLinearGradien.y2;
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createLinearGradient
        gradient = context.createLinearGradient(x1, y1, x2, y2);
      } else if (type === GradientType.RadialGradient) {
        var _computeRadialGradien = computeRadialGradient(width, height, cx, cy, size),
          x = _computeRadialGradien.x,
          y = _computeRadialGradien.y,
          r = _computeRadialGradien.r;
        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/createRadialGradient
        gradient = context.createRadialGradient(x, y, 0, x, y, r);
      }
      if (gradient) {
        steps.forEach(function (_ref) {
          var offset = _ref.offset,
            color = _ref.color;
          if (offset.unit === UnitType.kPercentage) {
            var _gradient;
            (_gradient = gradient) === null || _gradient === void 0 ? void 0 : _gradient.addColorStop(offset.value / 100, color.toString());
          }
        });
        this.gradientCache[key] = gradient;
      }
      return this.gradientCache[key];
    };
    _proto.generateGradientKey = function generateGradientKey(params) {
      var type = params.type,
        width = params.width,
        height = params.height,
        steps = params.steps,
        angle = params.angle,
        cx = params.cx,
        cy = params.cy,
        size = params.size;
      return "gradient-" + type + "-" + ((angle === null || angle === void 0 ? void 0 : angle.toString()) || 0) + "-" + ((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0) + "-" + ((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0) + "-" + ((size === null || size === void 0 ? void 0 : size.toString()) || 0) + "-" + width + "-" + height + "-" + steps.map(function (_ref2) {
        var offset = _ref2.offset,
          color = _ref2.color;
        return "" + offset + color;
      }).join('-');
    };
    _proto.generatePatternKey = function generatePatternKey(pattern) {
      var image = pattern.image,
        repetition = pattern.repetition;
      // only generate cache for Image
      if (isString(image)) {
        return "pattern-" + image + "-" + repetition;
      } else if (image.nodeName === 'rect') {
        return "pattern-" + image.entity + "-" + repetition;
      }
    };
    return ImagePool;
  }();

  var LoadImagePlugin = /*#__PURE__*/function () {
    function LoadImagePlugin() {}
    var _proto = LoadImagePlugin.prototype;
    _proto.apply = function apply(context) {
      // @ts-ignore
      var renderingService = context.renderingService,
        renderingContext = context.renderingContext,
        imagePool = context.imagePool;
      var canvas = renderingContext.root.ownerDocument.defaultView;
      var handleMounted = function handleMounted(e) {
        var object = e.target;
        var nodeName = object.nodeName,
          attributes = object.attributes;
        if (nodeName === Shape.IMAGE) {
          var img = attributes.img;
          if (isString(img)) {
            imagePool.getImageSync(img, function () {
              // set dirty rectangle flag
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        }
      };
      var handleAttributeChanged = function handleAttributeChanged(e) {
        var object = e.target;
        var attrName = e.attrName,
          newValue = e.newValue;
        if (object.nodeName === Shape.IMAGE) {
          if (attrName === 'img') {
            if (isString(newValue)) {
              imagePool.getOrCreateImage(newValue).then(function () {
                // set dirty rectangle flag
                object.renderable.dirty = true;
                renderingService.dirtify();
              });
            }
          }
        }
      };
      renderingService.hooks.init.tapPromise(LoadImagePlugin.tag, /*#__PURE__*/_asyncToGenerator$3( /*#__PURE__*/_regeneratorRuntime$3().mark(function _callee() {
        return _regeneratorRuntime$3().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
              canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      renderingService.hooks.destroy.tap(LoadImagePlugin.tag, function () {
        canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
        canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
      });
    };
    return LoadImagePlugin;
  }();
  LoadImagePlugin.tag = 'LoadImage';

  var Plugin$3 = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$5(Plugin, _AbstractRendererPlug);
    function Plugin() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
      _this.name = 'image-loader';
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      // @ts-ignore
      this.context.imagePool = new ImagePool(this.context.config);
      this.addRenderingPlugin(new LoadImagePlugin());
    };
    _proto.destroy = function destroy() {
      this.removeAllRenderingPlugins();
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function _regeneratorRuntime$4() {
    _regeneratorRuntime$4 = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$4(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$4(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _inheritsLoose$6(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$6(subClass, superClass);
  }
  function _setPrototypeOf$6(o, p) {
    _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$6(o, p);
  }

  /**
   * listen to mouse/touch/pointer events on DOM wrapper, trigger pointer events
   */
  var MobileInteractionPlugin = /*#__PURE__*/function () {
    function MobileInteractionPlugin() {}
    var _proto = MobileInteractionPlugin.prototype;
    _proto.apply = function apply(context) {
      var renderingService = context.renderingService,
        contextService = context.contextService,
        config = context.config;
      // 
      var canvasEl = contextService.getDomElement();
      var onPointerDown = function onPointerDown(ev) {
        renderingService.hooks.pointerDown.call(ev);
      };
      var onPointerUp = function onPointerUp(ev) {
        renderingService.hooks.pointerUp.call(ev);
      };
      var onPointerMove = function onPointerMove(ev) {
        //  G  pointerMove 
        renderingService.hooks.pointerMove.call(ev);
      };
      var onPointerOver = function onPointerOver(ev) {
        renderingService.hooks.pointerOver.call(ev);
      };
      var onPointerOut = function onPointerOut(ev) {
        renderingService.hooks.pointerOut.call(ev);
      };
      var onClick = function onClick(ev) {
        renderingService.hooks.click.call(ev);
      };
      var onPointerCancel = function onPointerCancel(ev) {
        renderingService.hooks.pointerCancel.call(ev);
      };
      renderingService.hooks.init.tapPromise(MobileInteractionPlugin.tag, /*#__PURE__*/_asyncToGenerator$4( /*#__PURE__*/_regeneratorRuntime$4().mark(function _callee() {
        return _regeneratorRuntime$4().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              //  DOM 
              canvasEl.addEventListener('touchstart', onPointerDown, true);
              canvasEl.addEventListener('touchend', onPointerUp, true);
              canvasEl.addEventListener('touchmove', onPointerMove, true);
              canvasEl.addEventListener('touchcancel', onPointerCancel, true);
              // FIXME:  canvasEl  mousemove  mouseup document 
              //  canvasEl
              // canvasEl.addEventListener('mousemove', onPointerMove, true);
              // canvasEl.addEventListener('mousedown', onPointerDown, true);
              canvasEl.addEventListener('mouseout', onPointerOut, true);
              canvasEl.addEventListener('mouseover', onPointerOver, true);
              // canvasEl.addEventListener('mouseup', onPointerUp, true);
              if (config.useNativeClickEvent) {
                canvasEl.addEventListener('click', onClick, true);
              }
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
      renderingService.hooks.destroy.tap(MobileInteractionPlugin.tag, function () {
        // 
        canvasEl.removeEventListener('touchstart', onPointerDown, true);
        canvasEl.removeEventListener('touchend', onPointerUp, true);
        canvasEl.removeEventListener('touchmove', onPointerMove, true);
        canvasEl.removeEventListener('touchcancel', onPointerCancel, true);
        // canvasEl.removeEventListener('mousemove', onPointerMove, true);
        // canvasEl.removeEventListener('mousedown', onPointerDown, true);
        canvasEl.removeEventListener('mouseout', onPointerOut, true);
        canvasEl.removeEventListener('mouseover', onPointerOver, true);
        // canvasEl.removeEventListener('mouseup', onPointerUp, true);
        if (config.useNativeClickEvent) {
          canvasEl.removeEventListener('click', onClick, true);
        }
      });
    };
    return MobileInteractionPlugin;
  }();
  MobileInteractionPlugin.tag = 'MobileInteraction';

  var Plugin$4 = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$6(Plugin, _AbstractRendererPlug);
    function Plugin() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
      _this.name = 'mobile-interaction';
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      this.addRenderingPlugin(new MobileInteractionPlugin());
    };
    _proto.destroy = function destroy() {
      this.removeAllRenderingPlugins();
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function _regeneratorRuntime$5() {
    _regeneratorRuntime$5 = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$5(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$5(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _inheritsLoose$7(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$7(subClass, superClass);
  }
  function _setPrototypeOf$7(o, p) {
    _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$7(o, p);
  }

  function _regeneratorRuntime$1$1() {
    _regeneratorRuntime$1$1 = function _regeneratorRuntime() {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function stop() {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep$1$1(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator$1$1(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep$1$1(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep$1$1(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  function _inheritsLoose$1$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1$1(subClass, superClass);
  }
  function _setPrototypeOf$1$1(o, p) {
    _setPrototypeOf$1$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1$1(o, p);
  }
  var DragndropPlugin = /*#__PURE__*/function () {
    function DragndropPlugin(dragndropPluginOptions) {
      this.dragndropPluginOptions = void 0;
      this.dragndropPluginOptions = dragndropPluginOptions;
    }
    var _proto = DragndropPlugin.prototype;
    _proto.apply = function apply(context) {
      var _this = this;
      var renderingService = context.renderingService,
        renderingContext = context.renderingContext;
      var document = renderingContext.root.ownerDocument;
      // TODO: should we add an option like `draggable` to Canvas
      var canvas = document.defaultView;
      var handlePointerdown = function handlePointerdown(event) {
        var target = event.target;
        var isDocument = target === document;
        var draggableEventTarget = isDocument && _this.dragndropPluginOptions.isDocumentDraggable ? document : target.closest && target.closest('[draggable=true]');
        // `draggable` may be set on ancestor nodes:
        // @see https://github.com/antvis/G/issues/1088
        if (draggableEventTarget) {
          // delay triggering dragstart event
          var dragstartTriggered = false;
          var dragstartTimeStamp = event.timeStamp;
          var dragstartClientCoordinates = [event.clientX, event.clientY];
          var currentDroppable = null;
          var lastDragClientCoordinates = [event.clientX, event.clientY];
          // @ts-ignore
          // eslint-disable-next-line no-inner-declarations
          var handlePointermove = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator$1$1( /*#__PURE__*/_regeneratorRuntime$1$1().mark(function _callee(event) {
              var timeElapsed, distanceMoved, point, elementsBelow, elementBelow, droppableBelow;
              return _regeneratorRuntime$1$1().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (dragstartTriggered) {
                      _context.next = 8;
                      break;
                    }
                    timeElapsed = event.timeStamp - dragstartTimeStamp;
                    distanceMoved = distanceSquareRoot([event.clientX, event.clientY], dragstartClientCoordinates); // check thresholds
                    if (!(timeElapsed <= _this.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this.dragndropPluginOptions.dragstartDistanceThreshold)) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragstart_event
                    event.type = 'dragstart';
                    draggableEventTarget.dispatchEvent(event);
                    dragstartTriggered = true;
                  case 8:
                    // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drag_event
                    event.type = 'drag';
                    // @ts-ignore
                    event.dx = event.clientX - lastDragClientCoordinates[0];
                    // @ts-ignore
                    event.dy = event.clientY - lastDragClientCoordinates[1];
                    draggableEventTarget.dispatchEvent(event);
                    lastDragClientCoordinates = [event.clientX, event.clientY];
                    if (isDocument) {
                      _context.next = 21;
                      break;
                    }
                    point = _this.dragndropPluginOptions.overlap === 'pointer' ? [event.canvasX, event.canvasY] : target.getBounds().center;
                    _context.next = 17;
                    return document.elementsFromPoint(point[0], point[1]);
                  case 17:
                    elementsBelow = _context.sent;
                    // prevent from picking the dragging element
                    elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                    droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest('[droppable=true]')) || (_this.dragndropPluginOptions.isDocumentDroppable ? document : null);
                    if (currentDroppable !== droppableBelow) {
                      if (currentDroppable) {
                        // null when we were not over a droppable before this event
                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragleave_event
                        event.type = 'dragleave';
                        event.target = currentDroppable;
                        currentDroppable.dispatchEvent(event);
                      }
                      if (droppableBelow) {
                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragleave_event
                        event.type = 'dragenter';
                        event.target = droppableBelow;
                        droppableBelow.dispatchEvent(event);
                      }
                      currentDroppable = droppableBelow;
                      if (currentDroppable) {
                        // null if we're not coming over a droppable now
                        // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragover_event
                        event.type = 'dragover';
                        event.target = currentDroppable;
                        currentDroppable.dispatchEvent(event);
                      }
                    }
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function handlePointermove(_x) {
              return _ref.apply(this, arguments);
            };
          }();
          canvas.addEventListener('pointermove', handlePointermove);
          var stopDragging = function stopDragging(originalPointerUpEvent) {
            if (dragstartTriggered) {
              // prevent click event being triggerd
              // @see https://github.com/antvis/G/issues/1091
              originalPointerUpEvent.detail = {
                preventClick: true
              };
              // clone event first
              var _event = originalPointerUpEvent.clone();
              // drop should fire before dragend
              // @see https://javascript.tutorialink.com/is-there-a-defined-ordering-between-dragend-and-drop-events/
              if (currentDroppable) {
                // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/drop_event
                _event.type = 'drop';
                _event.target = currentDroppable;
                currentDroppable.dispatchEvent(_event);
              }
              // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/dragend_event
              _event.type = 'dragend';
              draggableEventTarget.dispatchEvent(_event);
              dragstartTriggered = false;
            }
            canvas.removeEventListener('pointermove', handlePointermove);
          };
          target.addEventListener('pointerup', stopDragging, {
            once: true
          });
          target.addEventListener('pointerupoutside', stopDragging, {
            once: true
          });
        }
      };
      renderingService.hooks.init.tapPromise(DragndropPlugin.tag, /*#__PURE__*/_asyncToGenerator$1$1( /*#__PURE__*/_regeneratorRuntime$1$1().mark(function _callee2() {
        return _regeneratorRuntime$1$1().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              canvas.addEventListener('pointerdown', handlePointerdown);
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      })));
      renderingService.hooks.destroy.tap(DragndropPlugin.tag, function () {
        canvas.removeEventListener('pointerdown', handlePointerdown);
      });
    };
    return DragndropPlugin;
  }();
  DragndropPlugin.tag = 'Dragndrop';
  var Plugin$5 = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$1$1(Plugin, _AbstractRendererPlug);
    function Plugin(options) {
      var _this;
      if (options === void 0) {
        options = {};
      }
      _this = _AbstractRendererPlug.call(this) || this;
      _this.options = void 0;
      _this.name = 'dragndrop';
      _this.options = options;
      return _this;
    }
    var _proto = Plugin.prototype;
    _proto.init = function init() {
      this.addRenderingPlugin(new DragndropPlugin(_extends$2({
        overlap: 'pointer',
        isDocumentDraggable: false,
        isDocumentDroppable: false,
        dragstartDistanceThreshold: 0,
        dragstartTimeThreshold: 0
      }, this.options)));
    };
    _proto.destroy = function destroy() {
      this.removeAllRenderingPlugins();
    };
    _proto.setOptions = function setOptions(options) {
      Object.assign(this.plugins[0].dragndropPluginOptions, options);
    };
    return Plugin;
  }(AbstractRendererPlugin);

  function isCanvasElement(el) {
    if (!el || typeof el !== 'object') return false;
    if (el.nodeType === 1 && el.nodeName) {
      // HTMLCanvasElement
      return true;
    }
    // CanvasElement
    return !!el.isCanvasElement;
  }

  var Canvas2DContextService = /*#__PURE__*/function () {
    function Canvas2DContextService(context) {
      this.$canvas = void 0;
      this.dpr = void 0;
      this.context = void 0;
      this.canvasConfig = void 0;
      this.canvasConfig = context.config;
    }
    var _proto = Canvas2DContextService.prototype;
    _proto.init = /*#__PURE__*/function () {
      var _init = _asyncToGenerator$5( /*#__PURE__*/_regeneratorRuntime$5().mark(function _callee() {
        var _this$canvasConfig, canvas, devicePixelRatio, dpr;
        return _regeneratorRuntime$5().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this$canvasConfig = this.canvasConfig, canvas = _this$canvasConfig.canvas, devicePixelRatio = _this$canvasConfig.devicePixelRatio;
              this.$canvas = canvas;
              // 
              this.context = this.$canvas.getContext('2d');
              // use user-defined dpr first
              dpr = devicePixelRatio || 1;
              dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
              this.dpr = dpr;
              this.resize(this.canvasConfig.width, this.canvasConfig.height);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }();
    _proto.getContext = function getContext() {
      return this.context;
    };
    _proto.getDomElement = function getDomElement() {
      return this.$canvas;
    };
    _proto.getDPR = function getDPR() {
      return this.dpr;
    };
    _proto.getBoundingClientRect = function getBoundingClientRect() {
      if (this.$canvas.getBoundingClientRect) {
        return this.$canvas.getBoundingClientRect();
      }
    };
    _proto.destroy = function destroy() {
      // TODO:  context
      this.context = null;
      this.$canvas = null;
    };
    _proto.resize = function resize(width, height) {
      var devicePixelRatio = this.canvasConfig.devicePixelRatio;
      var pixelRatio = devicePixelRatio;
      var canvasDOM = this.$canvas; // HTMLCanvasElement or canvasElement
      // style
      if (canvasDOM.style) {
        canvasDOM.style.width = width + 'px';
        canvasDOM.style.height = height + 'px';
      }
      if (isCanvasElement(canvasDOM)) {
        canvasDOM.width = width * pixelRatio;
        canvasDOM.height = height * pixelRatio;
        if (pixelRatio !== 1) {
          this.context.scale(pixelRatio, pixelRatio);
        }
      }
    };
    _proto.applyCursorStyle = function applyCursorStyle(cursor) {
      // 
    };
    _proto.toDataURL = /*#__PURE__*/function () {
      var _toDataURL = _asyncToGenerator$5( /*#__PURE__*/_regeneratorRuntime$5().mark(function _callee2(options) {
        var type, encoderOptions;
        return _regeneratorRuntime$5().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              type = options.type, encoderOptions = options.encoderOptions;
              return _context2.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function toDataURL(_x) {
        return _toDataURL.apply(this, arguments);
      }
      return toDataURL;
    }();
    return Canvas2DContextService;
  }();

  var ContextRegisterPlugin = /*#__PURE__*/function (_AbstractRendererPlug) {
    _inheritsLoose$7(ContextRegisterPlugin, _AbstractRendererPlug);
    function ContextRegisterPlugin() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _AbstractRendererPlug.call.apply(_AbstractRendererPlug, [this].concat(args)) || this;
      _this.name = 'mobile-canvas-context-register';
      return _this;
    }
    var _proto = ContextRegisterPlugin.prototype;
    _proto.init = function init() {
      this.context.ContextService = Canvas2DContextService;
    };
    _proto.destroy = function destroy() {
      delete this.context.ContextService;
    };
    return ContextRegisterPlugin;
  }(AbstractRendererPlugin);

  var Renderer = /*#__PURE__*/function (_AbstractRenderer) {
    _inheritsLoose$7(Renderer, _AbstractRenderer);
    function Renderer(config) {
      var _this;
      _this = _AbstractRenderer.call(this, config) || this;
      // register Canvas2DContext
      _this.registerPlugin(new ContextRegisterPlugin());
      _this.registerPlugin(new Plugin$3());
      _this.registerPlugin(new Plugin());
      // enable rendering with Canvas2D API
      _this.registerPlugin(new Plugin$2());
      _this.registerPlugin(new Plugin$4());
      // enable picking with Canvas2D API
      _this.registerPlugin(new Plugin$1());
      _this.registerPlugin(new Plugin$5({
        isDocumentDraggable: isNil(config === null || config === void 0 ? void 0 : config.isDocumentDraggable) ? true : config.isDocumentDraggable,
        isDocumentDroppable: isNil(config === null || config === void 0 ? void 0 : config.isDocumentDroppable) ? true : config.isDocumentDroppable,
        dragstartDistanceThreshold: isNil(config === null || config === void 0 ? void 0 : config.dragstartDistanceThreshold) ? 10 : config.dragstartDistanceThreshold,
        dragstartTimeThreshold: isNil(config === null || config === void 0 ? void 0 : config.dragstartTimeThreshold) ? 50 : config.dragstartTimeThreshold
      }));
      return _this;
    }
    return Renderer;
  }(AbstractRenderer);

  // jsx-classic 
  function jsx(type, config) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      children[_i - 2] = arguments[_i];
    }
    var _a = config || {},
      key = _a.key,
      ref = _a.ref,
      props = __rest(_a, ["key", "ref"]);
    // automatic
    if (children.length) {
      props.children = children.length === 1 ? children[0] : children;
    }
    return {
      key: key,
      ref: ref,
      type: type,
      props: props
    };
  }

  var fragment = (function (props) {
    return props.children;
  });

  var CanvasElement = /*#__PURE__*/function () {
    function CanvasElement(ctx) {
      this.width = void 0;
      this.height = void 0;
      this.isCanvasElement = true;
      this.context = void 0;
      this.emitter = new eventemitter3();
      this.context = ctx;
      //  node canvas  context 
      var canvas = ctx.canvas || {};
      this.width = canvas.width || 0;
      this.height = canvas.height || 0;
    }
    var _proto = CanvasElement.prototype;
    _proto.getContext = function getContext(contextId, contextAttributes) {
      return this.context;
    };
    _proto.getBoundingClientRect = function getBoundingClientRect() {
      var width = this.width;
      var height = this.height;
      // 
      return {
        top: 0,
        right: width,
        bottom: height,
        left: 0,
        width: width,
        height: height,
        x: 0,
        y: 0
      };
    };
    _proto.addEventListener = function addEventListener(type, listener, options) {
      // TODO: implement options
      this.emitter.on(type, listener);
    };
    _proto.removeEventListener = function removeEventListener(type, listener, options) {
      this.emitter.off(type, listener);
    }
    /**
     * @see https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-dispatchEvent
     */;
    _proto.dispatchEvent = function dispatchEvent(e) {
      this.emitter.emit(e.type, e);
      return true;
    };
    return CanvasElement;
  }();
  function supportEventListener(canvas) {
    if (!canvas) {
      return false;
    }
    //  HTMLCanvasElement
    if (canvas.nodeType !== 1 || !canvas.nodeName || canvas.nodeName.toLowerCase() !== 'canvas') {
      return false;
    }
    // canvas.getContext('2d')CanvasRenderingContext2D
    // ctx.canvas, nodeType1addEventListener
    var support = false;
    try {
      canvas.addEventListener('eventTest', function () {
        support = true;
      });
      canvas.dispatchEvent(new Event('eventTest'));
    } catch (error) {
      support = false;
    }
    return support;
  }
  function createMobileCanvasElement(ctx) {
    if (!ctx) {
      return null;
    }
    if (supportEventListener(ctx.canvas)) {
      return ctx.canvas;
    }
    return new CanvasElement(ctx);
  }

  function createUpdater(canvas) {
    var setStateQueue = [];
    function process() {
      var item;
      var renderComponents = [];
      var renderCallbackQueue = [];
      while (item = setStateQueue.shift()) {
        var state = item.state,
          component = item.component,
          callback = item.callback;
        //  setState
        if (component.destroyed) {
          continue;
        }
        // prevStatestateprevState
        if (!component.prevState) {
          component.prevState = Object.assign({}, component.state);
        }
        // stateChangesetState
        if (typeof state === 'function') {
          Object.assign(component.state, state(component.prevState, component.props));
        } else {
          // stateChangesetState
          Object.assign(component.state, state);
        }
        component.prevState = component.state;
        if (typeof callback === 'function') {
          renderCallbackQueue.push({
            callback: callback,
            component: component
          });
        }
        if (renderComponents.indexOf(component) < 0) {
          renderComponents.push(component);
        }
      }
      canvas.updateComponents(renderComponents);
      // callback queue
      commitRenderQueue(renderCallbackQueue);
    }
    function enqueueSetState(component, state, callback) {
      if (setStateQueue.length === 0) {
        setTimeout(process, 0);
      }
      setStateQueue.push({
        component: component,
        state: state,
        callback: callback
      });
    }
    function commitRenderQueue(callbackQueue) {
      for (var i = 0; i < callbackQueue.length; i++) {
        var _a = callbackQueue[i],
          callback = _a.callback,
          component = _a.component;
        callback.call(component);
      }
    }
    var updater = {
      // isMounted: function(publicInstance) {
      //   return false;
      // },
      enqueueForceUpdate: enqueueSetState,
      // enqueueReplaceState: function(publicInstance, completeState) {
      // },
      enqueueSetState: enqueueSetState
    };
    return updater;
  }

  var THEME = {
    fontSize: '24px',
    fontFamily: '"Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif',
    pixelRatio: 1,
    padding: [0, 0, 0, 0]
  };

  var elementStyle = {
    fillStyle: 'String',
    font: 'String',
    globalAlpha: 'Number',
    lineCap: 'String',
    lineWidth: ['Number', 'String'],
    lineJoin: 'String',
    miterLimit: 'Number',
    shadowBlur: 'Number',
    shadowColor: 'String',
    shadowOffsetX: 'Number',
    shadowOffsetY: 'Number',
    strokeStyle: 'String',
    textAlign: 'String',
    textBaseline: 'String',
    lineDash: ['Array', 'Number'],
    shadow: 'String',
    matrix: 'Array',
    stroke: 'String',
    fill: ['String', 'Object'],
    opacity: 'Number',
    fillOpacity: 'Number',
    strokeOpacity: 'Number'
  };
  // css TODO / 
  var DEFAULT_CSS_RULE = {
    group: __assign({}, elementStyle),
    text: __assign(__assign({}, elementStyle), {
      x: 'Number',
      y: 'Number',
      text: 'String',
      width: 'Number',
      height: 'Number',
      fontSize: ['Number', 'String'],
      fontFamily: 'String',
      fontStyle: 'String',
      fontWeight: ['Number', 'String'],
      fontVariant: 'String'
    }),
    circle: __assign(__assign({}, elementStyle), {
      cx: 'Number',
      cy: 'Number',
      r: 'Number'
    }),
    path: __assign({}, elementStyle),
    ellipse: __assign(__assign({}, elementStyle), {
      cy: 'Number',
      cx: 'Number',
      ry: 'Number',
      rx: 'Number'
    }),
    rect: __assign(__assign({}, elementStyle), {
      width: 'Number',
      height: 'Number',
      x: 'Number',
      y: 'Number',
      radius: ['Array', 'Number']
    }),
    image: __assign(__assign({}, elementStyle), {
      width: 'Number',
      height: 'Number',
      x: 'Number',
      y: 'Number',
      img: 'String',
      src: 'String'
    }),
    line: __assign(__assign({}, elementStyle), {
      x1: 'Number',
      x2: 'Number',
      y1: 'Number',
      y2: 'Number'
    }),
    polyline: __assign(__assign({}, elementStyle), {
      points: 'Array',
      smooth: 'Boolean'
    }),
    polygon: __assign(__assign({}, elementStyle), {
      points: 'Array'
    }),
    arc: __assign(__assign({}, elementStyle), {
      x: 'Number',
      y: 'Number',
      r: 'Number',
      startAngle: ['Number', 'String'],
      endAngle: ['Number', 'String'],
      anticlockwise: 'Boolean'
    }),
    marker: __assign(__assign({}, elementStyle), {
      x: 'Number',
      y: 'Number',
      radius: 'Number',
      symbol: 'String'
    }),
    sector: __assign(__assign({}, elementStyle), {
      x: 'Number',
      y: 'Number',
      startAngle: ['Number', 'String'],
      endAngle: ['Number', 'String'],
      r: 'Number',
      r0: 'Number',
      anticlockwise: 'Boolean'
    })
  };
  function checkCSSRule(type, style) {
    if (!style) {
      return style;
    }
    var cssStyle = {};
    Object.keys(style).forEach(function (key) {
      var value = style[key];
      if (isNil(value)) {
        return;
      }
      var rule = DEFAULT_CSS_RULE[type] && DEFAULT_CSS_RULE[type][key];
      if (!rule) {
        cssStyle[key] = value;
        return;
      }
      var valueType = Object.prototype.toString.call(value);
      if (isArray(rule)) {
        for (var i = 0, len = rule.length; i < len; i++) {
          if (valueType === "[object ".concat(rule[i], "]")) {
            cssStyle[key] = value;
            return;
          }
        }
        // 
        return;
      }
      // string
      if (valueType === "[object ".concat(rule, "]")) {
        cssStyle[key] = value;
      }
    });
    return cssStyle;
  }

  // 50
  var ONE_REM;
  try {
    // xgraph
    ONE_REM = parseInt(document.documentElement.style.fontSize, 10) || 50;
  } catch (e) {
    ONE_REM = 50;
  }
  var SCALE = ONE_REM / 100;
  /**
   * 
   * @param {Number} px - 750
   * @return {Number} 
   */
  function defaultPx2hd(px) {
    if (!px) {
      return 0;
    }
    return Number((px * SCALE).toFixed(1));
  }
  function parsePadding(padding) {
    if (isNumber(padding)) {
      return [padding, padding, padding, padding];
    }
    var top = padding[0];
    var right = isNumber(padding[1]) ? padding[1] : padding[0];
    var bottom = isNumber(padding[2]) ? padding[2] : top;
    var left = isNumber(padding[3]) ? padding[3] : right;
    return [top, right, bottom, left];
  }
  function batch2hd(px2hd) {
    var batchPx2hd = function batchPx2hd(value) {
      // px
      if (isString(value) && /^-?\d+(\.\d+)?px$/.test(value)) {
        var num = value.substr(0, value.length - 2);
        return px2hd(Number(num));
      }
      if (isArray(value)) {
        return value.map(function (v) {
          return batchPx2hd(v);
        });
      }
      if (isPlainObject(value)) {
        var result = {};
        for (var key in value) {
          if (value.hasOwnProperty(key)) {
            var rst = batchPx2hd(value[key]);
            if (!rst) {
              result[key] = rst;
              continue;
            }
            if (key === 'padding' || key === 'margin') {
              var paddingArray = parsePadding(rst);
              result[key] = paddingArray;
              result["".concat(key, "Top")] = paddingArray[0];
              result["".concat(key, "Right")] = paddingArray[1];
              result["".concat(key, "Bottom")] = paddingArray[2];
              result["".concat(key, "Left")] = paddingArray[3];
              continue;
            }
            result[key] = rst;
          }
        }
        return result;
      }
      // 
      return value;
    };
    return batchPx2hd;
  }
  var px2hd = batch2hd(defaultPx2hd);

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _inheritsLoose$8(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$8(subClass, superClass);
  }
  function _setPrototypeOf$8(o, p) {
    _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$8(o, p);
  }
  function _toPrimitive$1(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey$1(arg) {
    var key = _toPrimitive$1(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationPlaybackEvent
   */
  var AnimationEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inheritsLoose$8(AnimationEvent, _FederatedEvent);
    function AnimationEvent(manager, target, currentTime, timelineTime) {
      var _this;
      _this = _FederatedEvent.call(this, manager) || this;
      _this.currentTime = void 0;
      _this.timelineTime = void 0;
      _this.currentTime = currentTime;
      _this.timelineTime = timelineTime;
      // @ts-ignore
      _this.target = target;
      _this.type = 'finish';
      _this.bubbles = false;
      // @ts-ignore
      _this.currentTarget = target;
      _this.defaultPrevented = false;
      _this.eventPhase = _this.AT_TARGET;
      _this.timeStamp = Date.now();
      _this.currentTime = currentTime;
      _this.timelineTime = timelineTime;
      return _this;
    }
    return AnimationEvent;
  }(FederatedEvent);

  var sequenceNumber = 0;
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/Animation
   */
  var Animation = /*#__PURE__*/function () {
    function Animation(effect, timeline) {
      var _this$effect;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
       */
      this.effect = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
       */
      this.timeline = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
       */
      this.id = void 0;
      this.currentTimePending = false;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/playState
       */
      // playState: AnimationPlayState;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      /**
       * record previos state
       */
      this.oldPlayState = void 0;
      this._holdTime = void 0;
      this.readyPromise = void 0;
      this.finishedPromise = void 0;
      // eslint-disable-next-line @typescript-eslint/ban-types
      this.resolveReadyPromise = void 0;
      // eslint-disable-next-line @typescript-eslint/ban-types
      this.rejectReadyPromise = void 0;
      // eslint-disable-next-line @typescript-eslint/ban-types
      this.resolveFinishedPromise = void 0;
      // eslint-disable-next-line @typescript-eslint/ban-types
      this.rejectFinishedPromise = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
       */
      this.onfinish = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
       */
      this.oncancel = void 0;
      /**
       * get called after each frame when running
       */
      this.onframe = void 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/currentTime
       */
      this._currentTime = 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
       */
      this._startTime = void 0;
      this._playbackRate = 1;
      this._totalDuration = void 0;
      this._inEffect = void 0;
      this._inTimeline = true;
      this.onremove = void 0;
      this.effect = effect;
      effect.animation = this;
      this.timeline = timeline;
      this.id = "" + sequenceNumber++;
      this._inEffect = !!this.effect.update(0);
      this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
      this._holdTime = 0;
      this._paused = false;
      this.oldPlayState = 'idle';
      this.updatePromises();
    }
    /**
     * state machine,
     * resolve/reject ready/finished Promise according to current state
     */
    var _proto = Animation.prototype;
    _proto.updatePromises = function updatePromises() {
      var oldPlayState = this.oldPlayState;
      var newPlayState = this.pending ? 'pending' : this.playState;
      if (this.readyPromise && newPlayState !== oldPlayState) {
        if (newPlayState === 'idle') {
          this.rejectReadyPromise();
          this.readyPromise = undefined;
        } else if (oldPlayState === 'pending') {
          this.resolveReadyPromise();
        } else if (newPlayState === 'pending') {
          this.readyPromise = undefined;
        }
      }
      if (this.finishedPromise && newPlayState !== oldPlayState) {
        if (newPlayState === 'idle') {
          this.rejectFinishedPromise();
          this.finishedPromise = undefined;
        } else if (newPlayState === 'finished') {
          this.resolveFinishedPromise();
        } else if (oldPlayState === 'finished') {
          this.finishedPromise = undefined;
        }
      }
      this.oldPlayState = newPlayState;
      return this.readyPromise || this.finishedPromise;
    };
    _proto.play = function play() {
      this.updatePromises();
      this._paused = false;
      if (this._isFinished || this._idle) {
        this.rewind();
        this._startTime = null;
      }
      this._finishedFlag = false;
      this._idle = false;
      this.ensureAlive();
      this.timeline.applyDirtiedAnimation(this);
      if (this.timeline.animations.indexOf(this) === -1) {
        this.timeline.animations.push(this);
      }
      this.updatePromises();
    };
    _proto.pause = function pause() {
      this.updatePromises();
      if (this.currentTime) {
        this._holdTime = this.currentTime;
      }
      if (!this._isFinished && !this._paused && !this._idle) {
        this.currentTimePending = true;
      } else if (this._idle) {
        this.rewind();
        this._idle = false;
      }
      this._startTime = null;
      this._paused = true;
      this.updatePromises();
    };
    _proto.finish = function finish() {
      this.updatePromises();
      if (this._idle) return;
      this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
      this._startTime = this._totalDuration - this.currentTime;
      this.currentTimePending = false;
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    };
    _proto.cancel = function cancel() {
      this.updatePromises();
      if (!this._inEffect) return;
      this._inEffect = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._startTime = null;
      this.effect.update(null);
      // effects are invalid after cancellation as the animation state
      // needs to un-apply.
      this.timeline.applyDirtiedAnimation(this);
      this.updatePromises();
    };
    _proto.reverse = function reverse() {
      this.updatePromises();
      var oldCurrentTime = this.currentTime;
      this.playbackRate *= -1;
      this.play();
      if (oldCurrentTime !== null) {
        this.currentTime = oldCurrentTime;
      }
      this.updatePromises();
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
     */;
    _proto.updatePlaybackRate = function updatePlaybackRate(playbackRate) {
      this.playbackRate = playbackRate;
    };
    _proto.targetAnimations = function targetAnimations() {
      var _this$effect2;
      var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
      return target.getAnimations();
    };
    _proto.markTarget = function markTarget() {
      var animations = this.targetAnimations();
      if (animations.indexOf(this) === -1) {
        animations.push(this);
      }
    };
    _proto.unmarkTarget = function unmarkTarget() {
      var animations = this.targetAnimations();
      var index = animations.indexOf(this);
      if (index !== -1) {
        animations.splice(index, 1);
      }
    };
    _proto.tick = function tick(timelineTime, isAnimationFrame) {
      if (!this._idle && !this._paused) {
        if (this._startTime === null) {
          if (isAnimationFrame) {
            this.startTime = timelineTime - this._currentTime / this.playbackRate;
          }
        } else if (!this._isFinished) {
          this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
        }
      }
      if (isAnimationFrame) {
        this.currentTimePending = false;
        this.fireEvents(timelineTime);
      }
    };
    _proto.rewind = function rewind() {
      if (this.playbackRate >= 0) {
        this.currentTime = 0;
      } else if (this._totalDuration < Infinity) {
        this.currentTime = this._totalDuration;
      } else {
        throw new Error('Unable to rewind negative playback rate animation with infinite duration');
      }
    };
    _proto.persist = function persist() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.addEventListener = function addEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.removeEventListener = function removeEventListener(type, listener, options) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.dispatchEvent = function dispatchEvent(event) {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    // replaceState: AnimationReplaceState;
    _proto.commitStyles = function commitStyles() {
      throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
    };
    _proto.ensureAlive = function ensureAlive() {
      // If an animation is playing backwards and is not fill backwards/both
      // then it should go out of effect when it reaches the start of its
      // active interval (currentTime === 0).
      if (this.playbackRate < 0 && this.currentTime === 0) {
        var _this$effect3;
        this._inEffect = !!((_this$effect3 = this.effect) === null || _this$effect3 === void 0 ? void 0 : _this$effect3.update(-1));
      } else {
        var _this$effect4;
        this._inEffect = !!((_this$effect4 = this.effect) === null || _this$effect4 === void 0 ? void 0 : _this$effect4.update(this.currentTime));
      }
      if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
        this._inTimeline = true;
        this.timeline.animations.push(this);
      }
    };
    _proto.tickCurrentTime = function tickCurrentTime(newTime, ignoreLimit) {
      if (newTime !== this._currentTime) {
        this._currentTime = newTime;
        if (this._isFinished && !ignoreLimit) {
          this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        }
        this.ensureAlive();
      }
    };
    _proto.fireEvents = function fireEvents(baseTime) {
      var _this = this;
      if (this._isFinished) {
        if (!this._finishedFlag) {
          if (this.onfinish) {
            var event = new AnimationEvent(null, this, this.currentTime, baseTime);
            setTimeout(function () {
              if (_this.onfinish) {
                _this.onfinish(event);
              }
            });
          }
          this._finishedFlag = true;
        }
      } else {
        if (this.onframe && this.playState === 'running') {
          var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
          this.onframe(_event);
        }
        this._finishedFlag = false;
      }
    };
    _createClass$1(Animation, [{
      key: "pending",
      get: // animation: InternalAnimation | null;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
       */
      function get() {
        return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
      }
    }, {
      key: "playState",
      get: function get() {
        if (this._idle) return 'idle';
        if (this._isFinished) return 'finished';
        if (this._paused) return 'paused';
        return 'running';
      }
    }, {
      key: "ready",
      get:
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
       * @example
        animation.pause();
        animation.ready.then(function() {
          // Displays 'running'
          alert(animation.playState);
        });
        animation.play();
       */
      function get() {
        var _this2 = this;
        if (!this.readyPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.readyPromise = new Promise(function (resolve, reject) {
            _this2.resolveReadyPromise = function () {
              resolve(_this2);
            };
            _this2.rejectReadyPromise = function () {
              reject(new Error());
            };
          });
          if (!this.pending) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
       * @example
        Promise.all(
          elem.getAnimations().map(
            function(animation) {
              return animation.finished
            }
          )
        ).then(
          function() {
            return elem.remove();
          }
        );
       */
    }, {
      key: "finished",
      get: function get() {
        var _this3 = this;
        if (!this.finishedPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.finishedPromise = new Promise(function (resolve, reject) {
            _this3.resolveFinishedPromise = function () {
              resolve(_this3);
            };
            _this3.rejectFinishedPromise = function () {
              reject(new Error());
            };
          });
          if (this.playState === 'finished') {
            this.resolveFinishedPromise();
          }
        }
        return this.finishedPromise;
      }
    }, {
      key: "currentTime",
      get: function get() {
        this.updatePromises();
        return this._idle || this.currentTimePending ? null : this._currentTime;
      },
      set: function set(newTime) {
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        this.timeline.restart();
        if (!this._paused && this._startTime !== null) {
          var _this$timeline;
          this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
        }
        this.currentTimePending = false;
        if (this._currentTime === newTime) {
          return;
        }
        if (this._idle) {
          this._idle = false;
          this._paused = true;
        }
        this.tickCurrentTime(newTime, true);
        this.timeline.applyDirtiedAnimation(this);
      }
    }, {
      key: "startTime",
      get: function get() {
        return this._startTime;
      },
      set: function set(newTime) {
        if (newTime !== null) {
          this.updatePromises();
          newTime = Number(newTime);
          if (isNaN(newTime)) return;
          if (this._paused || this._idle) return;
          this._startTime = newTime;
          this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
          this.timeline.applyDirtiedAnimation(this);
          this.updatePromises();
        }
      }
    }, {
      key: "playbackRate",
      get: function get() {
        return this._playbackRate;
      },
      set: function set(value) {
        if (value === this._playbackRate) {
          return;
        }
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this._playbackRate = value;
        this.startTime = null;
        if (this.playState !== 'paused' && this.playState !== 'idle') {
          this._finishedFlag = false;
          this._idle = false;
          this.ensureAlive();
          this.timeline.applyDirtiedAnimation(this);
        }
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      }
    }, {
      key: "_isFinished",
      get: function get() {
        return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
      }
    }, {
      key: "totalDuration",
      get: function get() {
        return this._totalDuration;
      }
    }, {
      key: "_needsTick",
      get: function get() {
        return this.pending || this.playState === 'running' || !this._finishedFlag;
      }
    }]);
    return Animation;
  }();

  /**
   * https://github.com/gre/bezier-easing
   * BezierEasing - use bezier curve for transition easing function
   * by Gatan Renaudeau 2014 - 2015  MIT License
   */
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';
  var A = function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  };
  var B = function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  };
  var C = function C(aA1) {
    return 3.0 * aA1;
  };
  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  var calcBezier = function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  };
  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  var getSlope = function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  };
  var binarySubdivide = function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) aB = currentT;else aA = currentT;
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  };
  var newtonRaphsonIterate = function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  var bezier = function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) throw new Error('bezier x values must be in [0, 1] range');
    if (mX1 === mY1 && mX2 === mY2) return function (t) {
      return t;
    };
    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    var getTForX = function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
      --currentSample;
      // Interpolate to provide an initial guess for t
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);else if (initialSlope === 0.0) return guessForT;else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    };
    return function (t) {
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (t === 0 || t === 1) return t;
      return calcBezier(getTForX(t), mY1, mY2);
    };
  };

  var convertToDash = function convertToDash(str) {
    str = str.replace(/([A-Z])/g, function (letter) {
      return "-" + letter.toLowerCase();
    });
    // Remove first dash
    return str.charAt(0) === '-' ? str.substring(1) : str;
  };
  /**
    Easing Functions from anime.js, they are tried and true, so, its better to use them instead of other alternatives
  */
  var Quad = function Quad(t) {
    return Math.pow(t, 2);
  };
  var Cubic = function Cubic(t) {
    return Math.pow(t, 3);
  };
  var Quart = function Quart(t) {
    return Math.pow(t, 4);
  };
  var Quint = function Quint(t) {
    return Math.pow(t, 5);
  };
  var Expo = function Expo(t) {
    return Math.pow(t, 6);
  };
  var Sine = function Sine(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  };
  var Circ = function Circ(t) {
    return 1 - Math.sqrt(1 - t * t);
  };
  var Back = function Back(t) {
    return t * t * (3 * t - 2);
  };
  var Bounce = function Bounce(t) {
    var pow2,
      b = 4;
    while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}
    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
  };
  var Elastic = function Elastic(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _params = params,
      _params$ = _params[0],
      amplitude = _params$ === void 0 ? 1 : _params$,
      _params$2 = _params[1],
      period = _params$2 === void 0 ? 0.5 : _params$2;
    var a = clamp(Number(amplitude), 1, 10);
    var p = clamp(Number(period), 0.1, 2);
    if (t === 0 || t === 1) return t;
    return -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
  };
  var Spring = function Spring(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    var _params2 = params,
      _params2$ = _params2[0],
      mass = _params2$ === void 0 ? 1 : _params2$,
      _params2$2 = _params2[1],
      stiffness = _params2$2 === void 0 ? 100 : _params2$2,
      _params2$3 = _params2[2],
      damping = _params2$3 === void 0 ? 10 : _params2$3,
      _params2$4 = _params2[3],
      velocity = _params2$4 === void 0 ? 0 : _params2$4;
    mass = clamp(mass, 0.1, 1000);
    stiffness = clamp(stiffness, 0.1, 1000);
    damping = clamp(damping, 0.1, 1000);
    velocity = clamp(velocity, 0.1, 1000);
    var w0 = Math.sqrt(stiffness / mass);
    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
    var a = 1;
    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
    var progress = duration ? duration * t / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) return t;
    return 1 - progress;
  };
  /**
   * Cache the durations at set easing parameters
   */
  // export const EasingDurationCache: Map<string | TypeEasingFunction, number> = new Map();
  /**
   * The threshold for an infinite loop
   */
  // const INTINITE_LOOP_LIMIT = 10000;
  /** Convert easing parameters to Array of numbers, e.g. "spring(2, 500)" to [2, 500] */
  // export const parseEasingParameters = (str: string) => {
  //   const match = /(\(|\s)([^)]+)\)?/.exec(str);
  //   return match
  //     ? match[2].split(',').map((value) => {
  //         const num = parseFloat(value);
  //         return !Number.isNaN(num) ? num : value.trim();
  //       })
  //     : [];
  // };
  /**
   * The spring easing function will only look smooth at certain durations, with certain parameters.
   * This functions returns the optimal duration to create a smooth springy animation based on physics
   *
   * Note: it can also be used to determine the optimal duration of other types of easing function, but be careful of 'in-'
   * easing functions, because of the nature of the function it can sometimes create an infinite loop, I suggest only using
   * `getEasingDuration` for `spring`, specifically 'out-spring' and 'spring'
   */
  // export const getEasingDuration = (easing: string | TypeEasingFunction = 'spring') => {
  //   if (EasingDurationCache.has(easing)) return EasingDurationCache.get(easing);
  //   // eslint-disable-next-line @typescript-eslint/no-use-before-define
  //   const easingFunction = typeof easing == 'function' ? easing : getEasingFunction(easing as string);
  //   const params = typeof easing == 'function' ? [] : parseEasingParameters(easing);
  //   const frame = 1 / 6;
  //   let elapsed = 0;
  //   let rest = 0;
  //   let count = 0;
  //   while (++count < INTINITE_LOOP_LIMIT) {
  //     elapsed += frame;
  //     if (easingFunction(elapsed, params, undefined) === 1) {
  //       rest++;
  //       if (rest >= 16) break;
  //     } else {
  //       rest = 0;
  //     }
  //   }
  //   const duration = elapsed * frame * 1000;
  //   EasingDurationCache.set(easing, duration);
  //   return duration;
  // };
  /**
    These Easing Functions are based off of the Sozi Project's easing functions
    https://github.com/sozi-projects/Sozi/blob/d72e44ebd580dc7579d1e177406ad41e632f961d/src/js/player/Timing.js
  */
  var Steps = function Steps(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _params3 = params,
      _params3$ = _params3[0],
      steps = _params3$ === void 0 ? 10 : _params3$,
      type = _params3[1];
    var trunc = type == 'start' ? Math.ceil : Math.floor;
    return trunc(clamp(t, 0, 1) * steps) / steps;
  };
  // @ts-ignore
  var Bezier = function Bezier(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _params4 = params,
      mX1 = _params4[0],
      mY1 = _params4[1],
      mX2 = _params4[2],
      mY2 = _params4[3];
    return bezier(mX1, mY1, mX2, mY2)(t);
  };
  /** The default `ease-in` easing function */
  var easein = bezier(0.42, 0.0, 1.0, 1.0);
  /** Converts easing functions to their `out`counter parts */
  var EaseOut = function EaseOut(ease) {
    return function (t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return 1 - ease(1 - t, params, duration);
    };
  };
  /** Converts easing functions to their `in-out` counter parts */
  var EaseInOut = function EaseInOut(ease) {
    return function (t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;
    };
  };
  /** Converts easing functions to their `out-in` counter parts */
  var EaseOutIn = function EaseOutIn(ease) {
    return function (t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return t < 0.5 ? (1 - ease(1 - t * 2, params, duration)) / 2 : (ease(t * 2 - 1, params, duration) + 1) / 2;
    };
  };
  var EasingFunctions = {
    steps: Steps,
    'step-start': function stepStart(t) {
      return Steps(t, [1, 'start']);
    },
    'step-end': function stepEnd(t) {
      return Steps(t, [1, 'end']);
    },
    linear: function linear(t) {
      return t;
    },
    'cubic-bezier': Bezier,
    ease: function ease(t) {
      return Bezier(t, [0.25, 0.1, 0.25, 1.0]);
    },
    in: easein,
    out: EaseOut(easein),
    'in-out': EaseInOut(easein),
    'out-in': EaseOutIn(easein),
    'in-quad': Quad,
    'out-quad': EaseOut(Quad),
    'in-out-quad': EaseInOut(Quad),
    'out-in-quad': EaseOutIn(Quad),
    'in-cubic': Cubic,
    'out-cubic': EaseOut(Cubic),
    'in-out-cubic': EaseInOut(Cubic),
    'out-in-cubic': EaseOutIn(Cubic),
    'in-quart': Quart,
    'out-quart': EaseOut(Quart),
    'in-out-quart': EaseInOut(Quart),
    'out-in-quart': EaseOutIn(Quart),
    'in-quint': Quint,
    'out-quint': EaseOut(Quint),
    'in-out-quint': EaseInOut(Quint),
    'out-in-quint': EaseOutIn(Quint),
    'in-expo': Expo,
    'out-expo': EaseOut(Expo),
    'in-out-expo': EaseInOut(Expo),
    'out-in-expo': EaseOutIn(Expo),
    'in-sine': Sine,
    'out-sine': EaseOut(Sine),
    'in-out-sine': EaseInOut(Sine),
    'out-in-sine': EaseOutIn(Sine),
    'in-circ': Circ,
    'out-circ': EaseOut(Circ),
    'in-out-circ': EaseInOut(Circ),
    'out-in-circ': EaseOutIn(Circ),
    'in-back': Back,
    'out-back': EaseOut(Back),
    'in-out-back': EaseInOut(Back),
    'out-in-back': EaseOutIn(Back),
    'in-bounce': Bounce,
    'out-bounce': EaseOut(Bounce),
    'in-out-bounce': EaseInOut(Bounce),
    'out-in-bounce': EaseOutIn(Bounce),
    'in-elastic': Elastic,
    'out-elastic': EaseOut(Elastic),
    'in-out-elastic': EaseInOut(Elastic),
    'out-in-elastic': EaseOutIn(Elastic),
    spring: Spring,
    'spring-in': Spring,
    'spring-out': EaseOut(Spring),
    'spring-in-out': EaseInOut(Spring),
    'spring-out-in': EaseOutIn(Spring)
  };
  /**
   * Convert string easing to their proper form
   */
  var complexEasingSyntax = function complexEasingSyntax(ease) {
    return convertToDash(ease).replace(/^ease-/, '') // Remove the "ease-" keyword
    .replace(/(\(|\s).+/, '') // Remove the function brackets and parameters
    .toLowerCase().trim();
  };
  /** Re-maps a number from one range to another. Numbers outside the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful. */
  var getEasingFunction = function getEasingFunction(ease) {
    return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;
  };
  // /**
  //  * Allows you to register new easing functions
  //  */
  // export const registerEasingFunction = (key: string, fn: TypeEasingFunction) => {
  //   Object.assign(EasingFunctions, {
  //     [key]: fn,
  //   });
  // };
  // /**
  //  * Allows you to register multiple new easing functions
  //  */
  // export const registerEasingFunctions = (...obj: typeof EasingFunctions[]) => {
  //   Object.assign(EasingFunctions, ...obj);
  // };

  var linear = function linear(x) {
    return x;
  };
  var Start = 1;
  var Middle = 0.5;
  var End = 0;
  function step(count, pos) {
    return function (x) {
      if (x >= 1) {
        return 1;
      }
      var stepSize = 1 / count;
      x += pos * stepSize;
      return x - x % stepSize;
    };
  }
  var numberString = '\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*';
  var cubicBezierRe = new RegExp('cubic-bezier\\(' + numberString + ',' + numberString + ',' + numberString + ',' + numberString + '\\)');
  var step1Re = /steps\(\s*(\d+)\s*\)/;
  var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
  function parseEasingFunction(normalizedEasing) {
    var cubicData = cubicBezierRe.exec(normalizedEasing);
    if (cubicData) {
      // @ts-ignore
      return bezier.apply(void 0, cubicData.slice(1).map(Number));
    }
    var step1Data = step1Re.exec(normalizedEasing);
    if (step1Data) {
      return step(Number(step1Data[1]), End);
    }
    var step2Data = step2Re.exec(normalizedEasing);
    if (step2Data) {
      // @ts-ignore
      return step(Number(step2Data[1]), {
        start: Start,
        middle: Middle,
        end: End
      }[step2Data[2]]);
    }
    return getEasingFunction(normalizedEasing);
  }
  function calculateActiveDuration(timing) {
    // @ts-ignore
    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
  }
  function repeatedDuration(timing) {
    var _timing$iterations;
    // https://drafts.csswg.org/web-animations/#calculating-the-active-duration
    if (timing.duration === 0 || timing.iterations === 0) {
      return 0;
    }
    // @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration#value
    // if (timing.duration === 'auto') {
    //   timing.duration = 0;
    // }
    return (timing.duration === 'auto' ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
  }
  var PhaseNone = 0;
  var PhaseBefore = 1;
  var PhaseAfter = 2;
  var PhaseActive = 3;
  function calculatePhase(activeDuration, localTime, timing) {
    // https://drafts.csswg.org/web-animations/#animation-effect-phases-and-states
    if (localTime === null) {
      return PhaseNone;
    }
    var endTime = timing.endTime;
    if (localTime < Math.min(timing.delay, endTime)) {
      return PhaseBefore;
    }
    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
      return PhaseAfter;
    }
    return PhaseActive;
  }
  function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
    // https://drafts.csswg.org/web-animations/#calculating-the-active-time
    switch (phase) {
      case PhaseBefore:
        if (fillMode === 'backwards' || fillMode === 'both') return 0;
        return null;
      case PhaseActive:
        return localTime - delay;
      case PhaseAfter:
        if (fillMode === 'forwards' || fillMode === 'both') return activeDuration;
        return null;
      case PhaseNone:
        return null;
    }
  }
  function calculateOverallProgress(iterationDuration, phase, iterations, activeTime, iterationStart) {
    // https://drafts.csswg.org/web-animations/#calculating-the-overall-progress
    var overallProgress = iterationStart;
    if (iterationDuration === 0) {
      if (phase !== PhaseBefore) {
        overallProgress += iterations;
      }
    } else {
      overallProgress += activeTime / iterationDuration;
    }
    return overallProgress;
  }
  function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations, activeTime, iterationDuration) {
    // https://drafts.csswg.org/web-animations/#calculating-the-simple-iteration-progress
    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
    if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
      simpleIterationProgress = 1;
    }
    return simpleIterationProgress;
  }
  function calculateCurrentIteration(phase, iterations, simpleIterationProgress, overallProgress) {
    // https://drafts.csswg.org/web-animations/#calculating-the-current-iteration
    if (phase === PhaseAfter && iterations === Infinity) {
      return Infinity;
    }
    if (simpleIterationProgress === 1) {
      return Math.floor(overallProgress) - 1;
    }
    return Math.floor(overallProgress);
  }
  function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
    // https://drafts.csswg.org/web-animations/#calculating-the-directed-progress
    var currentDirection = playbackDirection;
    if (playbackDirection !== 'normal' && playbackDirection !== 'reverse') {
      var d = currentIteration;
      if (playbackDirection === 'alternate-reverse') {
        d += 1;
      }
      currentDirection = 'normal';
      if (d !== Infinity && d % 2 !== 0) {
        currentDirection = 'reverse';
      }
    }
    if (currentDirection === 'normal') {
      return simpleIterationProgress;
    }
    return 1 - simpleIterationProgress;
  }
  function calculateIterationProgress(activeDuration, localTime, timing) {
    var phase = calculatePhase(activeDuration, localTime, timing);
    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
    if (activeTime === null) return null;
    var duration = timing.duration === 'auto' ? 0 : timing.duration;
    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
    timing.currentIteration = currentIteration;
    timing.progress = directedProgress;
    // https://drafts.csswg.org/web-animations/#calculating-the-transformed-progress
    // https://drafts.csswg.org/web-animations/#calculating-the-iteration-progress
    return timing.easingFunction(directedProgress);
  }

  function convertEffectInput(keyframes, timing, target) {
    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
    return function (target, fraction) {
      if (fraction !== null) {
        interpolations.filter(function (interpolation) {
          return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
        }).forEach(function (interpolation) {
          var offsetFraction = fraction - interpolation.startOffset;
          var localDuration = interpolation.endOffset - interpolation.startOffset;
          var scaledLocalTime = localDuration === 0 ? 0 : interpolation.easingFunction(offsetFraction / localDuration);
          // apply updated attribute
          target.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime));
          // if (interpolation.property === 'visibility') {
          //   console.log(
          //     scaledLocalTime,
          //     interpolation.interpolation(scaledLocalTime),
          //   );
          // }
        });
      } else {
        for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
          // clear attribute
          target.setAttribute(property, null);
        }
      }
    };
  }
  function isNotReservedWord(member) {
    return member !== 'offset' && member !== 'easing' && member !== 'composite' && member !== 'computedOffset';
  }
  function makePropertySpecificKeyframeGroups(keyframes, timing) {
    var propertySpecificKeyframeGroups = {};
    for (var i = 0; i < keyframes.length; i++) {
      for (var member in keyframes[i]) {
        if (isNotReservedWord(member)) {
          var propertySpecificKeyframe = {
            offset: keyframes[i].offset,
            computedOffset: keyframes[i].computedOffset,
            easing: keyframes[i].easing,
            easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
            value: keyframes[i][member]
          };
          propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
          propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
        }
      }
    }
    return propertySpecificKeyframeGroups;
  }
  function makeInterpolations(propertySpecificKeyframeGroups, target) {
    var interpolations = [];
    for (var groupName in propertySpecificKeyframeGroups) {
      var keyframes = propertySpecificKeyframeGroups[groupName];
      for (var i = 0; i < keyframes.length - 1; i++) {
        var startIndex = i;
        var endIndex = i + 1;
        var startOffset = keyframes[startIndex].computedOffset;
        var endOffset = keyframes[endIndex].computedOffset;
        var applyFrom = startOffset;
        var applyTo = endOffset;
        if (i === 0) {
          applyFrom = -Infinity;
          if (endOffset === 0) {
            endIndex = startIndex;
          }
        }
        if (i === keyframes.length - 2) {
          applyTo = Infinity;
          if (startOffset === 1) {
            startIndex = endIndex;
          }
        }
        interpolations.push({
          applyFrom: applyFrom,
          applyTo: applyTo,
          startOffset: keyframes[startIndex].computedOffset,
          endOffset: keyframes[endIndex].computedOffset,
          easingFunction: keyframes[startIndex].easingFunction,
          property: groupName,
          interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
        });
      }
    }
    interpolations.sort(function (leftInterpolation, rightInterpolation) {
      return leftInterpolation.startOffset - rightInterpolation.startOffset;
    });
    return interpolations;
  }
  var InterpolationFactory = function InterpolationFactory(from, to,
  // eslint-disable-next-line @typescript-eslint/ban-types
  convertToString) {
    return function (f) {
      var interpolated = interpolate(from, to, f);
      return !runtime.enableCSSParsing && isNumber(interpolated) ? interpolated : convertToString(interpolated);
    };
  };
  function propertyInterpolation(property, left, right, target) {
    var metadata = propertyMetadataCache[property];
    // discrete step
    // if (property === 'visibility') {
    //   return function (t: number) {
    //     if (t === 0) return left;
    //     if (t === 1) return right;
    //     debugger;
    //     return t < 0.5 ? left : right;
    //   };
    // }
    if (metadata && metadata.syntax && metadata.int) {
      var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
      if (propertyHandler) {
        var usedLeft;
        var usedRight;
        if (runtime.enableCSSParsing) {
          var computedLeft = runtime.styleValueRegistry.parseProperty(property, left, target);
          var computedRight = runtime.styleValueRegistry.parseProperty(property, right, target);
          usedLeft = runtime.styleValueRegistry.computeProperty(property, computedLeft, target);
          usedRight = runtime.styleValueRegistry.computeProperty(property, computedRight, target);
        } else {
          var parser = propertyHandler.parserWithCSSDisabled;
          usedLeft = parser ? parser(left, target) : left;
          usedRight = parser ? parser(right, target) : right;
        }
        // merger [left, right, n2string()]
        var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
        if (interpolationArgs) {
          var interp = InterpolationFactory.apply(void 0, interpolationArgs);
          return function (t) {
            if (t === 0) return left;
            if (t === 1) return right;
            return interp(t);
          };
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return InterpolationFactory(false, true, function (bool) {
      return bool ? right : left;
    });
  }
  /**
   * interpolate with number, boolean, number[], boolean[]
   */
  function interpolate(from, to, f) {
    if (typeof from === 'number' && typeof to === 'number') {
      return from * (1 - f) + to * f;
    }
    if (typeof from === 'boolean' && typeof to === 'boolean' || typeof from === 'string' && typeof to === 'string' // skip string, eg. path ['M', 10, 10]
    ) {
      return f < 0.5 ? from : to;
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      // interpolate arrays/matrix
      var fromLength = from.length;
      var toLength = to.length;
      var length = Math.max(fromLength, toLength);
      var r = [];
      for (var i = 0; i < length; i++) {
        r.push(interpolate(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
      }
      return r;
    }
    throw new Error('Mismatched interpolation arguments ' + from + ':' + to);
  }

  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming
   */
  var AnimationEffectTiming = /*#__PURE__*/function () {
    function AnimationEffectTiming() {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/delay
       */
      this.delay = 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/direction
       */
      this.direction = 'normal';
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/duration
       */
      this.duration = 'auto';
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing
       */
      this._easing = 'linear';
      this.easingFunction = linear;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/endDelay
       */
      this.endDelay = 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/fill
       */
      this.fill = 'auto';
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterationStart
       */
      this.iterationStart = 0;
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/iterations
       */
      this.iterations = 1;
      /**
       * @deprecated
       */
      this.playbackRate = void 0;
      /**
       * ref to effect
       */
      this.effect = void 0;
      this.composite = void 0;
      /**
       * ComputedEffectTiming
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
       */
      this.activeDuration = void 0;
      this.endTime = void 0;
      this.currentIteration = null;
      this.progress = null;
    }
    _createClass$1(AnimationEffectTiming, [{
      key: "easing",
      get: function get() {
        return this._easing;
      },
      set: function set(value) {
        this.easingFunction = parseEasingFunction(value);
        this._easing = value;
      }
    }]);
    return AnimationEffectTiming;
  }();

  /**
   * @example
    {
      translateY: [200, 300],
      scale: [1, 10],
    }

   * groups' length can be different, the following config should generate 3 frames:
    @example
    {
      translateY: [200, 300, 400],
      scale: [1, 10],
    }
   */
  function convertToArrayForm(effectInput) {
    var normalizedEffectInput = [];
    for (var property in effectInput) {
      // skip reserved props
      if (property in ['easing', 'offset', 'composite']) {
        continue;
      }
      // @ts-ignore
      var values = effectInput[property];
      if (!Array.isArray(values)) {
        values = [values];
      }
      var numKeyframes = values.length;
      for (var i = 0; i < numKeyframes; i++) {
        if (!normalizedEffectInput[i]) {
          var keyframe = {};
          if ('offset' in effectInput) {
            keyframe.offset = Number(effectInput.offset);
          }
          if ('easing' in effectInput) {
            // @ts-ignore
            keyframe.easing = effectInput.easing;
          }
          if ('composite' in effectInput) {
            // @ts-ignore
            keyframe.composite = effectInput.composite;
          }
          normalizedEffectInput[i] = keyframe;
        }
        if (values[i] !== undefined && values[i] !== null) {
          normalizedEffectInput[i][property] = values[i];
        }
      }
    }
    normalizedEffectInput.sort(function (a, b) {
      return (a.computedOffset || 0) - (b.computedOffset || 0);
    });
    return normalizedEffectInput;
  }
  function normalizeKeyframes(effectInput, timing) {
    if (effectInput === null) {
      return [];
    }
    if (!Array.isArray(effectInput)) {
      effectInput = convertToArrayForm(effectInput);
    }
    var keyframes = effectInput.map(function (originalKeyframe) {
      var keyframe = {};
      if (timing === null || timing === void 0 ? void 0 : timing.composite) {
        // This will be auto if the composite operation specified on the effect is being used.
        // @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats
        keyframe.composite = 'auto';
      }
      for (var member in originalKeyframe) {
        var memberValue = originalKeyframe[member];
        if (member === 'offset') {
          if (memberValue !== null) {
            memberValue = Number(memberValue);
            if (!isFinite(memberValue)) throw new Error('Keyframe offsets must be numbers.');
            if (memberValue < 0 || memberValue > 1) throw new Error('Keyframe offsets must be between 0 and 1.');
            keyframe.computedOffset = memberValue;
          }
        } else if (member === 'composite') {
          // TODO: Support add & accumulate in KeyframeEffect.composite
          // @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect/composite
          if (['replace', 'add', 'accumulate', 'auto'].indexOf(memberValue) === -1) {
            throw new Error(memberValue + " compositing is not supported");
          }
        } else ;
        // assign to keyframe, no need to parse shorthand value
        keyframe[member] = memberValue;
      }
      if (keyframe.offset === undefined) {
        keyframe.offset = null;
      }
      if (keyframe.easing === undefined) {
        // override with timing.easing
        keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || 'linear';
      }
      if (keyframe.composite === undefined) {
        keyframe.composite = 'auto';
      }
      return keyframe;
    });
    var everyFrameHasOffset = true;
    var previousOffset = -Infinity;
    for (var i = 0; i < keyframes.length; i++) {
      var offset = keyframes[i].offset;
      if (!isNil(offset)) {
        if (offset < previousOffset) {
          throw new TypeError('Keyframes are not loosely sorted by offset. Sort or specify offsets.');
        }
        previousOffset = offset;
      } else {
        everyFrameHasOffset = false;
      }
    }
    keyframes = keyframes.filter(function (keyframe) {
      return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
    });
    function spaceKeyframes() {
      var _keyframes$offset;
      var length = keyframes.length;
      keyframes[length - 1].computedOffset = Number((_keyframes$offset = keyframes[length - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
      if (length > 1) {
        var _keyframes$0$offset;
        keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
      }
      var previousIndex = 0;
      var previousOffset = Number(keyframes[0].computedOffset);
      for (var _i = 1; _i < length; _i++) {
        var _offset = keyframes[_i].computedOffset;
        if (!isNil(_offset) && !isNil(previousOffset)) {
          for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset + (Number(_offset) - previousOffset) * j / (_i - previousIndex);
          previousIndex = _i;
          previousOffset = Number(_offset);
        }
      }
    }
    if (!everyFrameHasOffset) spaceKeyframes();
    return keyframes;
  }

  var fills = 'backwards|forwards|both|none'.split('|');
  var directions = 'reverse|alternate|alternate-reverse'.split('|');
  function makeTiming(timingInput, forGroup) {
    var timing = new AnimationEffectTiming();
    if (forGroup) {
      timing.fill = 'both';
      timing.duration = 'auto';
    }
    if (typeof timingInput === 'number' && !isNaN(timingInput)) {
      timing.duration = timingInput;
    } else if (timingInput !== undefined) {
      Object.keys(timingInput).forEach(function (property) {
        if (timingInput[property] !== undefined && timingInput[property] !== null && timingInput[property] !== 'auto') {
          if (typeof timing[property] === 'number' || property === 'duration') {
            if (typeof timingInput[property] !== 'number' || isNaN(timingInput[property])) {
              return;
            }
          }
          if (property === 'fill' && fills.indexOf(timingInput[property]) === -1) {
            return;
          }
          if (property === 'direction' && directions.indexOf(timingInput[property]) === -1) {
            return;
          }
          // @ts-ignore
          timing[property] = timingInput[property];
        }
      });
    }
    return timing;
  }
  function normalizeTimingInput(timingInput, forGroup) {
    var _timingInput;
    timingInput = numericTimingToObject((_timingInput = timingInput) !== null && _timingInput !== void 0 ? _timingInput : {
      duration: 'auto'
    });
    return makeTiming(timingInput, forGroup);
  }
  function numericTimingToObject(timingInput) {
    if (typeof timingInput === 'number') {
      if (isNaN(timingInput)) {
        timingInput = {
          duration: 'auto'
        };
      } else {
        timingInput = {
          duration: timingInput
        };
      }
    }
    return timingInput;
  }
  /**
   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyframeEffect
   * @example
    const circleDownKeyframes = new KeyframeEffect(
      circle, // element to animate
      [
        { transform: 'translateY(0)' }, // keyframe
        { transform: 'translateY(100)' } // keyframe
      ],
      { duration: 3000, fill: 'forwards' } // keyframe options
    );
   *
   */
  var KeyframeEffect = /*#__PURE__*/function () {
    // pseudoElement: string | null;

    function KeyframeEffect(target, effectInput, timingInput) {
      var _this = this;
      this.composite = 'replace';
      this.iterationComposite = 'replace';
      this.target = void 0;
      this.animation = void 0;
      this.timing = void 0;
      this.computedTiming = void 0;
      this.normalizedKeyframes = void 0;
      this.timeFraction = void 0;
      this.interpolations = void 0;
      this.target = target;
      this.timing = normalizeTimingInput(timingInput, false);
      this.timing.effect = this;
      this.timing.activeDuration = calculateActiveDuration(this.timing);
      this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
      this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
      this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
      //  proxy  this.timing
      var Proxy = runtime.globalThis.Proxy;
      this.computedTiming = Proxy ? new Proxy(this.timing, {
        get: function get(target, prop) {
          if (prop === 'duration') {
            return target.duration === 'auto' ? 0 : target.duration;
          } else if (prop === 'fill') {
            return target.fill === 'auto' ? 'none' : target.fill;
          } else if (prop === 'localTime') {
            return _this.animation && _this.animation.currentTime || null;
          } else if (prop === 'currentIteration') {
            if (!_this.animation || _this.animation.playState !== 'running') {
              return null;
            }
            return target.currentIteration || 0;
          } else if (prop === 'progress') {
            if (!_this.animation || _this.animation.playState !== 'running') {
              return null;
            }
            return target.progress || 0;
          }
          return target[prop];
        },
        set: function set() {
          return true;
        }
      }) : this.timing;
    }
    var _proto = KeyframeEffect.prototype;
    _proto.applyInterpolations = function applyInterpolations() {
      this.interpolations(this.target, Number(this.timeFraction));
    };
    _proto.update = function update(localTime) {
      if (localTime === null) {
        return false;
      }
      this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
      return this.timeFraction !== null;
    };
    _proto.getKeyframes = function getKeyframes() {
      return this.normalizedKeyframes;
    };
    _proto.setKeyframes = function setKeyframes(keyframes) {
      this.normalizedKeyframes = normalizeKeyframes(keyframes);
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
     */;
    _proto.getComputedTiming = function getComputedTiming() {
      return this.computedTiming;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
     */;
    _proto.getTiming = function getTiming() {
      return this.timing;
    }
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
     */;
    _proto.updateTiming = function updateTiming(timing) {
      var _this2 = this;
      Object.keys(timing || {}).forEach(function (name) {
        _this2.timing[name] = timing[name];
      });
    };
    return KeyframeEffect;
  }();

  function compareAnimations(leftAnimation, rightAnimation) {
    return Number(leftAnimation.id) - Number(rightAnimation.id);
  }
  /**
   * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/web-animations-js/index.d.ts
   */
  var AnimationTimeline = /*#__PURE__*/function () {
    /**
     * all active animations
     */

    function AnimationTimeline(document) {
      var _this = this;
      this.document = void 0;
      this.animations = [];
      this.ticking = false;
      this.timelineTicking = false;
      this.hasRestartedThisFrame = false;
      this.animationsWithPromises = [];
      this.inTick = false;
      this.pendingEffects = [];
      this.currentTime = null;
      this.rafId = 0;
      this.rafCallbacks = [];
      this.frameId = void 0;
      this.webAnimationsNextTick = function (t) {
        _this.currentTime = t;
        _this.discardAnimations();
        if (_this.animations.length === 0) {
          _this.timelineTicking = false;
        } else {
          _this.requestAnimationFrame(_this.webAnimationsNextTick);
        }
      };
      this.processRafCallbacks = function (t) {
        var processing = _this.rafCallbacks;
        _this.rafCallbacks = [];
        if (t < Number(_this.currentTime)) t = Number(_this.currentTime);
        _this.animations.sort(compareAnimations);
        _this.animations = _this.tick(t, true, _this.animations)[0];
        processing.forEach(function (entry) {
          entry[1](t);
        });
        _this.applyPendingEffects();
      };
      this.document = document;
    }
    var _proto = AnimationTimeline.prototype;
    _proto.getAnimations = function getAnimations() {
      this.discardAnimations();
      return this.animations.slice();
    };
    _proto.isTicking = function isTicking() {
      return this.inTick;
    };
    _proto.play = function play(target, keyframes, options) {
      var effect = new KeyframeEffect(target, keyframes, options);
      var animation = new Animation(effect, this);
      this.animations.push(animation);
      this.restartWebAnimationsNextTick();
      animation.updatePromises();
      animation.play();
      animation.updatePromises();
      return animation;
    }
    // RAF is supposed to be the last script to occur before frame rendering but not
    // all browsers behave like this. This function is for synchonously updating an
    // animation's effects whenever its state is mutated by script to work around
    // incorrect script execution ordering by the browser.
    ;
    _proto.applyDirtiedAnimation = function applyDirtiedAnimation(animation) {
      var _this2 = this;
      if (this.inTick) {
        return;
      }
      // update active animations in displayobject
      animation.markTarget();
      var animations = animation.targetAnimations();
      animations.sort(compareAnimations);
      // clear inactive animations
      var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
      inactiveAnimations.forEach(function (animation) {
        var index = _this2.animations.indexOf(animation);
        if (index !== -1) {
          _this2.animations.splice(index, 1);
        }
      });
      this.applyPendingEffects();
    };
    _proto.restart = function restart() {
      if (!this.ticking) {
        this.ticking = true;
        this.requestAnimationFrame(function () {});
        this.hasRestartedThisFrame = true;
      }
      return this.hasRestartedThisFrame;
    };
    _proto.destroy = function destroy() {
      this.document.defaultView.cancelAnimationFrame(this.frameId);
    };
    _proto.applyPendingEffects = function applyPendingEffects() {
      this.pendingEffects.forEach(function (effect) {
        effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
      });
      this.pendingEffects = [];
    };
    _proto.updateAnimationsPromises = function updateAnimationsPromises() {
      this.animationsWithPromises = this.animationsWithPromises.filter(function (animation) {
        return animation.updatePromises();
      });
    };
    _proto.discardAnimations = function discardAnimations() {
      this.updateAnimationsPromises();
      this.animations = this.animations.filter(function (animation) {
        return animation.playState !== 'finished' && animation.playState !== 'idle';
      });
    };
    _proto.restartWebAnimationsNextTick = function restartWebAnimationsNextTick() {
      if (!this.timelineTicking) {
        this.timelineTicking = true;
        this.requestAnimationFrame(this.webAnimationsNextTick);
      }
    };
    _proto.rAF = function rAF(f) {
      var id = this.rafId++;
      if (this.rafCallbacks.length === 0) {
        this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
      }
      this.rafCallbacks.push([id, f]);
      return id;
    };
    _proto.requestAnimationFrame = function requestAnimationFrame(f) {
      var _this3 = this;
      return this.rAF(function (x) {
        _this3.updateAnimationsPromises();
        f(x);
        _this3.updateAnimationsPromises();
      });
    };
    _proto.tick = function tick(t, isAnimationFrame, updatingAnimations) {
      var _this4 = this,
        _this$pendingEffects,
        _this$pendingEffects2;
      this.inTick = true;
      this.hasRestartedThisFrame = false;
      this.currentTime = t;
      this.ticking = false;
      var newPendingClears = [];
      var newPendingEffects = [];
      var activeAnimations = [];
      var inactiveAnimations = [];
      updatingAnimations.forEach(function (animation) {
        animation.tick(t, isAnimationFrame);
        if (!animation._inEffect) {
          newPendingClears.push(animation.effect);
          animation.unmarkTarget();
        } else {
          newPendingEffects.push(animation.effect);
          animation.markTarget();
        }
        if (animation._needsTick) _this4.ticking = true;
        var alive = animation._inEffect || animation._needsTick;
        animation._inTimeline = alive;
        if (alive) {
          activeAnimations.push(animation);
        } else {
          inactiveAnimations.push(animation);
        }
      });
      (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
      (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
      if (this.ticking) this.requestAnimationFrame(function () {});
      this.inTick = false;
      return [activeAnimations, inactiveAnimations];
    };
    return AnimationTimeline;
  }();

  runtime.EasingFunction = parseEasingFunction;
  runtime.AnimationTimeline = AnimationTimeline;

  function measureText(container, px2hd, theme) {
    return function (text, font) {
      var _a = font || {},
        _b = _a.fontSize,
        fontSize = _b === void 0 ? theme.fontSize : _b,
        _c = _a.fontFamily,
        fontFamily = _c === void 0 ? theme.fontFamily : _c,
        _d = _a.fontWeight,
        fontWeight = _d === void 0 ? theme.fontWeight : _d,
        _e = _a.fontVariant,
        fontVariant = _e === void 0 ? theme.fontVariant : _e,
        _f = _a.fontStyle,
        fontStyle = _f === void 0 ? theme.fontStyle : _f,
        _g = _a.textAlign,
        textAlign = _g === void 0 ? theme.textAlign : _g,
        _h = _a.textBaseline,
        textBaseline = _h === void 0 ? theme.textBaseline : _h,
        _j = _a.lineWidth,
        lineWidth = _j === void 0 ? 1 : _j;
      var style = {
        x: 0,
        y: 0,
        fontSize: px2hd(fontSize),
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        fontWeight: fontWeight,
        fontVariant: fontVariant,
        text: text,
        textAlign: textAlign,
        textBaseline: textBaseline,
        lineWidth: lineWidth,
        visibility: 'hidden'
      };
      var result = checkCSSRule('text', style);
      var shape = new Text({
        style: result
      });
      container.appendChild(shape);
      var _k = shape.getBBox(),
        width = _k.width,
        height = _k.height;
      shape.remove();
      return {
        width: width,
        height: height
      };
    };
  }
  function computeLayout$2(style) {
    var left = style.left,
      top = style.top,
      width = style.width,
      height = style.height,
      padding = style.padding;
    var paddingTop = padding[0],
      paddingRight = padding[1],
      paddingBottom = padding[2],
      paddingLeft = padding[3];
    return {
      left: left + paddingLeft,
      top: top + paddingTop,
      width: width - paddingLeft - paddingRight,
      height: height - paddingTop - paddingBottom
    };
  }
  // Canvas
  var Canvas$1 = /** @class */function () {
    function Canvas$1(props) {
      var context = props.context,
        _a = props.renderer,
        renderer = _a === void 0 ? new Renderer() : _a,
        width = props.width,
        height = props.height,
        customTheme = props.theme,
        customPx2hd = props.px2hd,
        customPixelRatio = props.pixelRatio,
        landscape = props.landscape,
        rendererContainer = props.container,
        // style: customStyle,
        _b = props.animate,
        // style: customStyle,
        animate = _b === void 0 ? true : _b,
        createImage = props.createImage,
        requestAnimationFrame = props.requestAnimationFrame,
        cancelAnimationFrame = props.cancelAnimationFrame;
      var px2hd$1 = isFunction(customPx2hd) ? batch2hd(customPx2hd) : px2hd;
      // 
      var theme = px2hd$1(__assign(__assign({}, THEME), customTheme));
      var pixelRatio = theme.pixelRatio,
        fontSize = theme.fontSize,
        fontFamily = theme.fontFamily;
      var devicePixelRatio = customPixelRatio ? customPixelRatio : pixelRatio;
      // 
      var updater = createUpdater(this);
      var canvasElement = createMobileCanvasElement(context);
      var canvas = new Canvas({
        container: rendererContainer,
        canvas: canvasElement,
        devicePixelRatio: devicePixelRatio,
        renderer: renderer,
        width: width,
        height: height,
        supportsTouchEvents: true,
        supportsPointerEvents: true,
        createImage: createImage,
        requestAnimationFrame: requestAnimationFrame,
        cancelAnimationFrame: cancelAnimationFrame,
        useNativeClickEvent: true
      });
      var container = canvas.getRoot();
      var _c = canvas.getConfig(),
        canvasWidth = _c.width,
        canvasHeight = _c.height;
      // 
      container.setAttribute('fontSize', fontSize);
      container.setAttribute('fontFamily', fontFamily);
      var gesture = new Gesture$1(container);
      // 
      var componentContext = {
        ctx: context,
        root: this,
        canvas: canvas,
        px2hd: px2hd$1,
        theme: theme,
        gesture: gesture,
        measureText: measureText(container, px2hd$1, theme)
      };
      var vNode = {
        key: undefined,
        tag: ClassComponent,
        // style: layout,
        // @ts-ignore
        type: Canvas$1,
        props: props,
        shape: container,
        animate: animate,
        // @ts-ignore
        component: this,
        canvas: this,
        context: componentContext,
        updater: updater
      };
      this._ee = new eventemitter3();
      this.props = props;
      this.context = componentContext;
      this.updater = updater;
      this.gesture = gesture;
      this.theme = theme;
      this.canvas = canvas;
      this.container = container;
      this.el = canvasElement;
      this.vNode = vNode;
      // todo: 
      this.landscape = landscape;
      this.updateLayout(__assign(__assign({}, props), {
        width: canvasWidth,
        height: canvasHeight
      }));
    }
    Canvas$1.prototype.updateComponents = function (components) {
      updateComponents(components);
    };
    Canvas$1.prototype.update = function (nextProps) {
      return __awaiter(this, void 0, void 0, function () {
        var _a, props, vNode, _b, animate;
        return __generator(this, function (_c) {
          switch (_c.label) {
            case 0:
              _a = this, props = _a.props, vNode = _a.vNode;
              if (equal(nextProps, props)) {
                return [2 /*return*/];
              }

              _b = props.animate, animate = _b === void 0 ? true : _b;
              this.props = nextProps;
              vNode.props = nextProps;
              vNode.animate = animate;
              return [4 /*yield*/, this.render()];
            case 1:
              _c.sent();
              return [2 /*return*/];
          }
        });
      });
    };

    Canvas$1.prototype.render = function () {
      return __awaiter(this, void 0, void 0, function () {
        var _a, canvas, vNode;
        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              _a = this, canvas = _a.canvas, vNode = _a.vNode;
              return [4 /*yield*/, canvas.ready];
            case 1:
              _b.sent();
              render(vNode);
              return [2 /*return*/];
          }
        });
      });
    };

    Canvas$1.prototype.emit = function (type, event) {
      this._ee.emit(type, event);
    };
    Canvas$1.prototype.on = function (type, listener) {
      this._ee.on(type, listener);
    };
    Canvas$1.prototype.off = function (type, listener) {
      this._ee.off(type, listener);
    };
    Canvas$1.prototype.getCanvasEl = function () {
      return this.el;
    };
    Canvas$1.prototype.resize = function (width, height) {
      return __awaiter(this, void 0, void 0, function () {
        var canvas;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              canvas = this.canvas;
              canvas.resize(width, height);
              this.updateLayout(__assign(__assign({}, this.props), {
                width: width,
                height: height
              }));
              return [4 /*yield*/, this.render()];
            case 1:
              _a.sent();
              return [2 /*return*/];
          }
        });
      });
    };

    Canvas$1.prototype.updateLayout = function (props) {
      var width = props.width,
        height = props.height;
      var _a = this.context,
        px2hd = _a.px2hd,
        theme = _a.theme;
      var style = px2hd(__assign({
        left: 0,
        top: 0,
        width: width,
        height: height,
        padding: theme.padding
      }, props.style));
      var layout = computeLayout$2(style);
      var left = layout.left,
        top = layout.top;
      //  container 
      this.container.setAttribute('x', left);
      this.container.setAttribute('y', top);
      this.context = __assign(__assign({}, this.context), {
        left: left,
        top: top,
        width: layout.width,
        height: layout.height
      });
      this.vNode = __assign(__assign({}, this.vNode), {
        style: layout,
        context: this.context
      });
    };
    Canvas$1.prototype.toRawChildren = function (children) {
      return children;
    };
    Canvas$1.prototype.destroy = function () {
      var _a = this,
        canvas = _a.canvas,
        children = _a.children,
        el = _a.el;
      destroyElement(children);
      //  canvas  spa  ios  canvas 
      // https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12
      // https://github.com/antvis/F2/issues/630
      el.width = 0;
      el.height = 0;
      this.props = null;
      this.context = null;
      this.updater = null;
      this.theme = null;
      this.canvas = null;
      this.container = null;
      this.el = null;
      this.vNode = null;
      //  ready
      canvas.ready.then(function () {
        canvas.destroy();
      });
    };
    return Canvas$1;
  }();

  function createRef() {
    var ref = {
      current: null
    };
    return ref;
  }

  var Timeline = /** @class */function (_super) {
    __extends(Timeline, _super);
    function Timeline(props) {
      var _this = _super.call(this, props) || this;
      _this.next = function () {
        var _a = _this,
          state = _a.state,
          props = _a.props;
        var index = state.index,
          count = state.count,
          delay = state.delay;
        var loop = props.loop;
        var next = loop ? (index + 1) % count : index + 1;
        if (next < count) {
          setTimeout(function () {
            _this.setState({
              index: next
            });
          }, delay || 0);
        }
      };
      var delay = props.delay,
        _a = props.start,
        start = _a === void 0 ? 0 : _a,
        children = props.children;
      var count = Children.toArray(children).length;
      _this.state = {
        delay: delay,
        count: count,
        index: start
      };
      return _this;
    }
    Timeline.prototype.didMount = function () {
      this.animator.on('end', this.next);
    };
    Timeline.prototype.didUnmount = function () {
      this.animator.off('end', this.next);
    };
    Timeline.prototype.render = function () {
      var _a = this,
        state = _a.state,
        props = _a.props;
      var children = props.children;
      var index = state.index;
      var childrenArray = Children.toArray(children);
      return childrenArray[index];
    };
    return Timeline;
  }(Component);

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var toPrimitive = createCommonjsModule(function (module) {
  var _typeof = _typeof_1["default"];
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var toPropertyKey = createCommonjsModule(function (module) {
  var _typeof = _typeof_1["default"];

  function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var defineProperty = createCommonjsModule(function (module) {
  function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);

  var objectSpread2 = createCommonjsModule(function (module) {
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _objectSpread = /*@__PURE__*/getDefaultExportFromCjs(objectSpread2);

  var classCallCheck = createCommonjsModule(function (module) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _classCallCheck = /*@__PURE__*/getDefaultExportFromCjs(classCallCheck);

  var createClass = createCommonjsModule(function (module) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _createClass$2 = /*@__PURE__*/getDefaultExportFromCjs(createClass);

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
  }
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var inherits = createCommonjsModule(function (module) {
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _inherits = /*@__PURE__*/getDefaultExportFromCjs(inherits);

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
  }
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _getPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf);

  var isNativeReflectConstruct = createCommonjsModule(function (module) {
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var assertThisInitialized = createCommonjsModule(function (module) {
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _assertThisInitialized$2 = /*@__PURE__*/getDefaultExportFromCjs(assertThisInitialized);

  var possibleConstructorReturn = createCommonjsModule(function (module) {
  var _typeof = _typeof_1["default"];

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized(self);
  }
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _possibleConstructorReturn = /*@__PURE__*/getDefaultExportFromCjs(possibleConstructorReturn);

  var createSuper = createCommonjsModule(function (module) {
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    };
  }
  module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _createSuper = /*@__PURE__*/getDefaultExportFromCjs(createSuper);

  var arrayWithHoles = createCommonjsModule(function (module) {
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var iterableToArrayLimit = createCommonjsModule(function (module) {
  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var arrayLikeToArray = createCommonjsModule(function (module) {
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var unsupportedIterableToArray = createCommonjsModule(function (module) {
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }
  module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var nonIterableRest = createCommonjsModule(function (module) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var slicedToArray = createCommonjsModule(function (module) {
  function _slicedToArray(arr, i) {
    return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
  }
  module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _slicedToArray = /*@__PURE__*/getDefaultExportFromCjs(slicedToArray);

  function transposedRect(_ref) {
    var xMin = _ref.xMin,
      xMax = _ref.xMax,
      yMin = _ref.yMin,
      yMax = _ref.yMax;
    return {
      xMin: yMin,
      xMax: yMax,
      yMin: xMin,
      yMax: xMax
    };
  }
  function _convertRect(_ref2) {
    var x = _ref2.x,
      y = _ref2.y,
      size = _ref2.size,
      y0 = _ref2.y0;
    var xMin;
    var xMax;
    if (isArray(x)) {
      xMin = x[0];
      xMax = x[1];
    } else {
      xMin = x - size / 2;
      xMax = x + size / 2;
    }
    var yMin;
    var yMax;
    if (isArray(y)) {
      yMin = y[0];
      yMax = y[1];
    } else {
      yMin = Math.min(y0, y);
      yMax = Math.max(y0, y);
    }
    return {
      xMin: xMin,
      xMax: xMax,
      yMin: yMin,
      yMax: yMax
    };
  }
  /**
   * 
   * convert
   * transform (x/y/size/y0yMin/yMax/..)
   */
  var Base = /*#__PURE__*/function () {
    function Base(option) {
      _classCallCheck(this, Base);
      this.left = 0;
      this.top = 0;
      this.width = 0;
      this.height = 0;
      // x y 
      this.transposed = false;
      // xy 
      this.x = [0, 1];
      this.y = [0, 1];
      this.update(option);
    }
    _createClass$2(Base, [{
      key: "update",
      value: function update(option) {
        mix(this, option);
        var left = this.left,
          top = this.top,
          width = this.width,
          height = this.height;
        this.right = left + width;
        this.bottom = top + height;
        this.center = {
          x: left + width / 2,
          y: top + height / 2
        };
        return this;
      }
      //   2 
    }, {
      key: "isCyclic",
      value: function isCyclic() {
        return false;
      }
    }, {
      key: "_zoomVal",
      value: function _zoomVal(val, func) {
        return isArray(val) ? val.map(function (v) {
          return func(v);
        }) : func(val);
      }
      /**
       * 
       * @param point
       */
    }, {
      key: "convert",
      value: function convert(point) {
        var transposed = this.transposed,
          x = this.x,
          y = this.y;
        var xDim = transposed ? 'y' : 'x';
        var yDim = transposed ? 'x' : 'y';
        var pointX = point[xDim];
        var pointY = point[yDim];
        // 
        if (pointX < 0 || pointX > 1 || pointY < 0 || pointY > 1) {
          return {
            x: NaN,
            y: NaN
          };
        }
        return {
          x: this._zoomVal(point[xDim], function (v) {
            return x[0] + (x[1] - x[0]) * v;
          }),
          y: this._zoomVal(point[yDim], function (v) {
            return y[0] + (y[1] - y[0]) * v;
          })
        };
      }
      /**
       * convert 
       */
    }, {
      key: "invert",
      value: function invert(point) {
        var _ref3;
        var transposed = this.transposed,
          x = this.x,
          y = this.y;
        var xDim = transposed ? 'y' : 'x';
        var yDim = transposed ? 'x' : 'y';
        return _ref3 = {}, _defineProperty(_ref3, xDim, this._zoomVal(point.x, function (v) {
          return (v - x[0]) / (x[1] - x[0]);
        })), _defineProperty(_ref3, yDim, this._zoomVal(point.y, function (v) {
          return (v - y[0]) / (y[1] - y[0]);
        })), _ref3;
      }
      /**
       *  canvas 
       * @param point
       * @returns
       */
    }, {
      key: "convertPoint",
      value: function convertPoint(point) {
        return this.convert(point);
      }
      /**
       * canvas
       */
    }, {
      key: "invertPoint",
      value: function invertPoint(point) {
        return this.invert(point);
      }
      // 
    }, {
      key: "convertRect",
      value: function convertRect(rectPoint) {
        var xRange = this.x,
          yRange = this.y,
          transposed = this.transposed;
        var _xRange = _slicedToArray(xRange, 2),
          xStart = _xRange[0],
          xEnd = _xRange[1];
        var _yRange = _slicedToArray(yRange, 2),
          yStart = _yRange[0],
          yEnd = _yRange[1];
        var rect = _convertRect(rectPoint);
        var _ref4 = transposed ? transposedRect(rect) : rect,
          xMin = _ref4.xMin,
          xMax = _ref4.xMax,
          yMin = _ref4.yMin,
          yMax = _ref4.yMax;
        var x0 = xStart + (xEnd - xStart) * xMin;
        var x1 = xStart + (xEnd - xStart) * xMax;
        var y0 = yStart + (yEnd - yStart) * yMin;
        var y1 = yStart + (yEnd - yStart) * yMax;
        return {
          xMin: Math.min(x0, x1),
          xMax: Math.max(x0, x1),
          yMin: Math.min(y0, y1),
          yMax: Math.max(y0, y1)
        };
      }
      // 
    }, {
      key: "transformToRect",
      value: function transformToRect(rectPoint) {
        var x = rectPoint.x,
          y = rectPoint.y,
          y0 = rectPoint.y0,
          size = rectPoint.size;
        var coordOrigin = this.convertPoint({
          x: 0,
          y: y0
        });
        var transposed = this.transposed;
        var _rectPoint = {
          size: size,
          x: transposed ? y : x,
          y: transposed ? x : y,
          y0: transposed ? coordOrigin.x : coordOrigin.y
        };
        var rect = _convertRect(_rectPoint);
        var _ref5 = transposed ? transposedRect(rect) : rect,
          xMin = _ref5.xMin,
          xMax = _ref5.xMax,
          yMin = _ref5.yMin,
          yMax = _ref5.yMax;
        return {
          xMin: xMin,
          xMax: xMax,
          yMin: yMin,
          yMax: yMax
        };
      }
    }]);
    return Base;
  }();

  var superPropBase = createCommonjsModule(function (module) {
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var get$1 = createCommonjsModule(function (module) {
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
    return _get.apply(this, arguments);
  }
  module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _get = /*@__PURE__*/getDefaultExportFromCjs(get$1);

  var Rect$1 = /*#__PURE__*/function (_Base) {
    _inherits(Rect, _Base);
    var _super = _createSuper(Rect);
    function Rect() {
      var _this;
      _classCallCheck(this, Rect);
      _this = _super.apply(this, arguments);
      _this.type = 'rect';
      return _this;
    }
    _createClass$2(Rect, [{
      key: "update",
      value: function update(option) {
        _get(_getPrototypeOf(Rect.prototype), "update", this).call(this, option);
        var left = this.left,
          top = this.top,
          width = this.width,
          height = this.height;
        var x = [left, left + width];
        var y = [top + height, top];
        this.x = x;
        this.y = y;
        return this;
      }
    }]);
    return Rect;
  }(Base);

  /**
   *  expand Vec2
   */
  var vec2Direction = function vec2Direction(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
  };
  var vec2Zero = function vec2Zero(v) {
    return v[0] === 0 && v[1] === 0;
  };
  var vec2AngleTo = function vec2AngleTo(v1, v2, direction) {
    var angle$1 = angle(v1, v2);
    var angleLargeThanPI = vec2Direction(v1, v2) >= 0;
    if (direction) {
      if (angleLargeThanPI) {
        return Math.PI * 2 - angle$1;
      }
      return angle$1;
    }
    if (angleLargeThanPI) {
      return angle$1;
    }
    return Math.PI * 2 - angle$1;
  };

  var Polar = /*#__PURE__*/function (_Base) {
    _inherits(Polar, _Base);
    var _super = _createSuper(Polar);
    function Polar() {
      var _this;
      _classCallCheck(this, Polar);
      _this = _super.apply(this, arguments);
      _this.type = 'polar';
      _this.isPolar = true;
      return _this;
    }
    _createClass$2(Polar, [{
      key: "update",
      value: function update(option) {
        _get(_getPrototypeOf(Polar.prototype), "update", this).call(this, option);
        if (!this.option) {
          this.option = option;
        }
        var _this$option = this.option,
          _this$option$radius = _this$option.radius,
          radiusRatio = _this$option$radius === void 0 ? 1 : _this$option$radius,
          _this$option$innerRad = _this$option.innerRadius,
          innerRadiusRatio = _this$option$innerRad === void 0 ? 0 : _this$option$innerRad;
        var width = this.width,
          height = this.height,
          _this$startAngle = this.startAngle,
          startAngle = _this$startAngle === void 0 ? -Math.PI / 2 : _this$startAngle,
          _this$endAngle = this.endAngle,
          endAngle = _this$endAngle === void 0 ? Math.PI * 3 / 2 : _this$endAngle;
        // 
        var radius = radiusRatio * (Math.min(width, height) / 2);
        //  x  y  
        var x = [startAngle, endAngle];
        var y = [innerRadiusRatio * radius, radius];
        this.x = x;
        this.y = y;
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.radius = radius;
        this.innnerRadius = innerRadiusRatio * radius;
        return this;
      }
    }, {
      key: "isCyclic",
      value: function isCyclic() {
        var startAngle = this.startAngle,
          endAngle = this.endAngle;
        if (endAngle - startAngle < Math.PI * 2) {
          return false;
        }
        return true;
      }
    }, {
      key: "convertPoint",
      value: function convertPoint(point) {
        var center = this.center,
          transposed = this.transposed,
          x = this.x,
          y = this.y;
        var xDim = transposed ? 'y' : 'x';
        var yDim = transposed ? 'x' : 'y';
        var _x = _slicedToArray(x, 2),
          xStart = _x[0],
          xEnd = _x[1];
        var _y = _slicedToArray(y, 2),
          yStart = _y[0],
          yEnd = _y[1];
        var angle = xStart + (xEnd - xStart) * point[xDim];
        var radius = yStart + (yEnd - yStart) * point[yDim];
        return {
          x: center.x + Math.cos(angle) * radius,
          y: center.y + Math.sin(angle) * radius
        };
      }
    }, {
      key: "invertPoint",
      value: function invertPoint(point) {
        var center = this.center,
          transposed = this.transposed,
          x = this.x,
          y = this.y;
        var xDim = transposed ? 'y' : 'x';
        var yDim = transposed ? 'x' : 'y';
        var _x2 = _slicedToArray(x, 2),
          xStart = _x2[0],
          xEnd = _x2[1];
        var _y2 = _slicedToArray(y, 2),
          yStart = _y2[0],
          yEnd = _y2[1];
        var m = [1, 0, 0, 1, 0, 0];
        rotate(m, m, xStart);
        var startV = [1, 0];
        transformMat2d(startV, startV, m);
        startV = [startV[0], startV[1]];
        var pointV = [point.x - center.x, point.y - center.y];
        if (vec2Zero(pointV)) {
          return {
            x: 0,
            y: 0
          };
        }
        var theta = vec2AngleTo(startV, pointV, xEnd < xStart);
        if (Math.abs(theta - Math.PI * 2) < 0.001) {
          theta = 0;
        }
        var l = length$1(pointV);
        var percentX = theta / (xEnd - xStart);
        percentX = xEnd - xStart > 0 ? percentX : -percentX;
        var percentY = (l - yStart) / (yEnd - yStart);
        var rst = {};
        rst[xDim] = percentX;
        rst[yDim] = percentY;
        return rst;
      }
    }]);
    return Polar;
  }(Base);

  var coordMap = {
    rect: Rect$1,
    polar: Polar
  };
  var coordController = /*#__PURE__*/function () {
    function coordController() {
      _classCallCheck(this, coordController);
    }
    _createClass$2(coordController, [{
      key: "getOption",
      value: function getOption(cfg) {
        if (isString(cfg)) {
          return {
            type: coordMap[cfg] || Rect$1
          };
        }
        if (isFunction(cfg)) {
          return {
            type: cfg
          };
        }
        var _ref = cfg || {},
          type = _ref.type;
        return _objectSpread(_objectSpread({}, cfg), {}, {
          // 
          type: isFunction(type) ? type : coordMap[type] || Rect$1
        });
      }
    }, {
      key: "create",
      value: function create(cfg) {
        var layout = this.layout;
        var option = this.getOption(cfg);
        var type = option.type;
        var coord = new type(_objectSpread(_objectSpread({}, option), layout));
        this.coord = coord;
        return coord;
      }
    }, {
      key: "updateLayout",
      value: function updateLayout(style) {
        var coord = this.coord;
        var left = style.left,
          top = style.top,
          width = style.width,
          height = style.height,
          padding = style.padding;
        var _ref2 = padding || [0, 0, 0, 0],
          _ref3 = _slicedToArray(_ref2, 4),
          paddingTop = _ref3[0],
          paddingRight = _ref3[1],
          paddingBottom = _ref3[2],
          paddingLeft = _ref3[3];
        this.layout = {
          left: left + paddingLeft,
          top: top + paddingTop,
          width: width - paddingLeft - paddingRight,
          height: height - paddingTop - paddingBottom
        };
        if (coord) {
          coord.update(this.layout);
        }
      }
    }, {
      key: "useLayout",
      value: function useLayout(positionLayout) {
        var coord = this.coord;
        var position = positionLayout.position,
          boxWidth = positionLayout.width,
          boxHeight = positionLayout.height;
        var left = coord.left,
          top = coord.top,
          width = coord.width,
          height = coord.height;
        switch (position) {
          case 'left':
            left += boxWidth;
            width = Math.max(0, width - boxWidth);
            break;
          case 'right':
            width = Math.max(0, width - boxWidth);
            break;
          case 'top':
            top += boxHeight;
            height = Math.max(0, height - boxHeight);
            break;
          case 'bottom':
            height = Math.max(0, height - boxHeight);
            break;
        }
        coord.update({
          left: left,
          top: top,
          width: width,
          height: height
        });
      }
    }, {
      key: "update",
      value: function update() {}
    }, {
      key: "getCoord",
      value: function getCoord() {
        return this.coord;
      }
    }]);
    return coordController;
  }();

  var methodCache = {};
  /**
   *  ticks 
   * @param key 
   * @returns  ticks 
   */
  function getTickMethod(key) {
    return methodCache[key];
  }
  /**
   *  ticks 
   * @param key 
   * @param method 
   */
  function registerTickMethod(key, method) {
    methodCache[key] = method;
  }

  var Scale = /*#__PURE__*/function () {
    function Scale(cfg) {
      _classCallCheck(this, Scale);
      /**
       * 
       */
      this.type = 'base';
      /**
       * 
       */
      this.isCategory = false;
      /**
       * linear, time 
       */
      this.isLinear = false;
      /**
       * linear,time,log, pow, quantile, quantize 
       */
      this.isContinuous = false;
      /**
       * 
       */
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    // transform/map
    _createClass$2(Scale, [{
      key: "translate",
      value: function translate(v) {
        return v;
      }
      /**  */
    }, {
      key: "change",
      value: function change(cfg) {
        // 
        mix(this.__cfg__, cfg);
        this.init();
      }
    }, {
      key: "clone",
      value: function clone() {
        return this.constructor(this.__cfg__);
      }
      /** ticks */
    }, {
      key: "getTicks",
      value: function getTicks() {
        var _this = this;
        return map(this.ticks, function (tick, idx) {
          if (isObject(tick)) {
            // Tick
            return tick;
          }
          return {
            text: _this.getText(tick, idx),
            tickValue: tick,
            value: _this.scale(tick) // scaled
          };
        });
      }
      /** Tick */
    }, {
      key: "getText",
      value: function getText(value, key) {
        var formatter = this.formatter;
        var res = formatter ? formatter(value, key) : value;
        if (isNil(res) || !isFunction(res.toString)) {
          return '';
        }
        return res.toString();
      }
      //  scale 
    }, {
      key: "getConfig",
      value: function getConfig(key) {
        return this.__cfg__[key];
      }
      // scale
    }, {
      key: "init",
      value: function init() {
        mix(this, this.__cfg__);
        this.setDomain();
        if (isEmpty(this.getConfig('ticks'))) {
          this.ticks = this.calculateTicks();
        }
      }
      // 
    }, {
      key: "initCfg",
      value: function initCfg() {}
    }, {
      key: "setDomain",
      value: function setDomain() {}
    }, {
      key: "calculateTicks",
      value: function calculateTicks() {
        var tickMethod = this.tickMethod;
        var ticks = [];
        if (isString(tickMethod)) {
          var method = getTickMethod(tickMethod);
          if (!method) {
            throw new Error('There is no method to to calculate ticks!');
          }
          ticks = method(this);
        } else if (isFunction(tickMethod)) {
          ticks = tickMethod(this);
        }
        return ticks;
      }
      // range 
    }, {
      key: "rangeMin",
      value: function rangeMin() {
        return this.range[0];
      }
      // range 
    }, {
      key: "rangeMax",
      value: function rangeMax() {
        return this.range[1];
      }
      /**  0~1 */
    }, {
      key: "calcPercent",
      value: function calcPercent(value, min, max) {
        if (isNumber(value)) {
          return (value - min) / (max - min);
        }
        return NaN;
      }
      /** 0~1 */
    }, {
      key: "calcValue",
      value: function calcValue(percent, min, max) {
        return min + percent * (max - min);
      }
    }]);
    return Scale;
  }();

  /**
   * 
   * @class
   */
  var Category = /*#__PURE__*/function (_Base) {
    _inherits(Category, _Base);
    var _super = _createSuper(Category);
    function Category() {
      var _this;
      _classCallCheck(this, Category);
      _this = _super.apply(this, arguments);
      _this.type = 'cat';
      _this.isCategory = true;
      return _this;
    }
    _createClass$2(Category, [{
      key: "buildIndexMap",
      value: function buildIndexMap() {
        if (!this.translateIndexMap) {
          this.translateIndexMap = new Map();
          // 
          for (var i = 0; i < this.values.length; i++) {
            this.translateIndexMap.set(this.values[i], i);
          }
        }
      }
    }, {
      key: "translate",
      value: function translate(value) {
        //  map
        this.buildIndexMap();
        // 
        var idx = this.translateIndexMap.get(value);
        if (idx === undefined) {
          idx = isNumber(value) ? value : NaN;
        }
        return idx;
      }
    }, {
      key: "scale",
      value: function scale(value) {
        var order = this.translate(value);
        //  0.5 
        // if (order < this.min - 0.5 || order > this.max + 0.5) {
        //   return NaN;
        // }
        var percent = this.calcPercent(order, this.min, this.max);
        return this.calcValue(percent, this.rangeMin(), this.rangeMax());
      }
    }, {
      key: "invert",
      value: function invert(scaledValue) {
        var domainRange = this.max - this.min;
        var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
        var idx = Math.round(domainRange * percent) + this.min;
        if (idx < this.min || idx > this.max) {
          return NaN;
        }
        return this.values[idx];
      }
    }, {
      key: "getText",
      value: function getText(value) {
        var _get2;
        var v = value;
        // valueindex
        if (isNumber(value) && !this.values.includes(value)) {
          v = this.values[v];
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return (_get2 = _get(_getPrototypeOf(Category.prototype), "getText", this)).call.apply(_get2, [this, v].concat(args));
      }
      // 
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'cat';
      }
      //  min, max
    }, {
      key: "setDomain",
      value: function setDomain() {
        //  min
        if (isNil(this.getConfig('min'))) {
          this.min = 0;
        }
        if (isNil(this.getConfig('max'))) {
          var size = this.values.length;
          this.max = size > 1 ? size - 1 : size;
        }
        // scale.init 
        if (this.translateIndexMap) {
          this.translateIndexMap = undefined;
        }
      }
    }]);
    return Category;
  }(Scale);

  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
      var newArr = [];
      for (var i = 0, len = arr.length; i < len; i++) {
          newArr.push(arr[i].substr(0, sLen));
      }
      return newArr;
  }
  function assign(origObj) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
      }
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
          var obj = args_1[_a];
          for (var key in obj) {
              // @ts-ignore ex
              origObj[key] = obj[key];
          }
      }
      return origObj;
  }
  var dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
  ];
  var monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
      dayNamesShort: dayNamesShort,
      dayNames: dayNames,
      monthNamesShort: monthNamesShort,
      monthNames: monthNames,
      amPm: ["am", "pm"],
      DoFn: function (dayOfMonth) {
          return (dayOfMonth +
              ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3
                  ? 0
                  : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);
      }
  };
  var globalI18n = assign({}, defaultI18n);
  var pad = function (val, len) {
      if (len === void 0) { len = 2; }
      val = String(val);
      while (val.length < len) {
          val = "0" + val;
      }
      return val;
  };
  var formatFlags = {
      D: function (dateObj) { return String(dateObj.getDate()); },
      DD: function (dateObj) { return pad(dateObj.getDate()); },
      Do: function (dateObj, i18n) {
          return i18n.DoFn(dateObj.getDate());
      },
      d: function (dateObj) { return String(dateObj.getDay()); },
      dd: function (dateObj) { return pad(dateObj.getDay()); },
      ddd: function (dateObj, i18n) {
          return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function (dateObj, i18n) {
          return i18n.dayNames[dateObj.getDay()];
      },
      M: function (dateObj) { return String(dateObj.getMonth() + 1); },
      MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },
      MMM: function (dateObj, i18n) {
          return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function (dateObj, i18n) {
          return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function (dateObj) {
          return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },
      h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },
      hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },
      H: function (dateObj) { return String(dateObj.getHours()); },
      HH: function (dateObj) { return pad(dateObj.getHours()); },
      m: function (dateObj) { return String(dateObj.getMinutes()); },
      mm: function (dateObj) { return pad(dateObj.getMinutes()); },
      s: function (dateObj) { return String(dateObj.getSeconds()); },
      ss: function (dateObj) { return pad(dateObj.getSeconds()); },
      S: function (dateObj) {
          return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function (dateObj) {
          return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },
      a: function (dateObj, i18n) {
          return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function (dateObj, i18n) {
          return dateObj.getHours() < 12
              ? i18n.amPm[0].toUpperCase()
              : i18n.amPm[1].toUpperCase();
      },
      ZZ: function (dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return ((offset > 0 ? "-" : "+") +
              pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));
      },
      Z: function (dateObj) {
          var offset = dateObj.getTimezoneOffset();
          return ((offset > 0 ? "-" : "+") +
              pad(Math.floor(Math.abs(offset) / 60), 2) +
              ":" +
              pad(Math.abs(offset) % 60, 2));
      }
  };
  // Some common format strings
  var globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
  };
  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   * @returns {string} Formatted date string
   */
  var format = function (dateObj, mask, i18n) {
      if (mask === void 0) { mask = globalMasks["default"]; }
      if (i18n === void 0) { i18n = {}; }
      if (typeof dateObj === "number") {
          dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" ||
          isNaN(dateObj.getTime())) {
          throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      // Make literals inactive by replacing them with @@@
      mask = mask.replace(literal, function ($0, $1) {
          literals.push($1);
          return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      // Apply formatting rules
      mask = mask.replace(token, function ($0) {
          return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      // Inline literal values back into the formatted value
      return mask.replace(/@@@/g, function () { return literals.shift(); });
  };

  function timeFormat(time, mask) {
    return format(time, mask);
  }
  /**
   * 
   * @param value 
   */
  function toTimeStamp(value) {
    if (isString(value)) {
      if (value.indexOf('T') > 0) {
        value = new Date(value).getTime();
      } else {
        // new Date('2010/01/10')  new Date('2010-01-10') :
        // : Fri Jan 10 2020 02:40:13 GMT+0800 ()
        //  Sun Jan 10 2010 08:00:00 GMT+0800 ()
        value = new Date(value.replace(/-/gi, '/')).getTime();
      }
    }
    if (isDate(value)) {
      value = value.getTime();
    }
    return value;
  }

  /**
   * 
   * @class
   */
  var TimeCat = /*#__PURE__*/function (_Category) {
    _inherits(TimeCat, _Category);
    var _super = _createSuper(TimeCat);
    function TimeCat() {
      var _this;
      _classCallCheck(this, TimeCat);
      _this = _super.apply(this, arguments);
      _this.type = 'timeCat';
      return _this;
    }
    /**
     * @override
     */
    _createClass$2(TimeCat, [{
      key: "translate",
      value: function translate(value) {
        value = toTimeStamp(value);
        var index = this.values.indexOf(value);
        if (index === -1) {
          if (isNumber(value) && value < this.values.length) {
            index = value;
          } else {
            index = NaN;
          }
        }
        return index;
      }
      /**
       *  getText
       * @override
       */
    }, {
      key: "getText",
      value: function getText(value, tickIndex) {
        var index = this.translate(value);
        if (index > -1) {
          var result = this.values[index];
          var formatter = this.formatter;
          result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
          return result;
        }
        return value;
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'time-cat';
        this.mask = 'YYYY-MM-DD';
        this.tickCount = 7; //  7 14 30 
      }
    }, {
      key: "setDomain",
      value: function setDomain() {
        var values = this.values;
        // 
        each(values, function (v, i) {
          values[i] = toTimeStamp(v);
        });
        values.sort(function (v1, v2) {
          return v1 - v2;
        });
        _get(_getPrototypeOf(TimeCat.prototype), "setDomain", this).call(this);
      }
    }]);
    return TimeCat;
  }(Category);

  /**
   * 
   * @class
   */
  var Continuous = /*#__PURE__*/function (_Base) {
    _inherits(Continuous, _Base);
    var _super = _createSuper(Continuous);
    function Continuous() {
      var _this;
      _classCallCheck(this, Continuous);
      _this = _super.apply(this, arguments);
      _this.isContinuous = true;
      return _this;
    }
    _createClass$2(Continuous, [{
      key: "scale",
      value: function scale(value) {
        if (isNil(value)) {
          return NaN;
        }
        var rangeMin = this.rangeMin();
        var rangeMax = this.rangeMax();
        var max = this.max;
        var min = this.min;
        if (max === min) {
          return rangeMin;
        }
        var percent = this.getScalePercent(value);
        return rangeMin + percent * (rangeMax - rangeMin);
      }
    }, {
      key: "init",
      value: function init() {
        _get(_getPrototypeOf(Continuous.prototype), "init", this).call(this);
        // init  min, max  ticks 
        var ticks = this.ticks;
        var firstTick = head(ticks);
        var lastTick = last(ticks);
        if (firstTick < this.min) {
          this.min = firstTick;
        }
        if (lastTick > this.max) {
          this.max = lastTick;
        }
        // strict-limit 
        if (!isNil(this.minLimit)) {
          this.min = firstTick;
        }
        if (!isNil(this.maxLimit)) {
          this.max = lastTick;
        }
      }
    }, {
      key: "setDomain",
      value: function setDomain() {
        var _getRange = getRange(this.values),
          min = _getRange.min,
          max = _getRange.max;
        if (isNil(this.min)) {
          this.min = min;
        }
        if (isNil(this.max)) {
          this.max = max;
        }
        if (this.min > this.max) {
          this.min = min;
          this.max = max;
        }
      }
    }, {
      key: "calculateTicks",
      value: function calculateTicks() {
        var _this2 = this;
        var ticks = _get(_getPrototypeOf(Continuous.prototype), "calculateTicks", this).call(this);
        if (!this.nice) {
          ticks = filter(ticks, function (tick) {
            return tick >= _this2.min && tick <= _this2.max;
          });
        }
        return ticks;
      }
      // 
    }, {
      key: "getScalePercent",
      value: function getScalePercent(value) {
        var max = this.max;
        var min = this.min;
        return (value - min) / (max - min);
      }
    }, {
      key: "getInvertPercent",
      value: function getInvertPercent(value) {
        return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
      }
    }]);
    return Continuous;
  }(Scale);

  /**
   * 
   * @class
   */
  var Linear = /*#__PURE__*/function (_Continuous) {
    _inherits(Linear, _Continuous);
    var _super = _createSuper(Linear);
    function Linear() {
      var _this;
      _classCallCheck(this, Linear);
      _this = _super.apply(this, arguments);
      _this.type = 'linear';
      _this.isLinear = true;
      return _this;
    }
    _createClass$2(Linear, [{
      key: "invert",
      value: function invert(value) {
        var percent = this.getInvertPercent(value);
        return this.min + percent * (this.max - this.min);
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'wilkinson-extended';
        this.nice = false;
      }
    }]);
    return Linear;
  }(Continuous);

  // ab x^^a = b;x
  //  b  
  function calBase(a, b) {
    var e = Math.E;
    var value;
    if (b >= 0) {
      value = Math.pow(e, Math.log(b) / a); // 
    } else {
      value = Math.pow(e, Math.log(-b) / a) * -1; // 
    }

    return value;
  }
  function log(a, b) {
    if (a === 1) {
      return 1;
    }
    return Math.log(b) / Math.log(a);
  }
  function getLogPositiveMin(values, base, max) {
    if (isNil(max)) {
      max = Math.max.apply(null, values);
    }
    var positiveMin = max;
    each(values, function (value) {
      if (value > 0 && value < positiveMin) {
        positiveMin = value;
      }
    });
    if (positiveMin === max) {
      positiveMin = max / base;
    }
    if (positiveMin > 1) {
      positiveMin = 1;
    }
    return positiveMin;
  }

  /**
   * Log 
   */
  var Log = /*#__PURE__*/function (_Continuous) {
    _inherits(Log, _Continuous);
    var _super = _createSuper(Log);
    function Log() {
      var _this;
      _classCallCheck(this, Log);
      _this = _super.apply(this, arguments);
      _this.type = 'log';
      return _this;
    }
    /**
     * @override
     */
    _createClass$2(Log, [{
      key: "invert",
      value: function invert(value) {
        var base = this.base;
        var max = log(base, this.max);
        var rangeMin = this.rangeMin();
        var range = this.rangeMax() - rangeMin;
        var min;
        var positiveMin = this.positiveMin;
        if (positiveMin) {
          if (value === 0) {
            return 0;
          }
          min = log(base, positiveMin / base);
          var appendPercent = 1 / (max - min) * range; // 0  positiveMin
          if (value < appendPercent) {
            //  0 - positiveMin 
            return value / appendPercent * positiveMin;
          }
        } else {
          min = log(base, this.min);
        }
        var percent = (value - rangeMin) / range;
        var tmp = percent * (max - min) + min;
        return Math.pow(base, tmp);
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'log';
        this.base = 10;
        this.tickCount = 6;
        this.nice = true;
      }
      // 
    }, {
      key: "setDomain",
      value: function setDomain() {
        _get(_getPrototypeOf(Log.prototype), "setDomain", this).call(this);
        var min = this.min;
        if (min < 0) {
          throw new Error('When you use log scale, the minimum value must be greater than zero!');
        }
        if (min === 0) {
          this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
        }
      }
      // 
    }, {
      key: "getScalePercent",
      value: function getScalePercent(value) {
        var max = this.max;
        var min = this.min;
        if (max === min) {
          return 0;
        }
        // 00
        if (value <= 0) {
          return 0;
        }
        var base = this.base;
        var positiveMin = this.positiveMin;
        // min == 0, 0tick0
        if (positiveMin) {
          min = positiveMin * 1 / base;
        }
        var percent;
        //  value /  
        if (value < positiveMin) {
          percent = value / positiveMin / (log(base, max) - log(base, min));
        } else {
          percent = (log(base, value) - log(base, min)) / (log(base, max) - log(base, min));
        }
        return percent;
      }
    }]);
    return Log;
  }(Continuous);

  /**
   * Pow 
   */
  var Pow = /*#__PURE__*/function (_Continuous) {
    _inherits(Pow, _Continuous);
    var _super = _createSuper(Pow);
    function Pow() {
      var _this;
      _classCallCheck(this, Pow);
      _this = _super.apply(this, arguments);
      _this.type = 'pow';
      return _this;
    }
    /**
     * @override
     */
    _createClass$2(Pow, [{
      key: "invert",
      value: function invert(value) {
        var percent = this.getInvertPercent(value);
        var exponent = this.exponent;
        var max = calBase(exponent, this.max);
        var min = calBase(exponent, this.min);
        var tmp = percent * (max - min) + min;
        var factor = tmp >= 0 ? 1 : -1;
        return Math.pow(tmp, exponent) * factor;
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'pow';
        this.exponent = 2;
        this.tickCount = 5;
        this.nice = true;
      }
      // value
    }, {
      key: "getScalePercent",
      value: function getScalePercent(value) {
        var max = this.max;
        var min = this.min;
        if (max === min) {
          return 0;
        }
        var exponent = this.exponent;
        var percent = (calBase(exponent, value) - calBase(exponent, min)) / (calBase(exponent, max) - calBase(exponent, min));
        return percent;
      }
    }]);
    return Pow;
  }(Continuous);

  /**
   * 
   * @class
   */
  var Time = /*#__PURE__*/function (_Linear) {
    _inherits(Time, _Linear);
    var _super = _createSuper(Time);
    function Time() {
      var _this;
      _classCallCheck(this, Time);
      _this = _super.apply(this, arguments);
      _this.type = 'time';
      return _this;
    }
    /**
     * @override
     */
    _createClass$2(Time, [{
      key: "getText",
      value: function getText(value, index) {
        var numberValue = this.translate(value);
        var formatter = this.formatter;
        return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
      }
      /**
       * @override
       */
    }, {
      key: "scale",
      value: function scale(value) {
        var v = value;
        if (isString(v) || isDate(v)) {
          v = this.translate(v);
        }
        return _get(_getPrototypeOf(Time.prototype), "scale", this).call(this, v);
      }
      /**
       * 
       * @override
       */
    }, {
      key: "translate",
      value: function translate(v) {
        return toTimeStamp(v);
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'time-pretty';
        this.mask = 'YYYY-MM-DD';
        this.tickCount = 7;
        this.nice = false;
      }
    }, {
      key: "setDomain",
      value: function setDomain() {
        var values = this.values;
        //  min, max this.min, this.max
        var minConfig = this.getConfig('min');
        var maxConfig = this.getConfig('max');
        //  min,max 
        if (!isNil(minConfig) || !isNumber(minConfig)) {
          this.min = this.translate(this.min);
        }
        if (!isNil(maxConfig) || !isNumber(maxConfig)) {
          this.max = this.translate(this.max);
        }
        //  min, max 
        if (values && values.length) {
          // 
          var timeStamps = [];
          var min = Infinity; // 
          var secondMin = min; // 
          var max = 0;
          // min,max,secondMin
          each(values, function (v) {
            var timeStamp = toTimeStamp(v);
            if (isNaN(timeStamp)) {
              throw new TypeError("Invalid Time: ".concat(v, " in time scale!"));
            }
            if (min > timeStamp) {
              secondMin = min;
              min = timeStamp;
            } else if (secondMin > timeStamp) {
              secondMin = timeStamp;
            }
            if (max < timeStamp) {
              max = timeStamp;
            }
            timeStamps.push(timeStamp);
          });
          // 
          if (values.length > 1) {
            this.minTickInterval = secondMin - min;
          }
          if (isNil(minConfig)) {
            this.min = min;
          }
          if (isNil(maxConfig)) {
            this.max = max;
          }
        }
      }
    }]);
    return Time;
  }(Linear);

  /**
   * 
   */
  var Quantize = /*#__PURE__*/function (_Continuous) {
    _inherits(Quantize, _Continuous);
    var _super = _createSuper(Quantize);
    function Quantize() {
      var _this;
      _classCallCheck(this, Quantize);
      _this = _super.apply(this, arguments);
      _this.type = 'quantize';
      return _this;
    }
    _createClass$2(Quantize, [{
      key: "invert",
      value: function invert(value) {
        var ticks = this.ticks;
        var length = ticks.length;
        var percent = this.getInvertPercent(value);
        var minIndex = Math.floor(percent * (length - 1));
        // 
        if (minIndex >= length - 1) {
          return last(ticks);
        }
        //  
        if (minIndex < 0) {
          return head(ticks);
        }
        var minTick = ticks[minIndex];
        var nextTick = ticks[minIndex + 1];
        //  tick 
        var minIndexPercent = minIndex / (length - 1);
        var maxIndexPercent = (minIndex + 1) / (length - 1);
        return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
      }
    }, {
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'r-pretty';
        this.tickCount = 5;
        this.nice = true;
      }
    }, {
      key: "calculateTicks",
      value: function calculateTicks() {
        var ticks = _get(_getPrototypeOf(Quantize.prototype), "calculateTicks", this).call(this);
        if (!this.nice) {
          //  nice = false , min, max
          if (last(ticks) !== this.max) {
            ticks.push(this.max);
          }
          if (head(ticks) !== this.min) {
            ticks.unshift(this.min);
          }
        }
        return ticks;
      }
      // 
    }, {
      key: "getScalePercent",
      value: function getScalePercent(value) {
        var ticks = this.ticks;
        // 
        if (value < head(ticks)) {
          return 0;
        }
        // 
        if (value > last(ticks)) {
          return 1;
        }
        var minIndex = 0;
        each(ticks, function (tick, index) {
          if (value >= tick) {
            minIndex = index;
          } else {
            return false;
          }
        });
        return minIndex / (ticks.length - 1);
      }
    }]);
    return Quantize;
  }(Continuous);

  var Quantile = /*#__PURE__*/function (_Quantize) {
    _inherits(Quantile, _Quantize);
    var _super = _createSuper(Quantile);
    function Quantile() {
      var _this;
      _classCallCheck(this, Quantile);
      _this = _super.apply(this, arguments);
      _this.type = 'quantile';
      return _this;
    }
    _createClass$2(Quantile, [{
      key: "initCfg",
      value: function initCfg() {
        this.tickMethod = 'quantile';
        this.tickCount = 5;
        this.nice = true;
      }
    }]);
    return Quantile;
  }(Quantize);

  var map$3 = {};
  function getClass(key) {
    return map$3[key];
  }
  function registerClass(key, cls) {
    if (getClass(key)) {
      throw new Error("type '".concat(key, "' existed."));
    }
    map$3[key] = cls;
  }

  /**
   * identity scalescale/invert
   * Rhttps://github.com/r-lib/scales/blob/master/R/pal-identity.r
   * d3https://github.com/d3/d3-scale/blob/master/src/identity.js
   */
  var Identity = /*#__PURE__*/function (_Base) {
    _inherits(Identity, _Base);
    var _super = _createSuper(Identity);
    function Identity() {
      var _this;
      _classCallCheck(this, Identity);
      _this = _super.apply(this, arguments);
      _this.type = 'identity';
      _this.isIdentity = true;
      return _this;
    }
    _createClass$2(Identity, [{
      key: "calculateTicks",
      value: function calculateTicks() {
        return this.values;
      }
    }, {
      key: "scale",
      value: function scale(value) {
        //  identity  dodge
        if (this.values[0] !== value && isNumber(value)) {
          return value;
        }
        return this.range[0];
      }
    }, {
      key: "invert",
      value: function invert(value) {
        var range = this.range;
        if (value < range[0] || value > range[1]) {
          return NaN;
        }
        return this.values[0];
      }
    }]);
    return Identity;
  }(Scale);

  // cat
  var CatTick = (function (cfg) {
    var values = cfg.values,
      tickCount = cfg.tickCount;
    if (!tickCount) {
      return values;
    }
    if (values.length <= 1) {
      return values;
    }
    // , 1
    var step = Math.floor(values.length / (tickCount - 1)) || 1;
    var ticks = [];
    // 
    for (var index = 0; index < values.length; index = index + step) {
      ticks.push(values[index]);
    }
    var last = values[values.length - 1];
    // tick
    if (ticks[ticks.length - 1] !== last) {
      if (ticks.length >= tickCount) {
        // tick
        ticks[ticks.length - 1] = last;
      } else {
        // tickCount
        ticks.push(last);
      }
    }
    return ticks;
  });

  // nice
  var SNAP_COUNT_ARRAY = [1, 1.2, 1.5, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];
  var DEFAULT_COUNT = 5; // 
  var LinearTick = (function (cfg) {
    var _ref = cfg || {},
      tickCount = _ref.tickCount,
      tickInterval = _ref.tickInterval;
    var _ref2 = cfg || {},
      min = _ref2.min,
      max = _ref2.max;
    min = isNaN(min) ? 0 : min;
    max = isNaN(max) ? 0 : max;
    var count = tickCount && tickCount >= 2 ? tickCount : DEFAULT_COUNT;
    // interval tickInterval
    var interval = tickInterval || getBestInterval({
      tickCount: count,
      max: max,
      min: min
    });
    // intervaltick
    var minTick = Math.floor(min / interval) * interval;
    // tickInterval, count tickInterval
    if (tickInterval) {
      var intervalCount = Math.abs(Math.ceil((max - minTick) / tickInterval)) + 1;
      // tickCount  count 
      count = Math.max(count, intervalCount);
    }
    var tickLength = 0;
    var fixedLength = getFixedLength(interval);
    if (min < 0 && max > 0 && count === 2) {
      return [toFixed(minTick, fixedLength), toFixed(Math.ceil(max / interval) * interval, fixedLength)];
    }
    var ticks = [];
    while (tickLength < count) {
      ticks.push(toFixed(minTick + tickLength * interval, fixedLength));
      tickLength++;
    }
    return ticks;
  });
  var DECIMAL_LENGTH = 12;
  function getFactor(number) {
    // 
    number = Math.abs(number);
    var factor = 1;
    if (number === 0) {
      return factor;
    }
    // 1,
    if (number < 1) {
      var count = 0;
      while (number < 1) {
        factor = factor / 10;
        number = number * 10;
        count++;
      }
      // 
      if (factor.toString().length > DECIMAL_LENGTH) {
        factor = parseFloat(factor.toFixed(count));
      }
      return factor;
    }
    // 10
    while (number > 10) {
      factor = factor * 10;
      number = number / 10;
    }
    return factor;
  }
  // 
  function getBestInterval(_ref3) {
    var tickCount = _ref3.tickCount,
      min = _ref3.min,
      max = _ref3.max;
    // 1
    if (min === max) {
      return 1 * getFactor(max);
    }
    // 1.
    var avgInterval = (max - min) / (tickCount - 1);
    // 2. [1-10]
    var factor = getFactor(avgInterval);
    var calInterval = avgInterval / factor;
    var calMax = max / factor;
    var calMin = min / factor;
    // 
    var similarityIndex = 0;
    for (var index = 0; index < SNAP_COUNT_ARRAY.length; index++) {
      var item = SNAP_COUNT_ARRAY[index];
      if (calInterval <= item) {
        similarityIndex = index;
        break;
      }
    }
    var similarityInterval = min < 0 && max > 0 && tickCount === 2 ? SNAP_COUNT_ARRAY[similarityIndex] : getInterval(similarityIndex, tickCount, calMin, calMax);
    // , similarityIndexsimilarityIndex
    var fixedLength = getFixedLength(similarityInterval) + getFixedLength(factor);
    return toFixed(similarityInterval * factor, fixedLength);
  }
  function getInterval(startIndex, tickCount, min, max) {
    var verify = false;
    var interval = SNAP_COUNT_ARRAY[startIndex];
    // 
    for (var i = startIndex; i < SNAP_COUNT_ARRAY.length; i++) {
      if (intervalIsVerify({
        interval: SNAP_COUNT_ARRAY[i],
        tickCount: tickCount,
        max: max,
        min: min
      })) {
        // interval
        interval = SNAP_COUNT_ARRAY[i];
        verify = true;
        break;
      }
    }
    // , 10
    if (!verify) {
      return 10 * getInterval(0, tickCount, min / 10, max / 10);
    }
    return interval;
  }
  // 
  function intervalIsVerify(_ref4) {
    var interval = _ref4.interval,
      tickCount = _ref4.tickCount,
      max = _ref4.max,
      min = _ref4.min;
    var minTick = Math.floor(min / interval) * interval;
    if (minTick + (tickCount - 1) * interval >= max) {
      return true;
    }
    return false;
  }
  // 
  function getFixedLength(num) {
    var str = num.toString();
    var index = str.indexOf('.');
    var indexOfExp = str.indexOf('e-');
    var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;
    if (length > 20) {
      // 20
      length = 20;
    }
    return length;
  }
  // @antv/util fixedbasemr
  function toFixed(v, length) {
    return parseFloat(v.toFixed(length));
  }

  registerClass('cat', Category);
  registerClass('category', Category);
  registerClass('identity', Identity);
  registerClass('linear', Linear);
  registerClass('log', Log);
  registerClass('pow', Pow);
  registerClass('time', Time);
  registerClass('timeCat', TimeCat);
  registerClass('quantize', Quantize);
  registerClass('quantile', Quantile);
  // 0.3.x cat 
  registerTickMethod('cat', CatTick);
  registerTickMethod('time-cat', CatTick);
  // linear tick
  registerTickMethod('wilkinson-extended', LinearTick);
  var ScaleController = /*#__PURE__*/function () {
    function ScaleController(data) {
      _classCallCheck(this, ScaleController);
      this.data = data;
      this.options = {};
      this.scales = {};
    }
    _createClass$2(ScaleController, [{
      key: "_getType",
      value: function _getType(option) {
        var type = option.type,
          values = option.values,
          field = option.field;
        if (type) {
          return type;
        }
        if (isNumber(field) || isNil(values[0]) && field) {
          return 'identity';
        }
        if (typeof values[0] === 'number') {
          return 'linear';
        }
        return 'cat';
      }
    }, {
      key: "_getOption",
      value: function _getOption(option) {
        var values = option.values,
          field = option.field,
          justifyContent = option.justifyContent;
        var type = this._getType(option);
        option.type = type;
        // identity
        if (type === 'identity') {
          option.field = field.toString();
          option.values = [field];
          return option;
        }
        // linear 
        if (type === 'linear') {
          // nice
          if (typeof option.nice !== 'boolean') {
            option.nice = true;
          }
          // 
          var _getRange = getRange(values),
            min = _getRange.min,
            max = _getRange.max;
          if (isNil(option.min)) {
            option.min = min;
          }
          if (isNil(option.max)) {
            option.max = max;
          }
          option.values = values.sort(function (a, b) {
            return a - b;
          });
          return option;
        }
        //  timeCat  range
        if (type === 'cat' || type === 'timeCat') {
          if (option.range) {
            return option;
          }
          var count = values.length;
          var range = [0, 1];
          // 
          if (count === 1) {
            range = [0.5, 1];
          } else if (justifyContent) {
            // 
            var offset = 1 / count * 0.5;
            range = [offset, 1 - offset];
          } else {
            //  1 / count
            var _offset = 1 / count;
            range = [0, 1 - _offset];
          }
          option.range = range;
        }
        return option;
      }
    }, {
      key: "createScale",
      value: function createScale(option) {
        var type = option.type;
        if (isFunction(type)) {
          return new type(option);
        }
        var ScaleClass = getClass(type);
        return new ScaleClass(option);
      }
      // scale
    }, {
      key: "setScale",
      value: function setScale(field, option) {
        var options = this.options,
          scales = this.scales;
        options[field] = mix({}, options[field], option);
        // scalescale 
        if (scales[field]) {
          scales[field].change(options[field]);
          // delete scales[field];
        }
      }
    }, {
      key: "create",
      value: function create(options) {
        this.update(options);
      }
    }, {
      key: "update",
      value: function update(options) {
        var _this = this;
        if (!options) return;
        each(options, function (option, field) {
          _this.setScale(field, option);
        });
      }
    }, {
      key: "changeData",
      value: function changeData(data) {
        this.data = data;
        this.scales = {};
      }
    }, {
      key: "getData",
      value: function getData() {
        return this.data;
      }
    }, {
      key: "getScale",
      value: function getScale(field) {
        var scales = this.scales,
          options = this.options,
          data = this.data;
        var scale = scales[field];
        if (scale) {
          return scale;
        }
        var option = options[field];
        if (!option) {
          return null;
        }
        var values = option.values ? option.values : data ? valuesOfKey(data, field) : [];
        var scaleOption = this._getOption(_objectSpread(_objectSpread({}, option), {}, {
          field: field,
          values: values
        }));
        var newScale = this.createScale(scaleOption);
        scales[field] = newScale;
        return newScale;
      }
    }, {
      key: "getScales",
      value: function getScales() {
        var _this2 = this;
        var options = this.options,
          scales = this.scales;
        each(options, function (option, field) {
          _this2.getScale(field);
        });
        return scales;
      }
    }, {
      key: "getOptions",
      value: function getOptions() {
        var scales = this.scales;
        var options = {};
        each(scales, function (scale, field) {
          options[field] = _objectSpread({}, scale.__cfg__);
        });
        return options;
      }
    }, {
      key: "adjustStartZero",
      value: function adjustStartZero(scale) {
        var options = this.options;
        var field = scale.field,
          min = scale.min,
          max = scale.max;
        var option = options[field];
        // 
        if (option && option.min) {
          return;
        }
        if (min > 0) {
          scale.change({
            min: 0
          });
        } else if (max < 0) {
          scale.change({
            max: 0
          });
        }
      }
      // scale
    }, {
      key: "adjustPieScale",
      value: function adjustPieScale(scale) {
        var options = this.options;
        var field = scale.field;
        var option = options[field];
        if (option && !isNil(option.nice)) {
          return null;
        }
        scale.change({
          nice: false
        });
      }
      // scale  0
    }, {
      key: "getZeroValue",
      value: function getZeroValue(scale) {
        var min = scale.min,
          max = scale.max;
        var value;
        if (min >= 0) {
          value = min;
        } else if (max <= 0) {
          value = max;
        } else {
          value = 0;
        }
        return scale.scale(value);
      }
    }]);
    return ScaleController;
  }();

  var axis = {
    labelOffset: '15px',
    line: {
      stroke: '#E8E8E8',
      lineWidth: '1px'
    },
    symbol: {
      fill: '#E8E8E8',
      radius: '10px'
    },
    tickLine: {
      stroke: '#E8E8E8'
    },
    label: {
      fill: '#808080',
      fontSize: '20px'
    },
    grid: {
      stroke: '#E8E8E8',
      lineWidth: '1px',
      lineDash: ['4px']
    }
  };
  var guide = {
    line: {
      style: {
        stroke: '#a3a3a3',
        lineWidth: 1
      },
      offsetX: 0,
      offsetY: 0
    },
    text: {
      style: {
        fill: '#787878',
        // textAlign: 'center',
        textBaseline: 'middle'
      },
      offsetX: 0,
      offsetY: 0
    },
    rect: {
      style: {
        fill: '#fafafa'
      }
    },
    arc: {
      style: {
        stroke: '#a3a3a3'
      }
    },
    html: {
      offsetX: 0,
      offsetY: 0,
      alignX: 'center',
      alignY: 'middle'
    },
    tag: {
      offsetX: 0,
      offsetY: 0,
      side: 4,
      background: {
        padding: 5,
        radius: 2,
        fill: '#1890FF'
      },
      textStyle: {
        fontSize: 12,
        fill: '#fff',
        textAlign: 'center',
        textBaseline: 'middle'
      }
    },
    point: {
      offsetX: 0,
      offsetY: 0,
      style: {
        fill: '#fff',
        r: 3,
        lineWidth: 2,
        stroke: '#1890ff'
      }
    }
  };
  var chart = {
    padding: ['30px', '30px', '30px', '30px']
  };
  var Theme = {
    chart: chart,
    colors: ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'],
    shapes: {
      line: ['line', 'dash', 'smooth'],
      point: ['circle', 'hollowCircle', 'rect'],
      area: ['area', 'smooth'],
      interval: ['rect', 'pyramid', 'funnel']
    },
    sizes: ['4px', '6px', '8px', '10px', '12px'],
    shape: {
      line: {
        default: {
          lineWidth: '4px',
          lineJoin: 'round',
          lineCap: 'round'
        },
        smooth: {
          smooth: true
        },
        dash: {
          lineDash: ['8px', '8px']
        }
      },
      point: {
        default: {
          size: '6px'
        },
        hollowCircle: {
          lineWidth: '2px'
        }
      },
      area: {
        default: {
          fillOpacity: 0.1
        }
      },
      interval: {
        default: {}
      }
    },
    axis: axis,
    guide: guide
  };

  // 
  var Chart = /*#__PURE__*/function (_Component) {
    _inherits(Chart, _Component);
    var _super = _createSuper(Chart);
    function Chart(props, context) {
      var _this;
      _classCallCheck(this, Chart);
      _this = _super.call(this, props);
      // 
      _this.componentsPosition = [];
      var theme = context.theme,
        px2hd = context.px2hd;
      // hack 
      // 
      context.theme = deepMix(px2hd(Theme), theme);
      var data = props.data;
      _this.scale = new ScaleController(data);
      _this.coord = new coordController();
      _this.coordRef = createRef();
      // state
      _this.state = {
        filters: {}
      };
      return _this;
    }
    _createClass$2(Chart, [{
      key: "getStyle",
      value: function getStyle(props) {
        var context = this.context,
          layout = this.layout;
        var theme = context.theme,
          px2hd = context.px2hd;
        var left = layout.left,
          top = layout.top,
          width = layout.width,
          height = layout.height;
        var customStyle = props.style;
        return px2hd(_objectSpread(_objectSpread({
          left: left,
          top: top,
          width: width,
          height: height
        }, theme.chart), customStyle));
      }
    }, {
      key: "willMount",
      value: function willMount() {
        var props = this.props,
          coord = this.coord,
          scale = this.scale;
        var scaleOptions = props.scale,
          coordOption = props.coord;
        var style = this.getStyle(props);
        coord.updateLayout(style);
        //  scale
        scale.create(scaleOptions);
        //  coord
        coord.create(coordOption);
      }
      // props 
    }, {
      key: "willReceiveProps",
      value: function willReceiveProps(nextProps, context) {
        var scale = this.scale,
          coord = this.coord,
          lastProps = this.props;
        var nextStyle = nextProps.style,
          nextData = nextProps.data,
          nextScale = nextProps.scale;
        var lastStyle = lastProps.style,
          lastData = lastProps.data,
          lastScale = lastProps.scale;
        // style 
        if (!equal(nextStyle, lastStyle) || context !== this.context) {
          var style = this.getStyle(nextProps);
          coord.updateLayout(style);
        }
        if (nextData !== lastData) {
          scale.changeData(nextData);
        }
        // scale
        if (!equal(nextScale, lastScale)) {
          scale.update(nextScale);
        }
      }
    }, {
      key: "willUpdate",
      value: function willUpdate() {
        this.coord.create(this.props.coord);
      }
    }, {
      key: "on",
      value: function on(eventName, listener) {
        this.gesture = this.gesture ? this.gesture : new Gesture$1(this.coordRef.current);
        this.gesture.on(eventName, listener);
      }
    }, {
      key: "off",
      value: function off(eventName, listener) {
        this.gesture.off(eventName, listener);
      }
      // 
    }, {
      key: "layoutCoord",
      value: function layoutCoord(layout) {
        this.coord.useLayout(layout);
      }
    }, {
      key: "resetCoordLayout",
      value: function resetCoordLayout() {
        var coord = this.coord,
          props = this.props;
        var style = this.getStyle(props);
        coord.updateLayout(style);
      }
    }, {
      key: "updateCoordLayout",
      value: function updateCoordLayout(layout) {
        var _this2 = this;
        if (isArray(layout)) {
          layout.forEach(function (item) {
            _this2.layoutCoord(item);
          });
          return;
        }
        this.layoutCoord(layout);
      }
    }, {
      key: "updateCoordFor",
      value: function updateCoordFor(component, layout) {
        var _this3 = this;
        if (!layout) return;
        var componentsPosition = this.componentsPosition;
        var componentPosition = {
          component: component,
          layout: layout
        };
        var existIndex = findIndex(componentsPosition, function (item) {
          return item.component === component;
        });
        // 
        if (existIndex > -1) {
          componentsPosition.splice(existIndex, 1, componentPosition);
          // 
          this.resetCoordLayout();
          componentsPosition.forEach(function (componentPosition) {
            var layout = componentPosition.layout;
            _this3.updateCoordLayout(layout);
          });
          return;
        }
        // 
        componentsPosition.push(componentPosition);
        this.updateCoordLayout(layout);
      }
    }, {
      key: "getGeometrys",
      value: function getGeometrys() {
        // @ts-ignore
        var children = this.children.children;
        var geometrys = [];
        Children.toArray(children).forEach(function (element) {
          if (!element) return false;
          var component = element.component;
          // @ts-ignore
          if (component && component.isGeometry) {
            geometrys.push(component);
          }
        });
        return geometrys;
      }
      /**
       * calculate dataset's position on canvas
       * @param  {Object} record the dataset
       * @return {Object} return the position
       */
    }, {
      key: "getPosition",
      value: function getPosition(record) {
        var coord = this.getCoord();
        var xScale = this.getXScales()[0];
        var xField = xScale.field;
        var yScales = this.getYScales();
        // default first
        var yScale = yScales[0];
        var yField = yScale.field;
        for (var i = 0, len = yScales.length; i < len; i++) {
          var scale = yScales[i];
          var field = scale.field;
          if (record[field]) {
            yScale = scale;
            yField = field;
            break;
          }
        }
        var x = xScale.scale(record[xField]);
        var y = yScale.scale(record[yField]);
        return coord.convertPoint({
          x: x,
          y: y
        });
      }
    }, {
      key: "getSnapRecords",
      value: function getSnapRecords(point, inCoordRange) {
        var geometrys = this.getGeometrys();
        if (!geometrys.length) return;
        // @ts-ignore
        return geometrys[0].getSnapRecords(point, inCoordRange);
      }
    }, {
      key: "getRecords",
      value: function getRecords(data, field) {
        var geometrys = this.getGeometrys();
        if (!geometrys.length) return;
        // @ts-ignore
        return geometrys[0].getRecords(data, field);
      }
    }, {
      key: "getLegendItems",
      value: function getLegendItems(point) {
        var geometrys = this.getGeometrys();
        if (!geometrys.length) return;
        // @ts-ignore
        return geometrys[0].getLegendItems(point);
      }
    }, {
      key: "setScale",
      value: function setScale(field, option) {
        this.scale.setScale(field, option);
      }
    }, {
      key: "getScale",
      value: function getScale(field) {
        return this.scale.getScale(field);
      }
    }, {
      key: "getScales",
      value: function getScales() {
        return this.scale.getScales();
      }
    }, {
      key: "getXScales",
      value: function getXScales() {
        var geometrys = this.getGeometrys();
        return geometrys.map(function (component) {
          // @ts-ignore
          return component.getXScale();
        });
      }
    }, {
      key: "getYScales",
      value: function getYScales() {
        var geometrys = this.getGeometrys();
        return geometrys.map(function (component) {
          // @ts-ignore
          return component.getYScale();
        });
      }
    }, {
      key: "getLayout",
      value: function getLayout() {
        return this.coord.layout;
      }
    }, {
      key: "getCoord",
      value: function getCoord() {
        return this.coord.coord;
      }
    }, {
      key: "filter",
      value: function filter(field, condition) {
        var filters = this.state.filters;
        this.setState({
          filters: _objectSpread(_objectSpread({}, filters), {}, _defineProperty({}, field, condition))
        });
      }
    }, {
      key: "_getRenderData",
      value: function _getRenderData() {
        var props = this.props,
          state = this.state;
        var data = props.data;
        var filters = state.filters;
        if (!filters || !Object.keys(filters).length) {
          return data;
        }
        var filteredData = data;
        each(filters, function (condition, field) {
          if (!condition) return;
          filteredData = filteredData.filter(function (record) {
            return condition(record[field], record);
          });
        });
        return filteredData;
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;
        var props = this.props,
          scale = this.scale,
          chartLayout = this.layout;
        var children = props.children,
          originData = props.data;
        if (!originData) return null;
        var data = this._getRenderData();
        var layout = this.getLayout();
        var coord = this.getCoord();
        var scaleOptions = scale.getOptions();
        var width = chartLayout.width,
          height = chartLayout.height;
        return jsx("group", {
          ref: this.coordRef,
          style: {
            width: width,
            height: height,
            fill: 'transparent'
          }
        }, Children.map(children, function (child) {
          return Children.cloneElement(child, {
            data: data,
            chart: _this4,
            layout: layout,
            coord: coord,
            //  scaleOptions  child  props  scale scale , scaleOptions 
            scaleOptions: scaleOptions
          });
        }));
      }
    }]);
    return Chart;
  }(Component);

  var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var objectWithoutProperties = createCommonjsModule(function (module) {
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _objectWithoutProperties = /*@__PURE__*/getDefaultExportFromCjs(objectWithoutProperties);

  function isEqual(origin1, origin2, fields) {
    if (origin1 === origin2) {
      return true;
    }
    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      if (origin1[field] !== origin2[field]) {
        return false;
      }
    }
    return true;
  }
  var Selection = /*#__PURE__*/function (_Component) {
    _inherits(Selection, _Component);
    var _super = _createSuper(Selection);
    function Selection(props, context) {
      var _this;
      _classCallCheck(this, Selection);
      _this = _super.call(this, props, context);
      var selection = props.selection;
      if (!selection) return _possibleConstructorReturn(_this);
      var defaultSelected = selection.defaultSelected;
      _this.state.selected = defaultSelected;
      return _this;
    }
    _createClass$2(Selection, [{
      key: "didMount",
      value: function didMount() {
        var _this2 = this;
        var props = this.props,
          state = this.state;
        var selection = props.selection,
          chart = props.chart;
        if (!selection) return;
        //  click
        var _selection$triggerOn = selection.triggerOn,
          triggerOn = _selection$triggerOn === void 0 ? 'click' : _selection$triggerOn;
        chart.on(triggerOn, function (ev) {
          var points = ev.points,
            x = ev.canvasX,
            y = ev.canvasY;
          var point = triggerOn === 'click' ? {
            x: x,
            y: y
          } : points[0];
          var records = _this2.getSnapRecords(point);
          var _selection$type = selection.type,
            type = _selection$type === void 0 ? 'single' : _selection$type,
            _selection$cancelable = selection.cancelable,
            cancelable = _selection$cancelable === void 0 ? true : _selection$cancelable;
          if (!records || !records.length) {
            if (cancelable) {
              _this2.setState({
                selected: null
              });
            }
            return;
          }
          var selected = state.selected;
          var origins = records.map(function (record) {
            return record.origin;
          });
          if (!selected || !selected.length) {
            _this2.setState({
              selected: origins
            });
          }
          if (type === 'single') {
            if (!cancelable) {
              _this2.setState({
                selected: origins
              });
              return;
            }
            var _newSelected = [];
            records.forEach(function (record) {
              if (!_this2.isSelected(record)) {
                _newSelected.push(record.origin);
              }
            });
            _this2.setState({
              selected: _newSelected
            });
            return;
          }
          // 
          var scales = chart.getScales();
          var fields = Object.keys(scales);
          var selectedMap = {};
          selected.forEach(function (item) {
            var key = fields.map(function (field) {
              return item[field];
            }).join('-');
            selectedMap[key] = item;
          });
          records.forEach(function (record) {
            var origin = record.origin;
            var key = fields.map(function (field) {
              return origin[field];
            }).join('-');
            selectedMap[key] = selectedMap[key] ? null : origin;
          });
          var newSelected = Object.keys(selectedMap).map(function (key) {
            return selectedMap[key];
          }).filter(Boolean);
          _this2.setState({
            selected: newSelected
          });
        });
      }
    }, {
      key: "willReceiveProps",
      value: function willReceiveProps(nextProps) {
        var nextSelection = nextProps.selection;
        var lastSelection = this.props.selection;
        if (!nextSelection || !lastSelection) {
          return;
        }
        var nextDefaultSelected = nextSelection.defaultSelected;
        var lastDefaultSelected = lastSelection.defaultSelected;
        if (!equal(nextDefaultSelected, lastDefaultSelected)) {
          this.state.selected = nextDefaultSelected;
        }
      }
    }, {
      key: "getSnapRecords",
      value: function getSnapRecords(_point) {
        return null;
      }
    }, {
      key: "isSelected",
      value: function isSelected(record) {
        var state = this.state,
          props = this.props;
        var selected = state.selected;
        if (!selected || !selected.length) {
          return false;
        }
        var chart = props.chart;
        var scales = chart.getScales();
        var fields = Object.keys(scales);
        for (var i = 0, len = selected.length; i < len; i++) {
          var item = selected[i];
          if (isEqual(record.origin, item, fields)) {
            return true;
          }
        }
        return false;
      }
    }, {
      key: "getSelectionStyle",
      value: function getSelectionStyle(record) {
        var state = this.state,
          props = this.props;
        var selected = state.selected;
        if (!selected || !selected.length) {
          return null;
        }
        var selection = props.selection;
        var selectedStyle = selection.selectedStyle,
          unSelectedStyle = selection.unSelectedStyle;
        var isSelected = this.isSelected(record);
        if (isSelected) {
          return isFunction(selectedStyle) ? selectedStyle(record) : selectedStyle;
        }
        return isFunction(unSelectedStyle) ? unSelectedStyle(record) : unSelectedStyle;
      }
    }]);
    return Selection;
  }(Component);

  var DEFAULT_Y = 0; //  y 
  // 
  var MARGIN_RATIO = 1 / 2;
  var DODGE_RATIO = 1 / 2;
  // 
  var GAP = 0.05;

  var Adjust = /*#__PURE__*/function () {
    function Adjust(cfg) {
      _classCallCheck(this, Adjust);
      var xField = cfg.xField,
        yField = cfg.yField,
        _cfg$adjustNames = cfg.adjustNames,
        adjustNames = _cfg$adjustNames === void 0 ? ['x', 'y'] : _cfg$adjustNames,
        dimValuesMap = cfg.dimValuesMap;
      this.adjustNames = adjustNames;
      this.xField = xField;
      this.yField = yField;
      this.dimValuesMap = dimValuesMap;
    }
    /**
     *  adjust 
     * @param dim
     */
    _createClass$2(Adjust, [{
      key: "isAdjust",
      value: function isAdjust(dim) {
        return this.adjustNames.indexOf(dim) >= 0;
      }
    }, {
      key: "getAdjustRange",
      value: function getAdjustRange(dim, dimValue, values) {
        var yField = this.yField;
        var index = values.indexOf(dimValue);
        var length = values.length;
        var pre;
        var next;
        //  y  y 
        if (!yField && this.isAdjust('y')) {
          pre = 0;
          next = 1;
        } else if (length > 1) {
          // 
          pre = values[index === 0 ? 0 : index - 1];
          // 
          next = values[index === length - 1 ? length - 1 : index + 1];
          if (index !== 0) {
            pre += (dimValue - pre) / 2;
          } else {
            pre -= (next - dimValue) / 2;
          }
          if (index !== length - 1) {
            next -= (next - dimValue) / 2;
          } else {
            next += (dimValue - values[length - 2]) / 2;
          }
        } else {
          pre = dimValue === 0 ? 0 : dimValue - 0.5;
          next = dimValue === 0 ? 1 : dimValue + 0.5;
        }
        return {
          pre: pre,
          next: next
        };
      }
    }, {
      key: "adjustData",
      value: function adjustData(groupedDataArray, mergedData) {
        var _this = this;
        // 
        var dimValuesMap = this.getDimValues(mergedData);
        // 
        each(groupedDataArray, function (dataArray, index) {
          // 
          //  dim 
          each(dimValuesMap, function (values, dim) {
            // 
            _this.adjustDim(dim, values, dataArray, index);
          });
        });
      }
      /**
       * adjustData
       * @param data 
       * @param dim 
       * @return 
       */
    }, {
      key: "groupData",
      value: function groupData(data, dim) {
        // 
        each(data, function (record) {
          if (record[dim] === undefined) {
            record[dim] = DEFAULT_Y;
          }
        });
        //  dim 
        return groupBy(data, dim);
      }
      /** @override */
    }, {
      key: "adjustDim",
      value: function adjustDim(_dim, _values, _data, _index) {}
      /**
       * 
       * @param mergedData 
       * @return 
       */
    }, {
      key: "getDimValues",
      value: function getDimValues(mergedData) {
        var xField = this.xField,
          yField = this.yField;
        var dimValuesMap = mix({}, this.dimValuesMap);
        // 
        var dims = [];
        if (xField && this.isAdjust('x')) {
          dims.push(xField);
        }
        if (yField && this.isAdjust('y')) {
          dims.push(yField);
        }
        dims.forEach(function (dim) {
          if (dimValuesMap && dimValuesMap[dim]) {
            return;
          }
          // 
          dimValuesMap[dim] = valuesOfKey(mergedData, dim).sort(function (v1, v2) {
            return v1 - v2;
          });
        });
        //  y
        if (!yField && this.isAdjust('y')) {
          var dim = 'y';
          dimValuesMap[dim] = [DEFAULT_Y, 1]; //  y  0  1 
        }

        return dimValuesMap;
      }
    }]);
    return Adjust;
  }();

  var Dodge = /*#__PURE__*/function (_Adjust) {
    _inherits(Dodge, _Adjust);
    var _super = _createSuper(Dodge);
    function Dodge(cfg) {
      var _this;
      _classCallCheck(this, Dodge);
      _this = _super.call(this, cfg);
      _this.cacheMap = {};
      _this.adjustDataArray = [];
      _this.mergeData = [];
      var _cfg$marginRatio = cfg.marginRatio,
        marginRatio = _cfg$marginRatio === void 0 ? MARGIN_RATIO : _cfg$marginRatio,
        _cfg$dodgeRatio = cfg.dodgeRatio,
        dodgeRatio = _cfg$dodgeRatio === void 0 ? DODGE_RATIO : _cfg$dodgeRatio,
        dodgeBy = cfg.dodgeBy,
        intervalPadding = cfg.intervalPadding,
        dodgePadding = cfg.dodgePadding,
        xDimensionLength = cfg.xDimensionLength,
        groupNum = cfg.groupNum,
        defaultSize = cfg.defaultSize,
        maxColumnWidth = cfg.maxColumnWidth,
        minColumnWidth = cfg.minColumnWidth,
        columnWidthRatio = cfg.columnWidthRatio,
        customOffset = cfg.customOffset;
      _this.marginRatio = marginRatio;
      _this.dodgeRatio = dodgeRatio;
      _this.dodgeBy = dodgeBy;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.xDimensionLegenth = xDimensionLength;
      _this.groupNum = groupNum;
      _this.defaultSize = defaultSize;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.customOffset = customOffset;
      return _this;
    }
    _createClass$2(Dodge, [{
      key: "process",
      value: function process(groupDataArray) {
        var groupedDataArray = clone$2(groupDataArray);
        // 
        var mergeData = flatten(groupedDataArray);
        var dodgeBy = this.dodgeBy;
        //  dim 
        var adjustDataArray = dodgeBy ? group(mergeData, dodgeBy) : groupedDataArray;
        this.cacheMap = {};
        this.adjustDataArray = adjustDataArray;
        this.mergeData = mergeData;
        this.adjustData(adjustDataArray, mergeData);
        this.adjustDataArray = [];
        this.mergeData = [];
        return groupedDataArray;
      }
    }, {
      key: "adjustDim",
      value: function adjustDim(dim, values, data, frameIndex) {
        var _this2 = this;
        var customOffset = this.customOffset;
        var map = this.getDistribution(dim);
        var groupData = this.groupData(data, dim); // 
        each(groupData, function (group, key) {
          var range;
          // xField  dodge
          if (values.length === 1) {
            range = {
              pre: values[0] - 1,
              next: values[0] + 1
            };
          } else {
            // 
            range = _this2.getAdjustRange(dim, parseFloat(key), values);
          }
          each(group, function (d) {
            var value = d[dim];
            var valueArr = map[value];
            var valIndex = valueArr.indexOf(frameIndex);
            if (!isNil(customOffset)) {
              var _range = range,
                pre = _range.pre,
                next = _range.next;
              d[dim] = isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;
            } else {
              d[dim] = _this2.getDodgeOffset(range, valIndex, valueArr.length);
            }
          });
        });
        return [];
      }
    }, {
      key: "getDodgeOffset",
      value: function getDodgeOffset(range, idx, len) {
        var dodgeRatio = this.dodgeRatio,
          marginRatio = this.marginRatio,
          intervalPadding = this.intervalPadding,
          dodgePadding = this.dodgePadding;
        var pre = range.pre,
          next = range.next;
        var tickLength = next - pre;
        var position;
        // 
        if (!isNil(intervalPadding) && isNil(dodgePadding) && intervalPadding >= 0) {
          // intervalPadding
          var offset = this.getIntervalOnlyOffset(len, idx);
          position = pre + offset;
        } else if (!isNil(dodgePadding) && isNil(intervalPadding) && dodgePadding >= 0) {
          // dodgePadding
          var _offset = this.getDodgeOnlyOffset(len, idx);
          position = pre + _offset;
        } else if (!isNil(intervalPadding) && !isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
          // intervalPaddingdodgePadding
          var _offset2 = this.getIntervalAndDodgeOffset(len, idx);
          position = pre + _offset2;
        } else {
          // 
          var width = tickLength * dodgeRatio / len;
          var margin = marginRatio * width;
          var _offset3 = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
          position = (pre + next) / 2 + _offset3;
        }
        return position;
      }
    }, {
      key: "getIntervalOnlyOffset",
      value: function getIntervalOnlyOffset(len, idx) {
        var defaultSize = this.defaultSize,
          intervalPadding = this.intervalPadding,
          xDimensionLegenth = this.xDimensionLegenth,
          groupNum = this.groupNum,
          dodgeRatio = this.dodgeRatio,
          maxColumnWidth = this.maxColumnWidth,
          minColumnWidth = this.minColumnWidth,
          columnWidthRatio = this.columnWidthRatio;
        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
        var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        // columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth
        geomWidth = !isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
        if (!isNil(maxColumnWidth)) {
          var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
          geomWidth = Math.min(geomWidth, normalizedMaxWidht);
        }
        if (!isNil(minColumnWidth)) {
          var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
          geomWidth = Math.max(geomWidth, normalizedMinWidht);
        }
        geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
        // 
        normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
        return offset;
      }
    }, {
      key: "getDodgeOnlyOffset",
      value: function getDodgeOnlyOffset(len, idx) {
        var defaultSize = this.defaultSize,
          dodgePadding = this.dodgePadding,
          xDimensionLegenth = this.xDimensionLegenth,
          groupNum = this.groupNum,
          marginRatio = this.marginRatio,
          maxColumnWidth = this.maxColumnWidth,
          minColumnWidth = this.minColumnWidth,
          columnWidthRatio = this.columnWidthRatio;
        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
        var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        // columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth
        geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
        if (!isNil(maxColumnWidth)) {
          var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
          geomWidth = Math.min(geomWidth, normalizedMaxWidht);
        }
        if (!isNil(minColumnWidth)) {
          var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
          geomWidth = Math.max(geomWidth, normalizedMinWidht);
        }
        geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
        // 
        normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
        return offset;
      }
    }, {
      key: "getIntervalAndDodgeOffset",
      value: function getIntervalAndDodgeOffset(len, idx) {
        var intervalPadding = this.intervalPadding,
          dodgePadding = this.dodgePadding,
          xDimensionLegenth = this.xDimensionLegenth,
          groupNum = this.groupNum;
        var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
        var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
        var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
        var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
        return offset;
      }
    }, {
      key: "getDistribution",
      value: function getDistribution(dim) {
        var groupedDataArray = this.adjustDataArray;
        var cacheMap = this.cacheMap;
        var map = cacheMap[dim];
        if (!map) {
          map = {};
          each(groupedDataArray, function (data, index) {
            var values = valuesOfKey(data, dim);
            if (!values.length) {
              values.push(0);
            }
            each(values, function (val) {
              if (!map[val]) {
                map[val] = [];
              }
              map[val].push(index);
            });
          });
          cacheMap[dim] = map;
        }
        return map;
      }
    }]);
    return Dodge;
  }(Adjust);

  function randomNumber(min, max) {
    return (max - min) * Math.random() + min;
  }
  var Jitter = /*#__PURE__*/function (_Adjust) {
    _inherits(Jitter, _Adjust);
    var _super = _createSuper(Jitter);
    function Jitter() {
      _classCallCheck(this, Jitter);
      return _super.apply(this, arguments);
    }
    _createClass$2(Jitter, [{
      key: "process",
      value: function process(groupDataArray) {
        var groupedDataArray = clone$2(groupDataArray);
        // 
        var mergeData = flatten(groupedDataArray);
        // 
        this.adjustData(groupedDataArray, mergeData);
        return groupedDataArray;
      }
      /**
       * index dim  jitter 
       * @param dim
       * @param values
       * @param dataArray
       */
    }, {
      key: "adjustDim",
      value: function adjustDim(dim, values, dataArray) {
        var _this = this;
        //  dim 
        var groupDataArray = this.groupData(dataArray, dim);
        return each(groupDataArray, function (data, dimValue) {
          return _this.adjustGroup(data, dim, parseFloat(dimValue), values);
        });
      }
      // 
    }, {
      key: "getAdjustOffset",
      value: function getAdjustOffset(range) {
        var pre = range.pre,
          next = range.next;
        // 
        var margin = (next - pre) * GAP;
        return randomNumber(pre + margin, next - margin);
      }
      // adjust group data
    }, {
      key: "adjustGroup",
      value: function adjustGroup(group, dim, dimValue, values) {
        var _this2 = this;
        // 
        var range = this.getAdjustRange(dim, dimValue, values);
        each(group, function (data) {
          data[dim] = _this2.getAdjustOffset(range); // 
        });

        return group;
      }
    }]);
    return Jitter;
  }(Adjust);

  var Stack = /*#__PURE__*/function (_Adjust) {
    _inherits(Stack, _Adjust);
    var _super = _createSuper(Stack);
    function Stack(cfg) {
      var _this;
      _classCallCheck(this, Stack);
      _this = _super.call(this, cfg);
      var _cfg$adjustNames = cfg.adjustNames,
        adjustNames = _cfg$adjustNames === void 0 ? ['y'] : _cfg$adjustNames,
        _cfg$height = cfg.height,
        height = _cfg$height === void 0 ? NaN : _cfg$height,
        _cfg$size = cfg.size,
        size = _cfg$size === void 0 ? 10 : _cfg$size,
        _cfg$reverseOrder = cfg.reverseOrder,
        reverseOrder = _cfg$reverseOrder === void 0 ? false : _cfg$reverseOrder;
      _this.adjustNames = adjustNames;
      _this.height = height;
      _this.size = size;
      _this.reverseOrder = reverseOrder;
      return _this;
    }
    /**
     * 
     * @param groupDataArray 
     */
    _createClass$2(Stack, [{
      key: "process",
      value: function process(groupDataArray) {
        var yField = this.yField,
          reverseOrder = this.reverseOrder;
        //  y  y  stack
        // 
        var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
        return reverseOrder ? this.reverse(d) : d;
      }
    }, {
      key: "reverse",
      value: function reverse(groupedDataArray) {
        return groupedDataArray.slice(0).reverse();
      }
    }, {
      key: "processStack",
      value: function processStack(groupDataArray) {
        var xField = this.xField,
          yField = this.yField,
          reverseOrder = this.reverseOrder;
        // 
        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
        // 
        var positive = new default_1();
        var negative = new default_1();
        return groupedDataArray.map(function (dataArray) {
          return dataArray.map(function (data) {
            var x = get(data, xField, 0);
            var y = get(data, [yField]);
            var xKey = x.toString();
            // todo  _origin y  symmetric stack
            y = isArray(y) ? y[1] : y;
            if (!isNil(y)) {
              var cache = y >= 0 ? positive : negative;
              if (!cache.has(xKey)) {
                cache.set(xKey, 0);
              }
              var xValue = cache.get(xKey);
              var newXValue = y + xValue;
              // 
              cache.set(xKey, newXValue);
              return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, yField, [xValue, newXValue]));
            }
            // 
            return data;
          });
        });
      }
    }, {
      key: "processOneDimStack",
      value: function processOneDimStack(groupDataArray) {
        var _this2 = this;
        var xField = this.xField,
          height = this.height,
          reverseOrder = this.reverseOrder;
        var yField = 'y';
        // 
        var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
        // 
        var cache = new default_1();
        return groupedDataArray.map(function (dataArray) {
          return dataArray.map(function (data) {
            var size = _this2.size;
            var xValue = data[xField];
            // todo  stack 
            var stackHeight = size * 2 / height;
            if (!cache.has(xValue)) {
              cache.set(xValue, stackHeight / 2); // 
            }

            var stackValue = cache.get(xValue);
            //  stackHeight
            cache.set(xValue, stackValue + stackHeight);
            return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, yField, stackValue));
          });
        });
      }
    }]);
    return Stack;
  }(Adjust);

  var arrayWithoutHoles = createCommonjsModule(function (module) {
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
  module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var iterableToArray = createCommonjsModule(function (module) {
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var nonIterableSpread = createCommonjsModule(function (module) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var toConsumableArray = createCommonjsModule(function (module) {
  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }
  module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _toConsumableArray = /*@__PURE__*/getDefaultExportFromCjs(toConsumableArray);

  var Symmetric = /*#__PURE__*/function (_Adjust) {
    _inherits(Symmetric, _Adjust);
    var _super = _createSuper(Symmetric);
    function Symmetric() {
      _classCallCheck(this, Symmetric);
      return _super.apply(this, arguments);
    }
    _createClass$2(Symmetric, [{
      key: "process",
      value: function process(groupDataArray) {
        var mergeData = flatten(groupDataArray);
        var xField = this.xField,
          yField = this.yField;
        //  x  
        var cache = this.getXValuesMaxMap(mergeData);
        // 
        var max = Math.max.apply(Math, _toConsumableArray(Object.keys(cache).map(function (key) {
          return cache[key];
        })));
        return map(groupDataArray, function (dataArray) {
          return map(dataArray, function (data) {
            var yValue = data[yField];
            var xValue = data[xField];
            // 
            if (isArray(yValue)) {
              var off = (max - cache[xValue]) / 2;
              return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, yField, map(yValue, function (y) {
                return off + y;
              })));
            }
            // 
            var offset = (max - yValue) / 2;
            return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, yField, [offset, yValue + offset]));
          });
        });
      }
      //  x 
    }, {
      key: "getXValuesMaxMap",
      value: function getXValuesMaxMap(mergeData) {
        var _this = this;
        var xField = this.xField,
          yField = this.yField;
        //  xField 
        var groupDataArray = groupBy(mergeData, function (data) {
          return data[xField];
        });
        //  xField 
        return mapValues(groupDataArray, function (dataArray) {
          return _this.getDimMaxValue(dataArray, yField);
        });
      }
    }, {
      key: "getDimMaxValue",
      value: function getDimMaxValue(mergeData, dim) {
        //  value 
        var dimValues = map(mergeData, function (data) {
          return get(data, dim, []);
        });
        // dim value  stack 
        var flattenValues = flatten(dimValues);
        // 
        return Math.max.apply(Math, _toConsumableArray(flattenValues));
      }
    }]);
    return Symmetric;
  }(Adjust);

  function toTimeStamp$1(value) {
    if (isString(value)) {
      if (value.indexOf('T') > 0) {
        value = new Date(value).getTime();
      } else {
        // new Date('2010/01/10')  new Date('2010-01-10') :
        // : Fri Jan 10 2020 02:40:13 GMT+0800 ()
        //  Sun Jan 10 2010 08:00:00 GMT+0800 ()
        value = new Date(value.replace(/-/gi, '/')).getTime();
      }
    }
    if (isDate(value)) {
      value = value.getTime();
    }
    return value;
  }

  var Base$1 = /*#__PURE__*/function () {
    function Base(options) {
      _classCallCheck(this, Base);
      mix(this, options);
      var scale = this.scale,
        field = this.field,
        data = this.data;
      if (!scale && data) {
        var values = valuesOfKey(data, field);
        this.scale = this.createScale({
          values: values,
          field: field
        });
      }
    }
    _createClass$2(Base, [{
      key: "createScale",
      value: function createScale(_scaleConfig) {
        return null;
      }
      // 
    }, {
      key: "_mapping",
      value: function _mapping(value) {
        return value;
      }
    }, {
      key: "update",
      value: function update(options) {
        mix(this, options);
      }
    }, {
      key: "setRange",
      value: function setRange(range) {
        this.range = range;
      }
      // 
    }, {
      key: "normalize",
      value: function normalize(value) {
        var scale = this.scale;
        if (isArray(value)) {
          return value.map(function (v) {
            return scale.scale(v);
          });
        }
        return scale.scale(value);
      }
      // convert 
    }, {
      key: "convert",
      value: function convert(value) {
        return value;
      }
      //  normalize + convert 
    }, {
      key: "mapping",
      value: function mapping(value) {
        var child = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var rst = isFunction(this.callback) ? this.callback(value, child) : null;
        if (!isNil(rst)) {
          return rst;
        }
        return this._mapping(value);
      }
    }]);
    return Base;
  }();

  function define$1 (constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend$1(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color$1() {}
  var _darker = 0.7;
  var _brighter = 1 / _darker;
  var reI$1 = "\\s*([+-]?\\d+)\\s*",
    reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex$1 = /^#([0-9a-f]{3,8})$/,
    reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"),
    reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"),
    reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"),
    reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"),
    reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"),
    reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
  var named$1 = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };
  define$1(Color$1, color$1, {
    copy: function copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable: function displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex$1,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex$1,
    formatHsl: color_formatHsl$1,
    formatRgb: color_formatRgb$1,
    toString: color_formatRgb$1
  });
  function color_formatHex$1() {
    return this.rgb().formatHex();
  }
  function color_formatHsl$1() {
    return hslConvert$1(this).formatHsl();
  }
  function color_formatRgb$1() {
    return this.rgb().formatRgb();
  }
  function color$1(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) // #ff0000
    : l === 3 ? new Rgb$1(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
    : l === 8 ? rgba$1(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
    : l === 4 ? rgba$1(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
    : null // invalid hex
    ) : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
    : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
    : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
    : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
    : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
    : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
    : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) // eslint-disable-line no-prototype-builtins
    : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
  }
  function rgbn$1(n) {
    return new Rgb$1(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }
  function rgba$1(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb$1(r, g, b, a);
  }
  function rgbConvert$1(o) {
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Rgb$1();
    o = o.rgb();
    return new Rgb$1(o.r, o.g, o.b, o.opacity);
  }
  function rgb$1(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb$1(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define$1(Rgb$1, rgb$1, extend$1(Color$1, {
    brighter: function brighter(k) {
      k = k == null ? _brighter : Math.pow(_brighter, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function darker(k) {
      k = k == null ? _darker : Math.pow(_darker, k);
      return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function rgb() {
      return this;
    },
    displayable: function displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: rgb_formatHex$1,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex$1,
    formatRgb: rgb_formatRgb$1,
    toString: rgb_formatRgb$1
  }));
  function rgb_formatHex$1() {
    return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
  }
  function rgb_formatRgb$1() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
  function hex$1(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla$1(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
    return new Hsl$1(h, s, l, a);
  }
  function hslConvert$1(o) {
    if (o instanceof Hsl$1) return new Hsl$1(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$1)) o = color$1(o);
    if (!o) return new Hsl$1();
    if (o instanceof Hsl$1) return o;
    o = o.rgb();
    var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl$1(h, s, l, o.opacity);
  }
  function hsl$1(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl$1(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define$1(Hsl$1, hsl$1, extend$1(Color$1, {
    brighter: function brighter(k) {
      k = k == null ? _brighter : Math.pow(_brighter, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function darker(k) {
      k = k == null ? _darker : Math.pow(_darker, k);
      return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function rgb() {
      var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
      return new Rgb$1(hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$1(h, m1, m2), hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
    },
    displayable: function displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl: function formatHsl() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
    }
  }));

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb$1(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  var constant = (function (x) {
    return function () {
      return x;
    };
  });

  function linear$1(a, d) {
    return function (t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function (a, b) {
      return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
  }

  var interpolateRgb = (function rgbGamma(y) {
    var color = gamma(y);
    function rgb(start, end) {
      var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
      return function (t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + '';
      };
    }
    rgb.gamma = rgbGamma;
    return rgb;
  })(1);

  function interpolateNumber (a, b) {
    return a = +a, b = +b, function (t) {
      return a * (1 - t) + b * t;
    };
  }

  //  number  color
  var interpolate$1 = function interpolate(a, b) {
    if (isNumber(b)) {
      return interpolateNumber(a, b);
    }
    return interpolateRgb(a, b);
  };
  var Linear$1 = /*#__PURE__*/function (_Base) {
    _inherits(Linear$1, _Base);
    var _super = _createSuper(Linear$1);
    function Linear$1(options) {
      var _this;
      _classCallCheck(this, Linear$1);
      _this = _super.call(this, options);
      _this._updateInterpolate();
      return _this;
    }
    _createClass$2(Linear$1, [{
      key: "createScale",
      value: function createScale(scaleConfig) {
        return new Linear(scaleConfig);
      }
    }, {
      key: "_updateInterpolate",
      value: function _updateInterpolate() {
        var _this$range = _slicedToArray(this.range, 2),
          min = _this$range[0],
          max = _this$range[1];
        this.interpolate = interpolate$1(min, max);
      }
    }, {
      key: "update",
      value: function update(options) {
        _get(_getPrototypeOf(Linear$1.prototype), "update", this).call(this, options);
        this._updateInterpolate();
      }
    }, {
      key: "_mapping",
      value: function _mapping(value) {
        var scale = this.scale,
          interpolate = this.interpolate;
        if (isArray(value)) {
          return value.map(function (v) {
            return interpolate(scale.scale(v));
          });
        }
        return interpolate(scale.scale(value));
      }
    }, {
      key: "normalize",
      value: function normalize(value) {
        var scale = this.scale;
        if (isArray(value)) {
          return value.map(function (v) {
            return scale.scale(v);
          });
        }
        return scale.scale(value);
      }
    }, {
      key: "convert",
      value: function convert(value) {
        var range = this.range;
        var _range = _slicedToArray(range, 2),
          min = _range[0],
          max = _range[1];
        if (isArray(value)) {
          return value.map(function (v) {
            return min + (max - min) * v;
          });
        }
        return min + (max - min) * value;
      }
    }]);
    return Linear$1;
  }(Base$1);

  var Category$1 = /*#__PURE__*/function (_Base) {
    _inherits(Category$1, _Base);
    var _super = _createSuper(Category$1);
    function Category$1() {
      _classCallCheck(this, Category$1);
      return _super.apply(this, arguments);
    }
    _createClass$2(Category$1, [{
      key: "createScale",
      value: function createScale(scaleConfig) {
        return new Category(scaleConfig);
      }
    }, {
      key: "_mapping",
      value: function _mapping(value) {
        var scale = this.scale,
          range = this.range;
        if (scale.type === 'cat') {
          var _index = scale.translate(value);
          return range[_index % range.length];
        }
        var normalizeValue = scale.scale(value);
        var index = Math.round(normalizeValue * (range.length - 1));
        return range[index];
      }
    }]);
    return Category$1;
  }(Base$1);

  var Identity$1 = /*#__PURE__*/function (_Base) {
    _inherits(Identity$1, _Base);
    var _super = _createSuper(Identity$1);
    function Identity$1() {
      _classCallCheck(this, Identity$1);
      return _super.apply(this, arguments);
    }
    _createClass$2(Identity$1, [{
      key: "createScale",
      value: function createScale(scaleConfig) {
        return new Identity(scaleConfig);
      }
    }, {
      key: "_mapping",
      value: function _mapping() {
        var field = this.field,
          range = this.range;
        return field || range && range[0];
      }
    }]);
    return Identity$1;
  }(Base$1);

  var Attrs = /*#__PURE__*/Object.freeze({
      __proto__: null,
      Attr: Base$1,
      Linear: Linear$1,
      Category: Category$1,
      Identity: Identity$1
  });

  var Identity$2 = Identity$1,
    Linear$2 = Linear$1,
    Category$2 = Category$1;
  // 
  var ATTRS = ['x', 'y', 'color', 'size', 'shape'];
  // 
  var GROUP_ATTRS = ['color', 'size', 'shape'];
  function cloneScale(scale, scaleConfig) {
    // @ts-ignore
    return new scale.constructor(_objectSpread(_objectSpread({}, scale.__cfg__), scaleConfig));
  }
  var AttrController = /*#__PURE__*/function () {
    function AttrController(scaleController, attrsRange) {
      _classCallCheck(this, AttrController);
      this.scaleController = scaleController;
      this.attrsRange = attrsRange;
      this.options = {};
      this.attrs = {};
    }
    _createClass$2(AttrController, [{
      key: "parseOption",
      value: function parseOption(option, attrName) {
        if (!option) {
          return {
            type: 'identity'
          };
        }
        if (isString(option)) {
          return {
            field: option,
            type: 'category'
          };
        }
        if (isNumber(option)) {
          if (attrName === 'size') {
            return {
              type: 'identity',
              field: option
            };
          }
        }
        if (isArray(option)) {
          return {
            field: option[0],
            range: option[1]
          };
        }
        return option;
      }
    }, {
      key: "getAttrOptions",
      value: function getAttrOptions(props, justifyContentCenter) {
        var _this = this;
        if (!props.x || !props.y) {
          throw new Error('x, y are required !');
        }
        var options = {};
        var ranges = this.attrsRange;
        ATTRS.forEach(function (attrName) {
          if (!props[attrName]) return;
          var option = _this.parseOption(props[attrName], attrName);
          if (!option.range) {
            option.range = ranges[attrName];
          }
          options[attrName] = option;
        });
        // @ts-ignore
        var x = options.x,
          y = options.y;
        x.justifyContent = justifyContentCenter;
        // x, y Linear 
        x.type = Linear$2;
        y.type = Linear$2;
        return options;
      }
    }, {
      key: "getDefaultAttrValues",
      value: function getDefaultAttrValues() {
        var _this$attrsRange = this.attrsRange,
          color = _this$attrsRange.color,
          shape = _this$attrsRange.shape;
        return {
          color: color[0],
          shape: shape && shape[0]
        };
      }
    }, {
      key: "getGroupScales",
      value: function getGroupScales() {
        var attrs = this.attrs;
        var scales = [];
        each(GROUP_ATTRS, function (attrName) {
          var attr = attrs[attrName];
          if (!attr) {
            return;
          }
          var scale = attr.scale;
          if (scale && scale.isCategory && scales.indexOf(scale) === -1) {
            scales.push(scale);
          }
        });
        return scales;
      }
    }, {
      key: "createAttr",
      value: function createAttr(option) {
        var type = option.type,
          field = option.field,
          scaleConfig = option.scale;
        if (isNil(field) || type === Identity$2) {
          return new Identity$2(option);
        }
        var scale = this.scaleController.getScale(field);
        var attrOption = _objectSpread(_objectSpread({}, option), {}, {
          data: this.scaleController.getData(),
          // scaleConfig 
          scale: scaleConfig ? cloneScale(scale, scaleConfig) : scale
        });
        // identity
        if (scale && scale.type === 'identity') {
          return new Identity$2(attrOption);
        }
        // Attrscale
        var AttrConstructor = scale.isLinear ? Linear$2 : Category$2;
        // custom Attr Constructor
        if (isFunction(type)) {
          AttrConstructor = type;
        }
        if (isString(type) && Attrs[upperFirst(type)]) {
          AttrConstructor = Attrs[upperFirst(type)];
        }
        return new AttrConstructor(attrOption);
      }
    }, {
      key: "create",
      value: function create(options) {
        this.update(options);
      }
    }, {
      key: "update",
      value: function update(nextOptions) {
        var scaleController = this.scaleController,
          lastOptions = this.options,
          lastAttrs = this.attrs;
        var nextAttrs = {};
        each(nextOptions, function (nextOption, attrName) {
          var lastOption = lastOptions[attrName];
          if (equal(nextOption, lastOption)) {
            nextAttrs[attrName] = lastAttrs[attrName];
          }
          var field = nextOption.field,
            justifyContent = nextOption.justifyContent;
          if (field) {
            scaleController.setScale(field, {
              justifyContent: justifyContent
            });
          }
        });
        this.options = nextOptions;
        this.attrs = nextAttrs;
      }
    }, {
      key: "getAttr",
      value: function getAttr(attrName) {
        var attrs = this.attrs,
          options = this.options;
        var attr = attrs[attrName];
        if (attr) {
          return attr;
        }
        var option = options[attrName];
        if (!option) {
          return null;
        }
        var newAttr = this.createAttr(option);
        attrs[attrName] = newAttr;
        return newAttr;
      }
    }, {
      key: "getAttrs",
      value: function getAttrs() {
        var _this2 = this;
        var options = this.options,
          attrs = this.attrs;
        each(options, function (option, attrName) {
          _this2.getAttr(attrName);
        });
        return attrs;
      }
    }, {
      key: "isGroupAttr",
      value: function isGroupAttr(attrName) {
        return GROUP_ATTRS.indexOf(attrName) !== -1;
      }
    }, {
      key: "getAttrsByLinear",
      value: function getAttrsByLinear() {
        var attrs = this.attrs;
        var attrNames = Object.keys(attrs);
        var linearAttrs = [];
        var nonlinearAttrs = [];
        attrNames.forEach(function (attrName) {
          if (attrName === 'x' || attrName === 'y') {
            linearAttrs.push(attrName);
            return;
          }
          var scale = attrs[attrName].scale;
          if (scale && scale.type === 'linear') {
            linearAttrs.push(attrName);
          } else {
            nonlinearAttrs.push(attrName);
          }
        });
        return {
          linearAttrs: linearAttrs,
          nonlinearAttrs: nonlinearAttrs
        };
      }
    }]);
    return AttrController;
  }();

  var _excluded$1 = ["field"];
  var AdjustMap = {
    Stack: Stack,
    Dodge: Dodge,
    Jitter: Jitter,
    Symmetric: Symmetric
  };
  // 
  var FIELD_ORIGIN = 'origin';
  var Geometry = /*#__PURE__*/function (_Selection) {
    _inherits(Geometry, _Selection);
    var _super = _createSuper(Geometry);
    function Geometry(props, context) {
      var _this;
      _classCallCheck(this, Geometry);
      _this = _super.call(this, props, context);
      _this.isGeometry = true;
      // x 
      _this.justifyContent = false;
      // y 0
      _this.startOnZero = false;
      // 
      _this.connectNulls = false;
      // 
      _this.sortable = false;
      mix(_assertThisInitialized$2(_this), _this.getDefaultCfg());
      var chart = props.chart,
        coord = props.coord;
      var attrsRange = _this._getThemeAttrsRange();
      _this.attrController = new AttrController(chart.scale, attrsRange);
      var _assertThisInitialize = _assertThisInitialized$2(_this),
        attrController = _assertThisInitialize.attrController,
        justifyContent = _assertThisInitialize.justifyContent;
      var attrOptions = attrController.getAttrOptions(props, !coord.isCyclic() || justifyContent);
      attrController.create(attrOptions);
      return _this;
    }
    _createClass$2(Geometry, [{
      key: "getDefaultCfg",
      value: function getDefaultCfg() {
        return {};
      }
    }, {
      key: "willReceiveProps",
      value: function willReceiveProps(nextProps) {
        var lastProps = this.props,
          attrController = this.attrController,
          justifyContent = this.justifyContent;
        var nextData = nextProps.data,
          nextAdjust = nextProps.adjust,
          coord = nextProps.coord,
          selection = nextProps.selection;
        var lastData = lastProps.data,
          lastAdjust = lastProps.adjust,
          lastSelection = lastProps.selection;
        var justifyContentCenter = !coord.isCyclic() || justifyContent;
        var lastAttrOptions = attrController.getAttrOptions(lastProps, justifyContentCenter);
        attrController.attrsRange = this._getThemeAttrsRange();
        var nextAttrOptions = attrController.getAttrOptions(nextProps, justifyContentCenter);
        if (!equal(nextAttrOptions, lastAttrOptions)) {
          attrController.update(nextAttrOptions);
          this.dataRecords = null;
        }
        // 
        if (nextData !== lastData) {
          this.dataRecords = null;
        }
        // 
        if (nextAdjust !== lastAdjust) {
          this.dataRecords = null;
        }
        // selection 
        if (!equal(selection, lastSelection)) {
          _get(_getPrototypeOf(Geometry.prototype), "willReceiveProps", this).call(this, nextProps);
        }
      }
    }, {
      key: "willMount",
      value: function willMount() {
        this._createAttrs();
        if (!this.dataRecords) {
          this._processData();
        }
      }
    }, {
      key: "willUpdate",
      value: function willUpdate() {
        this._createAttrs();
        if (!this.dataRecords) {
          this._processData();
        }
      }
    }, {
      key: "didMount",
      value: function didMount() {
        _get(_getPrototypeOf(Geometry.prototype), "didMount", this).call(this);
        //  attrController
        this.attrController.attrsRange = this._getThemeAttrsRange();
      }
    }, {
      key: "_createAttrs",
      value: function _createAttrs() {
        var attrController = this.attrController;
        attrController.attrs = {};
        this.attrs = attrController.getAttrs();
      }
    }, {
      key: "_getThemeAttrsRange",
      value: function _getThemeAttrsRange() {
        var context = this.context,
          props = this.props,
          geomType = this.geomType;
        var coord = props.coord;
        var theme = context.theme;
        var colors = theme.colors,
          sizes = theme.sizes,
          shapes = theme.shapes;
        return {
          x: coord.x,
          y: coord.y,
          color: colors,
          size: sizes,
          shape: shapes[geomType]
        };
      }
    }, {
      key: "_adjustScales",
      value: function _adjustScales() {
        var attrs = this.attrs,
          props = this.props,
          defaultStartOnZero = this.startOnZero;
        var chart = props.chart,
          _props$startOnZero = props.startOnZero,
          startOnZero = _props$startOnZero === void 0 ? defaultStartOnZero : _props$startOnZero,
          coord = props.coord,
          adjust = props.adjust;
        var isPolar = coord.isPolar,
          transposed = coord.transposed;
        var y = attrs.y;
        var yField = y.field;
        //  0  y  scale
        if (startOnZero) {
          var _y = attrs.y;
          chart.scale.adjustStartZero(_y.scale);
        }
        // scalenice
        if (isPolar && transposed && (adjust === 'stack' || (adjust === null || adjust === void 0 ? void 0 : adjust.type) === 'stack')) {
          var _y2 = attrs.y;
          chart.scale.adjustPieScale(_y2.scale);
        }
        if (adjust === 'stack' || (adjust === null || adjust === void 0 ? void 0 : adjust.type) === 'stack') {
          this._updateStackRange(yField, y.scale, this.dataArray);
        }
      }
    }, {
      key: "_groupData",
      value: function _groupData(data) {
        var attrController = this.attrController;
        var groupScales = attrController.getGroupScales();
        if (!groupScales.length) {
          return [{
            children: data
          }];
        }
        var names = [];
        groupScales.forEach(function (scale) {
          var field = scale.field;
          names.push(field);
        });
        var groups = groupToMap(data, names);
        var records = [];
        for (var key in groups) {
          records.push({
            key: key.replace(/^_/, ''),
            children: groups[key]
          });
        }
        return records;
      }
    }, {
      key: "_saveOrigin",
      value: function _saveOrigin(originData) {
        var len = originData.length;
        var data = new Array(len);
        for (var i = 0; i < len; i++) {
          var record = originData[i];
          data[i] = _objectSpread(_objectSpread({}, record), {}, _defineProperty({}, FIELD_ORIGIN, record));
        }
        return data;
      }
    }, {
      key: "_numberic",
      value: function _numberic(data) {
        var attrs = this.attrs;
        var scales = [attrs.x.scale, attrs.y.scale];
        for (var j = 0, len = data.length; j < len; j++) {
          var obj = data[j];
          var count = scales.length;
          for (var i = 0; i < count; i++) {
            var scale = scales[i];
            if (scale.isCategory) {
              var field = scale.field;
              obj[field] = scale.translate(obj[field]);
            }
          }
        }
      }
    }, {
      key: "_adjustData",
      value: function _adjustData(records) {
        var attrs = this.attrs,
          props = this.props;
        var adjust = props.adjust;
        // groupedArray 
        var groupedArray = records.map(function (record) {
          return record.children;
        });
        if (!adjust) {
          return groupedArray;
        }
        var adjustCfg = typeof adjust === 'string' ? {
          type: adjust
        } : adjust;
        var adjustType = upperFirst(adjustCfg.type);
        var AdjustConstructor = AdjustMap[adjustType];
        if (!AdjustConstructor) {
          throw new Error('not support such adjust : ' + adjust);
        }
        if (adjustType === 'Dodge') {
          for (var i = 0, len = groupedArray.length; i < len; i++) {
            // dodge, 
            this._numberic(groupedArray[i]);
          }
          // @ts-ignore
          adjustCfg.adjustNames = ['x'];
        }
        var x = attrs.x,
          y = attrs.y;
        // @ts-ignore
        adjustCfg.xField = x.field;
        // @ts-ignore
        adjustCfg.yField = y.field;
        var adjustInstance = new AdjustConstructor(adjustCfg);
        var adjustData = adjustInstance.process(groupedArray);
        this.adjust = {
          type: adjustCfg.type,
          adjust: adjustInstance
        };
        // process  records
        records.forEach(function (record, index) {
          record.children = adjustData[index];
        });
        return adjustData;
      }
    }, {
      key: "_updateStackRange",
      value: function _updateStackRange(field, scale, dataArray) {
        var flattenArray = flatten(dataArray);
        var min = Infinity;
        var max = -Infinity;
        for (var i = 0, len = flattenArray.length; i < len; i++) {
          var obj = flattenArray[i];
          var tmpMin = Math.min.apply(null, obj[field]);
          var tmpMax = Math.max.apply(null, obj[field]);
          if (tmpMin < min) {
            min = tmpMin;
          }
          if (tmpMax > max) {
            max = tmpMax;
          }
        }
        if (min !== scale.min || max !== scale.max) {
          scale.change({
            min: min,
            max: max
          });
        }
      }
    }, {
      key: "_processData",
      value: function _processData() {
        var props = this.props;
        var originData = props.data;
        var data = this._saveOrigin(originData);
        // 
        var records = this._groupData(data);
        // adjust
        var dataArray = this._adjustData(records);
        this.dataArray = dataArray;
        // scale y  0   
        this._adjustScales();
        // 
        if (this.sortable) {
          this._sortData(records);
        }
        this.dataRecords = records;
      }
    }, {
      key: "_sortData",
      value: function _sortData(records) {
        var xScale = this.getXScale();
        var field = xScale.field,
          type = xScale.type;
        if (type !== 'identity' && xScale.values.length > 1) {
          each(records, function (_ref) {
            var children = _ref.children;
            children.sort(function (record1, record2) {
              if (type === 'timeCat') {
                return toTimeStamp$1(record1[FIELD_ORIGIN][field]) - toTimeStamp$1(record2[FIELD_ORIGIN][field]);
              }
              return xScale.translate(record1[FIELD_ORIGIN][field]) - xScale.translate(record2[FIELD_ORIGIN][field]);
            });
          });
        }
      }
    }, {
      key: "getY0Value",
      value: function getY0Value() {
        var attrs = this.attrs,
          props = this.props;
        var chart = props.chart;
        var field = attrs.y.field;
        var scale = chart.getScale(field);
        return chart.scale.getZeroValue(scale);
      }
      // 
    }, {
      key: "_getShapeStyle",
      value: function _getShapeStyle(shape, origin) {
        var context = this.context,
          props = this.props,
          geomType = this.geomType;
        var theme = context.theme;
        var shapeTheme = theme.shape[geomType] || {};
        var defaultShapeStyle = shapeTheme.default;
        var shapeThemeStyle = shapeTheme[shape];
        var style = props.style;
        var shapeStyle = _objectSpread(_objectSpread({}, defaultShapeStyle), shapeThemeStyle);
        if (!style || !isObject(style)) {
          return shapeStyle;
        }
        // @ts-ignore
        var field = style.field,
          styles = _objectWithoutProperties(style, _excluded$1);
        var value = field ? origin[field] : origin;
        each(styles, function (attr, key) {
          if (isFunction(attr)) {
            shapeStyle[key] = attr(value);
          } else {
            shapeStyle[key] = attr;
          }
        });
        return shapeStyle;
      }
      /**
       * 
       * xy  normalize  convertPoint
       * colorsizeshape
       *  Linear  mapping
       *  Category/Identity  mapping
       */
    }, {
      key: "_mapping",
      value: function _mapping(records) {
        var attrs = this.attrs,
          props = this.props,
          attrController = this.attrController;
        var coord = props.coord;
        var _attrController$getAt = attrController.getAttrsByLinear(),
          linearAttrs = _attrController$getAt.linearAttrs,
          nonlinearAttrs = _attrController$getAt.nonlinearAttrs;
        var defaultAttrValues = attrController.getDefaultAttrValues();
        var mappedRecords = [];
        for (var i = 0, len = records.length; i < len; i++) {
          var record = records[i];
          var children = record.children;
          var attrValues = _objectSpread({}, defaultAttrValues);
          var firstChild = children[0];
          if (children.length === 0) {
            mappedRecords.push(_objectSpread({}, record));
            continue;
          }
          // 
          for (var k = 0, _len = nonlinearAttrs.length; k < _len; k++) {
            var attrName = nonlinearAttrs[k];
            var attr = attrs[attrName];
            // 
            attrValues[attrName] = attr.mapping(firstChild[attr.field]);
          }
          // 
          var mappedChildren = [];
          for (var j = 0, childrenLen = children.length; j < childrenLen; j++) {
            var child = children[j];
            var normalized = {};
            for (var _k = 0; _k < linearAttrs.length; _k++) {
              var _attrName = linearAttrs[_k];
              var _attr = attrs[_attrName];
              // 
              if (attrController.isGroupAttr(_attrName)) {
                attrValues[_attrName] = _attr.mapping(child[_attr.field], child);
              } else {
                normalized[_attrName] = _attr.normalize(child[_attr.field]);
              }
            }
            var _coord$convertPoint = coord.convertPoint({
                x: normalized.x,
                y: normalized.y
              }),
              x = _coord$convertPoint.x,
              y = _coord$convertPoint.y;
            //  shape  style
            var origin = child.origin;
            var shapeName = attrValues.shape;
            var shape = this._getShapeStyle(shapeName, origin);
            var selected = this.isSelected(child);
            mappedChildren.push(_objectSpread(_objectSpread(_objectSpread({}, child), attrValues), {}, {
              normalized: normalized,
              x: x,
              y: y,
              shapeName: shapeName,
              shape: shape,
              selected: selected
            }));
          }
          mappedRecords.push(_objectSpread(_objectSpread({}, record), {}, {
            children: mappedChildren
          }));
        }
        return mappedRecords;
      }
      // 
    }, {
      key: "mapping",
      value: function mapping() {
        var dataRecords = this.dataRecords;
        // 
        this.records = this._mapping(dataRecords);
        return this.records;
      }
    }, {
      key: "getClip",
      value: function getClip() {
        var _this$props = this.props,
          coord = _this$props.coord,
          viewClip = _this$props.viewClip;
        var contentWidth = coord.width,
          contentHeight = coord.height,
          left = coord.left,
          top = coord.top;
        if (viewClip) {
          return {
            type: 'rect',
            style: {
              x: left,
              y: top,
              width: contentWidth,
              height: contentHeight
            }
          };
        }
        return null;
      }
    }, {
      key: "getAttr",
      value: function getAttr(attrName) {
        return this.attrController.getAttr(attrName);
      }
    }, {
      key: "getXScale",
      value: function getXScale() {
        return this.getAttr('x').scale;
      }
    }, {
      key: "getYScale",
      value: function getYScale() {
        return this.getAttr('y').scale;
      }
    }, {
      key: "_getXSnap",
      value: function _getXSnap(invertPointX) {
        var xScale = this.getXScale();
        if (xScale.isCategory) {
          return xScale.invert(invertPointX);
        }
        // linear 
        var invertValue = xScale.invert(invertPointX);
        var values = xScale.values;
        var len = values.length;
        // 11
        if (len === 1) {
          return values[0];
        }
        // 12
        if ((values[0] + values[1]) / 2 > invertValue) {
          return values[0];
        }
        // 2
        if ((values[len - 2] + values[len - 1]) / 2 <= invertValue) {
          return values[len - 1];
        }
        for (var i = 1; i < len; i++) {
          // 
          if ((values[i - 1] + values[i]) / 2 <= invertValue && (values[i + 1] + values[i]) / 2 > invertValue) {
            return values[i];
          }
        }
        return null;
      }
    }, {
      key: "_getYSnapRecords",
      value: function _getYSnapRecords(invertPointY, records) {
        var yScale = this.getYScale();
        var yField = yScale.field;
        var yValue = yScale.invert(invertPointY);
        // category
        if (yScale.isCategory) {
          return records.filter(function (record) {
            return record[FIELD_ORIGIN][yField] === yValue;
          });
        }
        // linear
        return records.filter(function (record) {
          var rangeY = record[yField];
          if (rangeY[0] <= yValue && rangeY[1] >= yValue) {
            return true;
          }
          return false;
        });
      }
      //  records 
    }, {
      key: "flatRecords",
      value: function flatRecords() {
        var records = this.records;
        return records.reduce(function (prevRecords, record) {
          return prevRecords.concat(record.children);
        }, []);
      }
    }, {
      key: "getSnapRecords",
      value: function getSnapRecords(point, inCoordRange) {
        var props = this.props;
        var coord = props.coord,
          adjust = props.adjust;
        var invertPoint = coord.invertPoint(point);
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        // coord
        // if (invertPoint.x < 0 || invertPoint.y < 0) {
        //   return [];
        // }
        //  point
        if (inCoordRange) {
          var xRange = xScale.range;
          var yRange = yScale.range;
          //  inCoordRange=true point  coord  range 
          invertPoint.x = Math.min(Math.max(invertPoint.x, xRange[0]), xRange[1]);
          invertPoint.y = Math.min(Math.max(invertPoint.y, yRange[0]), yRange[1]);
        }
        var records = this.flatRecords();
        // 
        if (adjust === 'stack' && coord.isPolar && coord.transposed) {
          // 
          if (invertPoint.x >= 0 && invertPoint.x <= 1) {
            var snapRecords = this._getYSnapRecords(invertPoint.y, records);
            return snapRecords;
          }
        }
        var rst = [];
        var value = this._getXSnap(invertPoint.x);
        if (isNull(value)) {
          return rst;
        }
        var xField = xScale.field;
        var yField = yScale.field;
        for (var i = 0, len = records.length; i < len; i++) {
          var record = _objectSpread(_objectSpread({}, records[i]), {}, {
            xField: xField,
            yField: yField
          });
          var originValue = record[FIELD_ORIGIN][xField];
          if (xScale.type === 'timeCat' && toTimeStamp$1(originValue) === value) {
            rst.push(record);
          } else if (originValue === value) {
            rst.push(record);
          }
        }
        return rst;
      }
    }, {
      key: "getRecords",
      value: function getRecords(data) {
        var field = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'xfield';
        var records = this.flatRecords();
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale.field;
        var yField = yScale.field;
        var value = data[xField];
        var rst = [];
        for (var i = 0, len = records.length; i < len; i++) {
          var record = _objectSpread(_objectSpread({}, records[i]), {}, {
            xField: xField,
            yField: yField
          });
          var originValue = record[FIELD_ORIGIN][field === 'xfield' ? xField : yField];
          if (originValue === value) {
            rst.push(record);
          }
        }
        return rst;
      }
    }, {
      key: "getLegendItems",
      value: function getLegendItems() {
        var attrController = this.attrController;
        var colorAttr = attrController.getAttr('color');
        if (!colorAttr) return null;
        var scale = colorAttr.scale;
        if (!scale.isCategory) return null;
        var ticks = scale.getTicks();
        var items = ticks.map(function (tick) {
          var text = tick.text,
            tickValue = tick.tickValue;
          var color = colorAttr.mapping(tickValue);
          return {
            field: scale.field,
            color: color,
            name: text,
            tickValue: tickValue
          };
        });
        return items;
      }
    }]);
    return Geometry;
  }(Selection);

  var withLine = (function (View) {
    return /*#__PURE__*/function (_Geometry) {
      _inherits(Line, _Geometry);
      var _super = _createSuper(Line);
      function Line() {
        _classCallCheck(this, Line);
        return _super.apply(this, arguments);
      }
      _createClass$2(Line, [{
        key: "getDefaultCfg",
        value: function getDefaultCfg() {
          return {
            geomType: 'line',
            sortable: true
          };
        }
      }, {
        key: "splitPoints",
        value: function splitPoints(points) {
          var topPoints = [];
          var bottomPoints = [];
          for (var i = 0, len = points.length; i < len; i++) {
            var point = points[i];
            var x = point.x,
              y = point.y;
            topPoints.push(_objectSpread(_objectSpread({}, point), {}, {
              x: x,
              y: y[1]
            }));
            bottomPoints.push(_objectSpread(_objectSpread({}, point), {}, {
              x: x,
              y: y[0]
            }));
          }
          return [topPoints, bottomPoints];
        }
      }, {
        key: "splitNulls",
        value: function splitNulls(points, connectNulls) {
          if (connectNulls) {
            var _tmpPoints = [];
            for (var i = 0, len = points.length; i < len; i++) {
              var point = points[i];
              var y = point.y;
              if (isArray(y)) {
                if (isNaN(y[0])) {
                  continue;
                }
                _tmpPoints.push(point);
                continue;
              }
              if (isNaN(y)) {
                continue;
              }
              _tmpPoints.push(point);
            }
            if (_tmpPoints.length) {
              return [_tmpPoints];
            }
            return [];
          }
          var result = [];
          var tmpPoints = [];
          for (var _i = 0, _len = points.length; _i < _len; _i++) {
            var _point = points[_i];
            var _y = _point.y;
            if (isArray(_y)) {
              if (isNaN(_y[0])) {
                if (tmpPoints.length) {
                  result.push(tmpPoints);
                  tmpPoints = [];
                }
                continue;
              }
              tmpPoints.push(_point);
              continue;
            }
            if (isNaN(_y)) {
              if (tmpPoints.length) {
                result.push(tmpPoints);
                tmpPoints = [];
              }
              continue;
            }
            tmpPoints.push(_point);
          }
          if (tmpPoints.length) {
            result.push(tmpPoints);
          }
          return result;
        }
      }, {
        key: "mapping",
        value: function mapping() {
          var _this = this;
          var records = _get(_getPrototypeOf(Line.prototype), "mapping", this).call(this);
          var props = this.props,
            defaultConnectNulls = this.connectNulls;
          var coord = props.coord,
            _props$connectNulls = props.connectNulls,
            connectNulls = _props$connectNulls === void 0 ? defaultConnectNulls : _props$connectNulls;
          return records.map(function (record) {
            var children = record.children;
            // children 
            var _ref = children[0] || {},
              size = _ref.size,
              color = _ref.color,
              shape = _ref.shape,
              y = _ref.y;
            // 
            var points = coord.isPolar ? [].concat(_toConsumableArray(children), [children[0]]) : children;
            var splitPoints = _this.splitNulls(points, connectNulls);
            var newChildren = splitPoints.map(function (points) {
              var _ref2 = isArray(y) ? _this.splitPoints(points) : [points, undefined],
                _ref3 = _slicedToArray(_ref2, 2),
                topPoints = _ref3[0],
                bottomPoints = _ref3[1];
              return {
                size: size,
                color: color,
                shape: shape,
                points: topPoints,
                bottomPoints: bottomPoints
              };
            });
            return _objectSpread(_objectSpread({}, record), {}, {
              children: newChildren
            });
          });
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props;
          var coord = props.coord;
          var records = this.mapping();
          var clip = this.getClip();
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            coord: coord,
            records: records,
            clip: clip
          }));
        }
      }]);
      return Line;
    }(Geometry);
  });

  function concatPoints(children) {
    var result = [];
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      result = result.concat(child.points);
    }
    return result;
  }
  var LineView = (function (props) {
    var records = props.records,
      coord = props.coord,
      animation = props.animation,
      EndView = props.endView,
      clip = props.clip;
    var left = coord.left,
      top = coord.top,
      width = coord.width,
      height = coord.height,
      center = coord.center,
      startAngle = coord.startAngle,
      endAngle = coord.endAngle,
      radius = coord.radius;
    var appear = coord.isPolar ? {
      easing: 'quadraticOut',
      duration: 450,
      clip: {
        type: 'sector',
        property: ['endAngle'],
        style: {
          cx: center.x,
          cy: center.y,
          startAngle: "".concat(startAngle, "rad"),
          r: radius
        },
        start: {
          endAngle: "".concat(startAngle, "rad")
        },
        end: {
          endAngle: "".concat(endAngle, "rad")
        }
      }
    } : {
      easing: 'quadraticOut',
      duration: 450,
      clip: {
        type: 'rect',
        property: ['width'],
        style: {
          x: left,
          y: top,
          height: height
        },
        start: {
          width: 0
        },
        end: {
          width: width
        }
      }
    };
    return jsx("group", {
      attrs: {
        clip: clip
      }
    }, records.map(function (record) {
      var _points$;
      var key = record.key,
        children = record.children;
      var points = concatPoints(children);
      var ref = createRef();
      return jsx("group", {
        key: key
      }, children.map(function (child) {
        var points = child.points,
          color = child.color,
          size = child.size,
          shape = child.shape;
        var fliterPoints = points.filter(function (point) {
          return !isNaN(point.x) && !isNaN(point.y);
        });
        if (fliterPoints.length === 0) return;
        return jsx("polyline", {
          key: key,
          ref: ref,
          style: _objectSpread(_objectSpread({
            points: fliterPoints.map(function (point) {
              return [point.x, point.y];
            }),
            stroke: color
          }, shape), {}, {
            lineWidth: size || shape.lineWidth
          }),
          animation: deepMix({
            update: {
              easing: 'linear',
              duration: 450,
              property: ['points']
            },
            appear: appear
          }, animation)
        });
      }), EndView ? jsx("group", {
        style: {
          offset: ref
        },
        animation: deepMix({
          appear: {
            easing: 'quadraticOut',
            duration: 450,
            property: ['offsetDistance'],
            start: {
              offsetDistance: 0
            },
            end: {
              offsetDistance: 1
            }
          }
        }, animation)
      }, jsx(EndView, {
        origin: (_points$ = points[0]) === null || _points$ === void 0 ? void 0 : _points$.origin
      })) : null);
    }));
  });

  var index = withLine(LineView);

  var withArea = (function (View) {
    return /*#__PURE__*/function (_withLine) {
      _inherits(Area, _withLine);
      var _super = _createSuper(Area);
      function Area() {
        _classCallCheck(this, Area);
        return _super.apply(this, arguments);
      }
      _createClass$2(Area, [{
        key: "getDefaultCfg",
        value: function getDefaultCfg() {
          return {
            geomType: 'area',
            // 0
            startOnZero: true,
            // 
            sortable: true
          };
        }
      }, {
        key: "mapping",
        value: function mapping() {
          var records = _get(_getPrototypeOf(Area.prototype), "mapping", this).call(this);
          //  y0
          var y0 = this.getY0Value();
          var props = this.props,
            defaultStartOnZero = this.startOnZero;
          var coord = props.coord,
            _props$startOnZero = props.startOnZero,
            startOnZero = _props$startOnZero === void 0 ? defaultStartOnZero : _props$startOnZero;
          var baseY = coord.y[0];
          if (startOnZero) {
            // 
            var originCoord = coord.convertPoint({
              x: 0,
              y: y0
            });
            baseY = originCoord.y;
          }
          for (var i = 0, len = records.length; i < len; i++) {
            var record = records[i];
            var children = record.children;
            for (var j = 0, _len = children.length; j < _len; j++) {
              var child = children[j];
              var points = child.points,
                bottomPoints = child.bottomPoints;
              if (bottomPoints && bottomPoints.length) {
                bottomPoints.reverse();
                child.points = points.concat(bottomPoints);
              } else {
                points.push({
                  x: points[points.length - 1].x,
                  y: baseY
                });
                points.push({
                  x: points[0].x,
                  y: baseY
                });
              }
            }
          }
          return records;
        }
      }]);
      return Area;
    }(withLine(View));
  });

  var AreaView = (function (props) {
    var coord = props.coord,
      records = props.records,
      shape = props.shape,
      animation = props.animation;
    var isSmooth = shape === 'smooth';
    var left = coord.left,
      top = coord.top,
      width = coord.width,
      height = coord.height,
      center = coord.center,
      startAngle = coord.startAngle,
      endAngle = coord.endAngle,
      radius = coord.radius;
    var appear = coord.isPolar ? {
      easing: 'quadraticOut',
      duration: 450,
      clip: {
        type: 'sector',
        property: ['endAngle'],
        style: {
          cx: center.x,
          cy: center.y,
          startAngle: "".concat(startAngle, "rad"),
          r: radius
        },
        start: {
          endAngle: "".concat(startAngle, "rad")
        },
        end: {
          endAngle: "".concat(endAngle, "rad")
        }
      }
    } : {
      easing: 'quadraticOut',
      duration: 450,
      clip: {
        type: 'rect',
        property: ['width'],
        style: {
          x: left,
          y: top,
          height: height
        },
        start: {
          width: 0
        },
        end: {
          width: width
        }
      }
    };
    return jsx("group", null, records.map(function (record) {
      var key = record.key,
        children = record.children;
      return jsx("group", {
        key: key
      }, children.map(function (child) {
        var points = child.points,
          bottomPoints = child.bottomPoints,
          color = child.color,
          shape = child.shape;
        if (isSmooth) {
          var generatePath = function generatePath() {
            var d = [];
            var constaint = [[0, 0], [1, 1]];
            var bottomPointsLen = (bottomPoints === null || bottomPoints === void 0 ? void 0 : bottomPoints.length) || 0;
            var topPoints = points.slice(0, points.length - bottomPointsLen);
            var topSps = catmullRom2bezier(topPoints, false, constaint);
            d.push(['M', topPoints[0].x, topPoints[0].y]);
            for (var i = 0, n = topSps.length; i < n; i++) {
              var sp = topSps[i];
              d.push(['C', sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);
            }
            if (bottomPointsLen) {
              var bottomSps = catmullRom2bezier(bottomPoints, false, constaint);
              d.push(['L', bottomPoints[0].x, bottomPoints[0].y]);
              for (var _i = 0, _n = bottomSps.length; _i < _n; _i++) {
                var _sp = bottomSps[_i];
                d.push(['C', _sp[1], _sp[2], _sp[3], _sp[4], _sp[5], _sp[6]]);
              }
            }
            return d;
          };
          return jsx("path", {
            style: _objectSpread({
              path: generatePath(),
              lineWidth: '2px',
              fill: color
            }, shape)
          });
        }
        return jsx("polygon", {
          attrs: _objectSpread({
            points: points.map(function (point) {
              return [point.x, point.y];
            }),
            lineWidth: '2px',
            fill: color
          }, shape),
          animation: deepMix({
            appear: appear,
            update: {
              easing: 'linear',
              duration: 450,
              property: ['points']
            }
          }, animation)
        });
      }));
    }));
  });

  var index$1 = withArea(AreaView);

  /**
   * 
   * @param start {x:number, y:number}
   * @param end {x:number, y:number}
   * @returns {x:number, y:number}
   */
  function getMiddlePoint(start, end) {
    var x = (end.x - start.x) / 2 + start.x;
    var y = (end.y - start.y) / 2 + start.y;
    return {
      x: x,
      y: y
    };
  }

  var DEFAULT_LABEL_CFG = {
    textBaseline: 'middle',
    fill: '#808080'
  };
  function LabelView(props) {
    var record = props.record,
      offsetX = props.offsetX,
      offsetY = props.offsetY,
      points = props.points,
      label = props.label,
      guide = props.guide;
    var origin = record.origin,
      color = record.color;
    var labelAttrs, guideAttrs;
    if (isFunction(label)) {
      var point = points.length === 4 //  3 
      ? getMiddlePoint(points[1], points[2]) : getMiddlePoint(points[0], points[1]);
      labelAttrs = mix({
        x: point.x + offsetX,
        y: point.y + offsetY
      }, DEFAULT_LABEL_CFG, label(origin, color));
    }
    if (isFunction(guide)) {
      var _points$;
      var _point = getMiddlePoint(points.length === 4 ? getMiddlePoint(points[0], points[1]) : points[0], getMiddlePoint(points[2], (_points$ = points[3]) !== null && _points$ !== void 0 ? _points$ : points[1]));
      guideAttrs = mix({
        x: _point.x,
        y: _point.y,
        textBaseline: 'middle',
        textAlign: 'center'
      }, DEFAULT_LABEL_CFG, guide(origin, color));
    }
    return jsx("group", null, labelAttrs && jsx("text", {
      attrs: labelAttrs
    }), guideAttrs && jsx("text", {
      attrs: guideAttrs
    }));
  }

  var LabelViews = /*#__PURE__*/Object.freeze({
      __proto__: null,
      pyramid: LabelView,
      funnel: LabelView
  });

  var withInterval = (function (Views) {
    return /*#__PURE__*/function (_Geometry) {
      _inherits(Interval, _Geometry);
      var _super = _createSuper(Interval);
      function Interval() {
        _classCallCheck(this, Interval);
        return _super.apply(this, arguments);
      }
      _createClass$2(Interval, [{
        key: "getDefaultCfg",
        value: function getDefaultCfg() {
          return {
            geomType: 'interval',
            justifyContent: true,
            startOnZero: true
          };
        }
      }, {
        key: "getDefaultSize",
        value: function getDefaultSize() {
          var attrs = this.attrs,
            props = this.props,
            adjust = this.adjust,
            records = this.records;
          var coord = props.coord,
            sizeRatio = props.sizeRatio;
          var x = attrs.x;
          var scale = x.scale;
          var values = scale.values;
          if (sizeRatio) {
            return 1 / values.length * sizeRatio;
          }
          var defaultWithRatio = {
            column: 1 / 2,
            rose: 0.999999,
            multiplePie: 3 / 4 // 
          };

          var count = values.length;
          var ratio;
          if (coord.isPolar) {
            if (coord.transposed && count > 1) {
              ratio = defaultWithRatio.multiplePie;
            } else {
              ratio = defaultWithRatio.rose;
            }
          } else {
            ratio = defaultWithRatio.column;
          }
          var size = 1 / values.length * ratio;
          // size
          if (adjust && adjust.type === 'dodge') {
            return size / records.length;
          }
          return size;
        }
      }, {
        key: "mapping",
        value: function mapping() {
          var records = _get(_getPrototypeOf(Interval.prototype), "mapping", this).call(this);
          var props = this.props;
          var coord = props.coord;
          var y0 = this.getY0Value();
          var defaultSize = this.getDefaultSize();
          for (var i = 0, len = records.length; i < len; i++) {
            var record = records[i];
            var children = record.children;
            for (var j = 0, _len = children.length; j < _len; j++) {
              var child = children[j];
              var normalized = child.normalized,
                mappedSize = child.size;
              // sizesize
              if (isNil(mappedSize)) {
                var x = normalized.x,
                  y = normalized.y,
                  _normalized$size = normalized.size,
                  size = _normalized$size === void 0 ? defaultSize : _normalized$size;
                mix(child, coord.convertRect({
                  x: x,
                  y: y,
                  y0: y0,
                  size: size
                }));
              } else {
                var _x = child.x,
                  _y = child.y;
                var rect = {
                  size: mappedSize,
                  x: _x,
                  y: _y,
                  y0: y0
                };
                mix(child, coord.transformToRect(rect));
              }
              mix(child.shape, this.getSelectionStyle(child));
            }
          }
          return records;
        }
        // Y
      }, {
        key: "getPointY0",
        value: function getPointY0() {
          var props = this.props;
          var coord = props.coord;
          var y0 = this.getY0Value();
          var y0Point = coord.convertPoint({
            y: y0,
            x: 0
          });
          return y0Point === null || y0Point === void 0 ? void 0 : y0Point.y;
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            state = this.state;
          var coord = props.coord,
            _props$shape = props.shape,
            shape = _props$shape === void 0 ? 'rect' : _props$shape,
            animation = props.animation,
            showLabel = props.showLabel,
            customLabelCfg = props.labelCfg;
          var View = isFunction(Views) ? Views : Views[shape];
          var LabelView = LabelViews[shape];
          var labelCfg = deepMix({
            label: null,
            offsetX: 0,
            offsetY: 0
          }, customLabelCfg);
          if (!View) return null;
          var selected = state.selected;
          var records = this.mapping();
          var pointY0 = this.getPointY0();
          var clip = this.getClip();
          return jsx(View, {
            coord: coord,
            records: records,
            selected: selected,
            shape: shape,
            animation: animation,
            showLabel: showLabel,
            labelCfg: labelCfg,
            LabelView: LabelView,
            y0: pointY0,
            clip: clip
          });
        }
      }]);
      return Interval;
    }(Geometry);
  });

  var Rect$2 = (function (props) {
    var records = props.records,
      animation = props.animation,
      y0 = props.y0,
      clip = props.clip,
      onClick = props.onClick;
    return jsx("group", {
      attrs: {
        clip: clip
      }
    }, records.map(function (record) {
      var key = record.key,
        children = record.children;
      return jsx("group", {
        key: key
      }, children.map(function (item) {
        var key = item.key,
          xMin = item.xMin,
          xMax = item.xMax,
          yMin = item.yMin,
          yMax = item.yMax,
          color = item.color,
          shape = item.shape;
        if (isNaN(xMin) || isNaN(xMax) || isNaN(yMin) || isNaN(yMax)) {
          return null;
        }
        return jsx("rect", {
          key: key,
          attrs: _objectSpread({
            x: xMin,
            y: yMin,
            width: xMax - xMin,
            height: yMax - yMin,
            fill: color
          }, shape),
          onClick: onClick,
          animation: deepMix({
            appear: {
              easing: 'linear',
              duration: 450,
              property: ['y', 'height'],
              start: {
                y: y0,
                height: 0
              }
            },
            update: {
              easing: 'linear',
              duration: 450,
              property: ['x', 'y', 'width', 'height']
            }
          }, animation)
        });
      }));
    }));
  });

  var Polar$1 = (function (props) {
    var coord = props.coord,
      records = props.records,
      animation = props.animation,
      onClick = props.onClick;
    var center = coord.center,
      startAngle = coord.startAngle,
      endAngle = coord.endAngle,
      radius = coord.radius;
    return jsx("group", {
      animation: {
        appear: _objectSpread({
          easing: 'quadraticOut',
          duration: 450,
          clip: {
            type: 'sector',
            property: ['endAngle'],
            style: {
              cx: center.x,
              cy: center.y,
              startAngle: "".concat(startAngle, "rad"),
              r: radius
            },
            start: {
              endAngle: "".concat(startAngle, "rad")
            },
            end: {
              endAngle: "".concat(endAngle, "rad")
            }
          }
        }, animation && animation.appear)
      }
    }, records.map(function (record) {
      var key = record.key,
        children = record.children;
      return jsx("group", {
        key: key
      }, children.map(function (item) {
        var key = item.key,
          xMin = item.xMin,
          xMax = item.xMax,
          yMin = item.yMin,
          yMax = item.yMax,
          color = item.color,
          shape = item.shape;
        return jsx("sector", {
          key: key,
          attrs: _objectSpread({
            cx: center.x,
            cy: center.y,
            fill: color,
            lineWidth: 1,
            startAngle: "".concat(xMin, "rad"),
            endAngle: "".concat(xMax, "rad"),
            r0: yMin,
            r: yMax
          }, shape),
          onClick: onClick,
          animation: deepMix({
            update: {
              easing: 'linear',
              duration: 450,
              property: ['x', 'y', 'startAngle', 'endAngle', 'r0', 'r']
            }
          }, animation)
        });
      }));
    }));
  });

  var intervalView = (function (props) {
    var coord = props.coord;
    var coordType = coord.type;
    // 
    if (coordType === 'rect') {
      return jsx(Rect$2, _objectSpread({}, props));
    }
    // 
    return jsx(Polar$1, _objectSpread({}, props));
  });

  function convertToPoints(_ref) {
    var xMin = _ref.xMin,
      xMax = _ref.xMax,
      yMin = _ref.yMin,
      yMax = _ref.yMax;
    return [{
      x: xMin,
      y: yMin
    }, {
      x: xMax,
      y: yMin
    }, {
      x: xMax,
      y: yMax
    }, {
      x: xMin,
      y: yMax
    } // bl
    ];
  }

  // View
  var polygonView = (function (props) {
    var records = props.records,
      shape = props.shape,
      showLabel = props.showLabel,
      labelCfg = props.labelCfg,
      LabelView = props.LabelView;
    // 
    var overturn = false;
    return jsx("group", null, records.map(function (record, index) {
      var key = record.key,
        children = record.children;
      var isLastRecord = index === records.length - 1;
      var nextRecord = isLastRecord ? record : records[index + 1];
      var nextChildren = nextRecord.children;
      var nextFirstPoint = convertToPoints(nextChildren[0]);
      var nextLastPoints = convertToPoints(nextChildren[nextChildren.length - 1]);
      if (!overturn) {
        overturn = nextChildren[0].yMax > children[0].yMax;
      }
      if (overturn) {
        nextFirstPoint.reverse();
        nextLastPoints.reverse();
      }
      var polygonPoints = children.map(function (child, childIndex) {
        var points = convertToPoints(child);
        if (overturn) {
          points.reverse();
        }
        if (isLastRecord) {
          if (shape === 'pyramid') {
            points = [getMiddlePoint(points[0], points[1]), points[2], points[3]];
          }
        } else {
          if (childIndex === 0) {
            points[0] = nextFirstPoint[3];
          }
          if (childIndex === children.length - 1) {
            points[1] = nextLastPoints[2];
          }
        }
        return _objectSpread(_objectSpread({}, child), {}, {
          points: points
        });
      });
      return jsx("group", {
        key: key
      }, polygonPoints.map(function (child) {
        var points = child.points,
          color = child.color,
          shape = child.shape;
        return jsx("group", null, jsx("polygon", {
          attrs: _objectSpread({
            points: points.map(function (d) {
              return [d.x, d.y];
            }),
            fill: color
          }, shape)
        }), showLabel && LabelView ? jsx(LabelView, _objectSpread({
          record: child,
          points: points
        }, labelCfg)) : null);
      }));
    }));
  });

  // /

  var Views = /*#__PURE__*/Object.freeze({
      __proto__: null,
      rect: intervalView,
      pyramid: polygonView,
      funnel: polygonView
  });

  var index$2 = withInterval(Views);

  var withPoint = (function (View) {
    return /*#__PURE__*/function (_Geometry) {
      _inherits(Point, _Geometry);
      var _super = _createSuper(Point);
      function Point() {
        _classCallCheck(this, Point);
        return _super.apply(this, arguments);
      }
      _createClass$2(Point, [{
        key: "getDefaultCfg",
        value: function getDefaultCfg() {
          return {
            geomType: 'point'
          };
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props;
          var coord = props.coord;
          var records = this.mapping();
          var clip = this.getClip();
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            coord: coord,
            records: records,
            clip: clip
          }));
        }
      }]);
      return Point;
    }(Geometry);
  });

  var PointView = (function (props) {
    var records = props.records,
      animation = props.animation,
      clip = props.clip;
    return jsx("group", {
      attrs: {
        clip: clip
      }
    }, records.map(function (record) {
      var key = record.key,
        children = record.children;
      return jsx("group", {
        key: key
      }, children.map(function (item) {
        var x = item.x,
          y = item.y,
          size = item.size,
          color = item.color,
          shapeName = item.shapeName,
          shape = item.shape;
        if (isNaN(x) || isNaN(y)) {
          return null;
        }
        if (shapeName === 'rect') {
          var rectSize = isNil(size) ? shape.size : size;
          return jsx("rect", {
            key: key,
            attrs: _objectSpread(_objectSpread({
              x: x - rectSize,
              y: y - rectSize,
              fill: color,
              stroke: color
            }, shape), {}, {
              width: rectSize * 2,
              height: rectSize * 2
            }),
            animation: deepMix({
              appear: {
                easing: 'linear',
                duration: 450
              },
              update: {
                easing: 'linear',
                duration: 450,
                property: ['x', 'y', 'width', 'height', 'fill']
              }
            }, animation)
          });
        }
        return jsx("circle", {
          key: key,
          style: _objectSpread(_objectSpread({
            cx: x,
            cy: y,
            fill: shapeName === 'circle' ? color : null,
            stroke: shapeName === 'hollowCircle' ? color : null
          }, shape), {}, {
            r: isNil(size) ? shape.size : size
          }),
          animation: deepMix({
            appear: {
              easing: 'linear',
              duration: 450
            },
            update: {
              easing: 'linear',
              duration: 450,
              property: ['cx', 'cy', 'r', 'fill']
            }
          }, animation)
        });
      }));
    }));
  });

  var index$3 = withPoint(PointView);

  var withAxis = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Axis, _Component);
      var _super = _createSuper(Axis);
      function Axis(props) {
        var _this;
        _classCallCheck(this, Axis);
        _this = _super.call(this, props);
        _this.axisStyle = {};
        var chart = props.chart,
          field = props.field;
        var scaleOption = _this.getScaleOption(props);
        chart.setScale(field, scaleOption);
        return _this;
      }
      _createClass$2(Axis, [{
        key: "willReceiveProps",
        value: function willReceiveProps(nextProps) {
          var lastProps = this.props;
          var chart = nextProps.chart,
            field = nextProps.field;
          var nextScaleOption = this.getScaleOption(nextProps);
          var lastScaleOption = this.getScaleOption(lastProps);
          if (!equal(nextScaleOption, lastScaleOption)) {
            chart.setScale(field, nextScaleOption);
          }
        }
      }, {
        key: "willMount",
        value: function willMount() {
          this.updateCoord();
        }
      }, {
        key: "willUpdate",
        value: function willUpdate() {
          this.updateCoord();
        }
      }, {
        key: "getScaleOption",
        value: function getScaleOption(props) {
          var type = props.type,
            tickCount = props.tickCount,
            range = props.range,
            mask = props.mask,
            formatter = props.formatter,
            ticks = props.ticks,
            min = props.min,
            max = props.max,
            nice = props.nice;
          return {
            type: type,
            tickCount: tickCount,
            range: range,
            mask: mask,
            formatter: formatter,
            min: min,
            max: max,
            nice: nice,
            ticks: ticks
          };
        }
      }, {
        key: "_getDimType",
        value: function _getDimType() {
          var props = this.props;
          var field = props.field,
            chart = props.chart;
          var xScales = chart.getXScales();
          var scales = xScales.filter(function (scale) {
            return scale.field === field;
          });
          return scales.length > 0 ? 'x' : 'y';
        }
        // ticks
      }, {
        key: "getMaxBBox",
        value: function getMaxBBox(ticks, style) {
          var context = this.context;
          var measureText = context.measureText;
          var label = style.label,
            labelOffset = style.labelOffset;
          var width = 0;
          var height = 0;
          ticks.forEach(function (tick) {
            if (!label) return;
            var _tick$labelStyle = tick.labelStyle,
              labelStyle = _tick$labelStyle === void 0 ? {} : _tick$labelStyle,
              text = tick.text;
            var bbox = measureText(labelStyle.text || text, _objectSpread(_objectSpread({}, label), labelStyle));
            width = Math.max(width, bbox.width);
            height = Math.max(height, bbox.height);
          });
          if (!width && !height) {
            return {
              width: width,
              height: height
            };
          }
          var bbox = {
            width: width + labelOffset,
            height: height + labelOffset
          };
          return bbox;
        }
      }, {
        key: "_getPosition",
        value: function _getPosition() {
          var props = this.props;
          var position = props.position,
            coord = props.coord;
          if (position) {
            return position;
          }
          var dimType = this._getDimType();
          if (coord.transposed) {
            return dimType === 'x' ? 'left' : 'bottom';
          }
          return dimType === 'x' ? 'bottom' : 'left';
        }
      }, {
        key: "getTicks",
        value: function getTicks() {
          var props = this.props;
          var field = props.field,
            chart = props.chart;
          var scale = chart.getScale(field);
          var ticks = scale.getTicks();
          // tick
          ticks = this._setTicksStyle(ticks);
          ticks = this._generateGridPoints(ticks);
          return ticks;
        }
        /**
         * 
         * @param ticks
         * @returns
         */
      }, {
        key: "_generateGridPoints",
        value: function _generateGridPoints(ticks) {
          var props = this.props;
          var chart = props.chart,
            coord = props.coord;
          if (!coord.isPolar) {
            return ticks;
          }
          var dimType = this._getDimType();
          //  y 
          if (dimType !== 'y') {
            return ticks;
          }
          var xScale = chart.getXScales()[0];
          var xTicks = xScale.getTicks();
          ticks.forEach(function (tick) {
            var gridPoints = xTicks.map(function (xTick) {
              return coord.convertPoint({
                x: xTick.value,
                y: tick.value
              });
            });
            //  1 
            gridPoints.push(gridPoints[0]);
            tick.gridPoints = gridPoints;
          });
          return ticks;
        }
      }, {
        key: "_setTicksStyle",
        value: function _setTicksStyle(ticks) {
          var _this2 = this;
          var props = this.props,
            context = this.context;
          var theme = context.theme,
            px2hd = context.px2hd;
          var _props$style = props.style,
            style = _props$style === void 0 ? {} : _props$style;
          var themeAxis = theme.axis;
          each(themeAxis, function (value, key) {
            // tick
            if (style[key] === null) {
              return;
            }
            var styleValue = isFunction(style[key]) ? undefined : style[key];
            if (isString(value) || isNumber(value)) {
              _this2.axisStyle[key] = px2hd(styleValue) || value;
            } else if (isArray(styleValue)) {
              _this2.axisStyle[key] = styleValue.map(function (d) {
                return px2hd(deepMix(clone$2(value), d));
              });
            } else {
              _this2.axisStyle[key] = px2hd(deepMix(clone$2(value), styleValue));
            }
          });
          return ticks.map(function (tick, index) {
            var label = style.label,
              grid = style.grid;
            var defaultLabelStyle = themeAxis.label,
              defaultGridStyle = themeAxis.grid;
            if (isFunction(label)) {
              tick.labelStyle = px2hd(mix({}, defaultLabelStyle, label(tick.text, index, ticks)));
            }
            if (isFunction(grid)) {
              tick.gridStyle = px2hd(mix({}, defaultGridStyle, grid(tick.text, index, ticks.length)));
            }
            return tick;
          });
        }
      }, {
        key: "convertTicks",
        value: function convertTicks(ticks) {
          var props = this.props;
          var coord = props.coord;
          var dimType = this._getDimType();
          var otherDim = dimType === 'x' ? 'y' : 'x';
          return ticks.map(function (tick) {
            var _coord$convertPoint, _coord$convertPoint2;
            var start = coord.convertPoint((_coord$convertPoint = {}, _defineProperty(_coord$convertPoint, dimType, tick.value), _defineProperty(_coord$convertPoint, otherDim, 0), _coord$convertPoint));
            var end = coord.convertPoint((_coord$convertPoint2 = {}, _defineProperty(_coord$convertPoint2, dimType, tick.value), _defineProperty(_coord$convertPoint2, otherDim, 1), _coord$convertPoint2));
            return _objectSpread(_objectSpread({}, tick), {}, {
              points: [start, end]
            });
          });
        }
      }, {
        key: "measureLayout",
        value: function measureLayout() {
          var props = this.props;
          var visible = props.visible,
            coord = props.coord;
          if (visible === false) {
            return null;
          }
          var ticks = this.getTicks();
          var bbox = this.getMaxBBox(ticks, this.axisStyle);
          var isPolar = coord.isPolar;
          var dimType = this._getDimType();
          var width = bbox.width,
            height = bbox.height;
          if (isPolar) {
            //  y 
            if (dimType === 'y') {
              return null;
            }
            // 4 
            return ['top', 'right', 'bottom', 'left'].map(function (position) {
              return {
                position: position,
                width: width,
                height: height
              };
            });
          }
          // 
          var position = this._getPosition();
          return {
            position: position,
            width: width,
            height: height
          };
        }
        // coord
      }, {
        key: "updateCoord",
        value: function updateCoord() {
          var props = this.props;
          var chart = props.chart;
          var layout = this.measureLayout();
          chart.updateCoordFor(this, layout);
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            axisStyle = this.axisStyle;
          var visible = props.visible,
            coord = props.coord;
          if (visible === false) {
            return null;
          }
          var ticks = this.getTicks();
          var position = this._getPosition();
          var dimType = this._getDimType();
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            style: axisStyle,
            ticks: this.convertTicks(ticks),
            coord: coord,
            position: position,
            dimType: dimType
          }));
        }
      }]);
      return Axis;
    }(Component);
  });

  // 
  function getOffsetPoint(center, point, offset) {
    var vectorX = point.x - center.x;
    var vectorY = point.y - center.y;
    var vectorLength = length$1([vectorX, vectorY]);
    var offsetLength = vectorLength + offset;
    var x = vectorX / vectorLength * offsetLength;
    var y = vectorY / vectorLength * offsetLength;
    return {
      x: center.x + x,
      y: center.y + y
    };
  }
  // 
  function getTextAlignInfo(center, point) {
    // 
    var vector = [point.x - center.x, point.y - center.y];
    var align;
    var baseLine;
    // 
    if (vector[0] > 0) {
      align = 'left';
    } else if (vector[0] < 0) {
      align = 'right';
    } else {
      align = 'center';
    }
    // 
    if (vector[1] > 0) {
      baseLine = 'top';
    } else if (vector[1] < 0) {
      baseLine = 'bottom';
    } else {
      baseLine = 'middle';
    }
    return {
      textAlign: align,
      textBaseline: baseLine
    };
  }
  var Line$1 = function Line(props) {
    var line = props.line,
      gridType = props.gridType,
      center = props.center,
      radius = props.radius,
      ticks = props.ticks;
    if (!line) return null;
    if (gridType !== 'line') {
      return jsx("arc", {
        attrs: _objectSpread({
          cx: center.x,
          cy: center.y,
          r: radius,
          startAngle: 0,
          endAngle: 360
        }, line)
      });
    }
    var points = ticks.map(function (tick) {
      var points = tick.points;
      return points[points.length - 1];
    });
    // 
    points.push(points[0]);
    return jsx("polyline", {
      attrs: _objectSpread({
        points: points.map(function (d) {
          return [d.x, d.y];
        })
      }, line)
    });
  };
  var PolarX = (function (props) {
    var originTicks = props.ticks,
      coord = props.coord,
      style = props.style,
      gridType = props.grid;
    var center = coord.center;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label;
    var ticks = originTicks.filter(function (d) {
      return !isNaN(d.value);
    });
    var firstTicks = ticks[0];
    var points = firstTicks.points;
    var end = points[points.length - 1];
    var radius = length$1([end.x - center.x, end.y - center.y]);
    return jsx("group", null, grid ? ticks.map(function (tick) {
      var points = tick.points,
        gridStyle = tick.gridStyle;
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread(_objectSpread({
          x1: center.x,
          y1: center.y,
          x2: end.x,
          y2: end.y
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? ticks.map(function (tick) {
      var points = tick.points;
      var end = points[points.length - 1];
      var offsetPoint = getOffsetPoint(center, end, tickLine.length);
      return jsx("line", {
        attrs: _objectSpread({
          x1: end.x,
          y1: end.y,
          x2: offsetPoint.x,
          y2: offsetPoint.y
        }, tickLine)
      });
    }) : null, jsx(Line$1, {
      line: line,
      gridType: gridType,
      center: center,
      radius: radius,
      ticks: ticks
    }), label ? ticks.map(function (tick) {
      var points = tick.points,
        text = tick.text,
        labelStyle = tick.labelStyle;
      var end = points[points.length - 1];
      var offsetPoint = getOffsetPoint(center, end, labelOffset);
      return jsx("text", {
        attrs: _objectSpread(_objectSpread(_objectSpread({
          x: offsetPoint.x,
          y: offsetPoint.y,
          text: text
        }, getTextAlignInfo(center, end)), label), labelStyle)
      });
    }) : null);
  });

  var PolarY = (function (props) {
    var originTicks = props.ticks,
      coord = props.coord,
      style = props.style,
      gridType = props.grid;
    var center = coord.center;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label;
    var ticks = originTicks.filter(function (d) {
      return !isNaN(d.value);
    });
    return jsx("group", null, grid ? ticks.map(function (tick) {
      var points = tick.points,
        gridStyle = tick.gridStyle,
        gridPoints = tick.gridPoints;
      var end = points[points.length - 1];
      if (gridType !== 'line') {
        return jsx("arc", {
          attrs: _objectSpread(_objectSpread({
            cx: center.x,
            cy: center.y,
            startAngle: 0,
            endAngle: 360,
            r: length$1([end.x - center.x, end.y - center.y])
          }, grid), gridStyle)
        });
      }
      return jsx("polyline", {
        attrs: _objectSpread(_objectSpread({
          points: gridPoints.map(function (d) {
            return [d.x, d.y];
          })
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? ticks.map(function (tick) {
      var points = tick.points;
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread({
          x1: end.x,
          y1: end.y,
          x2: end.x - tickLine.length,
          y2: end.y
        }, tickLine)
      });
    }) : null, line ? jsx("line", {
      attrs: _objectSpread({
        x1: ticks[0].points[0].x,
        y1: ticks[0].points[0].y,
        x2: ticks[ticks.length - 1].points[0].x,
        y2: ticks[ticks.length - 1].points[0].y
      }, line)
    }) : null, label ? ticks.map(function (tick) {
      var points = tick.points,
        text = tick.text,
        labelStyle = tick.labelStyle;
      var end = points[points.length - 1];
      return jsx("text", {
        attrs: _objectSpread(_objectSpread({
          x: end.x - labelOffset,
          y: end.y,
          text: text,
          textAlign: 'right',
          textBaseline: 'middle'
        }, label), labelStyle)
      });
    }) : null);
  });

  var Top = (function (props) {
    var originTicks = props.ticks,
      coord = props.coord,
      style = props.style;
    var left = coord.left,
      top = coord.top,
      right = coord.right;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label,
      symbol = style.symbol;
    var ticks = originTicks.filter(function (d) {
      return !isNaN(d.value);
    });
    var symbols = isArray(symbol) ? symbol : [symbol];
    return jsx("group", null, grid ? ticks.map(function (tick) {
      var points = tick.points,
        gridStyle = tick.gridStyle;
      var start = points[0];
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread(_objectSpread({
          x1: start.x,
          y1: start.y,
          x2: end.x,
          y2: end.y
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? ticks.map(function (tick) {
      var points = tick.points;
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread({
          x1: end.x,
          y1: end.y,
          x2: end.x,
          y2: end.y - tickLine.length
        }, tickLine)
      });
    }) : null, symbols[0] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: right,
        y: top,
        transform: 'rotate(90deg)',
        transformOrigin: '50% 50%'
      }, symbols[0]), {}, {
        symbol: symbols[0].type
      })
    }) : null, line ? jsx("line", {
      attrs: _objectSpread({
        x1: left,
        y1: top,
        x2: right,
        y2: top
      }, line)
    }) : null, symbols[1] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: left,
        y: top,
        transform: 'rotate(-90deg)',
        transformOrigin: '50% 50%'
      }, symbols[0]), {}, {
        symbol: symbols[1].type
      })
    }) : null, label ? ticks.map(function (tick, _index) {
      var points = tick.points,
        text = tick.text,
        labelStyle = tick.labelStyle;
      var end = points[points.length - 1];
      return jsx("text", {
        attrs: _objectSpread(_objectSpread({
          x: end.x,
          y: end.y - labelOffset,
          textAlign: 'center',
          textBaseline: 'bottom',
          text: text
        }, label), labelStyle)
      });
    }) : null);
  });

  var Bottom = (function (props, context) {
    var ticks = props.ticks,
      coord = props.coord,
      style = props.style,
      animation = props.animation;
    var px2hd = context.px2hd;
    var left = coord.left,
      right = coord.right,
      bottom = coord.bottom;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label,
      symbol = style.symbol;
    var filterTicks = ticks.filter(function (d) {
      return !isNaN(d.value);
    });
    var symbols = isArray(symbol) ? symbol : [symbol];
    return jsx("group", null, grid ? filterTicks.map(function (tick) {
      var points = tick.points,
        tickValue = tick.tickValue,
        gridStyle = tick.gridStyle;
      var start = points[0];
      var end = points[points.length - 1];
      return jsx("line", {
        key: tickValue,
        attrs: _objectSpread(_objectSpread({
          x1: start.x,
          y1: start.y,
          x2: end.x,
          y2: end.y
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? filterTicks.map(function (tick) {
      var points = tick.points,
        tickValue = tick.tickValue;
      var start = points[0];
      return jsx("line", {
        key: tickValue,
        attrs: _objectSpread({
          x1: start.x,
          y1: start.y,
          x2: start.x,
          y2: start.y + px2hd(tickLine.length)
        }, tickLine)
      });
    }) : null, symbols[0] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: right,
        y: bottom,
        transform: 'rotate(90deg)',
        transformOrigin: '50% 50%'
      }, symbols[0]), {}, {
        symbol: symbols[0].type
      })
    }) : null, line ? jsx("line", {
      attrs: _objectSpread({
        x1: left,
        y1: bottom,
        x2: right,
        y2: bottom
      }, line)
    }) : null, symbols[1] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: left,
        y: bottom,
        transform: 'rotate(-90deg)',
        transformOrigin: '50% 50%'
      }, symbols[0]), {}, {
        symbol: symbols[1].type
      })
    }) : null, label ? filterTicks.map(function (tick, index) {
      var points = tick.points,
        text = tick.text,
        tickValue = tick.tickValue,
        labelStyle = tick.labelStyle;
      var start = points[0];
      var _ref = labelStyle || label || {},
        _ref$align = _ref.align,
        align = _ref$align === void 0 ? 'center' : _ref$align;
      var textAttrs = _objectSpread(_objectSpread({
        x: start.x,
        y: start.y + labelOffset,
        textBaseline: 'top',
        text: text
      }, label), labelStyle);
      if (align === 'between') {
        if (index === 0) {
          textAttrs.textAlign = 'start';
        } else if (index === ticks.length - 1) {
          textAttrs.textAlign = 'end';
        } else {
          textAttrs.textAlign = 'center';
        }
      } else {
        textAttrs.textAlign = align;
      }
      return jsx("text", {
        key: tickValue,
        attrs: textAttrs,
        animation: animation || {
          appear: {
            easing: 'linear',
            duration: 300,
            delay: 0,
            property: ['fillOpacity'],
            start: {
              fillOpacity: 0
            },
            end: {
              fillOpacity: 1
            }
          },
          update: {
            easing: 'linear',
            duration: 450,
            delay: 0,
            property: ['x', 'y']
          },
          leave: {
            easing: 'linear',
            duration: 450,
            delay: 0,
            property: ['fillOpacity'],
            start: {
              fillOpacity: 1
            },
            end: {
              fillOpacity: 0
            }
          }
        }
      });
    }) : null);
  });

  var Right = (function (props) {
    var originTicks = props.ticks,
      coord = props.coord,
      style = props.style;
    var top = coord.top,
      right = coord.right,
      bottom = coord.bottom;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label,
      symbol = style.symbol;
    var ticks = originTicks.filter(function (d) {
      return !isNaN(d.value);
    });
    var symbols = isArray(symbol) ? symbol : [symbol];
    return jsx("group", null, grid ? ticks.map(function (tick) {
      var points = tick.points,
        gridStyle = tick.gridStyle;
      var start = points[0];
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread(_objectSpread({
          x1: start.x,
          y1: start.y,
          x2: end.x,
          y2: end.y
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? ticks.map(function (tick) {
      var points = tick.points;
      var end = points[points.length - 1];
      return jsx("line", {
        attrs: _objectSpread({
          x1: end.x,
          y1: end.y,
          x2: end.x + tickLine.length,
          y2: end.y
        }, tickLine)
      });
    }) : null, symbols[0] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: right,
        y: top
      }, symbols[0]), {}, {
        symbol: symbols[0].type
      })
    }) : null, line ? jsx("line", {
      attrs: _objectSpread({
        x1: right,
        y1: top,
        x2: right,
        y2: bottom
      }, line)
    }) : null, symbols[1] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: right,
        y: bottom,
        transform: 'rotate(180deg)',
        transformOrigin: '50% 50%'
      }, symbols[1]), {}, {
        symbol: symbols[1].type
      })
    }) : null, label ? ticks.map(function (tick, _index) {
      var points = tick.points,
        text = tick.text,
        labelStyle = tick.labelStyle;
      var end = points[points.length - 1];
      return jsx("text", {
        attrs: _objectSpread(_objectSpread({
          x: end.x + labelOffset,
          y: end.y,
          textAlign: 'left',
          textBaseline: 'middle',
          text: text
        }, label), labelStyle)
      });
    }) : null);
  });

  var Left = (function (props) {
    var originTicks = props.ticks,
      coord = props.coord,
      style = props.style,
      animation = props.animation;
    var left = coord.left,
      top = coord.top,
      bottom = coord.bottom;
    var grid = style.grid,
      tickLine = style.tickLine,
      line = style.line,
      labelOffset = style.labelOffset,
      label = style.label,
      symbol = style.symbol;
    var ticks = originTicks.filter(function (d) {
      return !isNaN(d.value);
    });
    var symbols = isArray(symbol) ? symbol : [symbol];
    return jsx("group", null, grid ? ticks.map(function (tick) {
      var points = tick.points,
        tickValue = tick.tickValue,
        gridStyle = tick.gridStyle;
      var start = points[0];
      var end = points[points.length - 1];
      return jsx("line", {
        key: tickValue,
        attrs: _objectSpread(_objectSpread({
          x1: start.x,
          y1: start.y,
          x2: end.x,
          y2: end.y
        }, grid), gridStyle)
      });
    }) : null, tickLine && tickLine.length ? ticks.map(function (tick) {
      var points = tick.points,
        tickValue = tick.tickValue;
      var start = points[0];
      return jsx("line", {
        key: tickValue,
        attrs: _objectSpread({
          x1: start.x,
          y1: start.y,
          x2: start.x - tickLine.length,
          y2: start.y
        }, tickLine)
      });
    }) : null, symbols[0] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: left,
        y: top
      }, symbols[0]), {}, {
        symbol: symbols[0].type
      })
    }) : null, line ? jsx("line", {
      style: _objectSpread({
        x1: left,
        y1: top,
        x2: left,
        y2: bottom
      }, line)
    }) : null, symbols[1] ? jsx("marker", {
      style: _objectSpread(_objectSpread({
        x: left,
        y: bottom,
        transform: 'rotate(180deg)',
        transformOrigin: '50% 50%'
      }, symbols[1]), {}, {
        symbol: symbols[1].type
      })
    }) : null, label ? ticks.map(function (tick, _index) {
      var tickValue = tick.tickValue,
        points = tick.points,
        text = tick.text,
        labelStyle = tick.labelStyle;
      var start = points[0];
      return jsx("text", {
        key: tickValue,
        attrs: _objectSpread(_objectSpread({
          x: start.x - labelOffset,
          y: start.y,
          textAlign: 'right',
          textBaseline: 'middle',
          text: text
        }, label), labelStyle),
        animation: animation || {
          appear: {
            easing: 'linear',
            duration: 300,
            delay: 0,
            property: ['fillOpacity'],
            start: {
              fillOpacity: 0
            },
            end: {
              fillOpacity: 1
            }
          },
          update: {
            easing: 'linear',
            duration: 450,
            delay: 0,
            property: ['x', 'y']
          },
          leave: {
            easing: 'linear',
            duration: 450,
            delay: 0,
            property: ['fillOpacity'],
            start: {
              fillOpacity: 1
            },
            end: {
              fillOpacity: 0
            }
          }
        }
      });
    }) : null);
  });

  function isPolar(props) {
    return props.coord.isPolar;
  }
  var AxisView = (function (props) {
    // 
    if (isPolar(props)) {
      var dimType = props.dimType;
      if (dimType === 'x') {
        return jsx(PolarX, _objectSpread({}, props));
      }
      return jsx(PolarY, _objectSpread({}, props));
    }
    var position = props.position;
    // 
    if (position === 'right') {
      return jsx(Right, _objectSpread({}, props));
    }
    if (position === 'left') {
      return jsx(Left, _objectSpread({}, props));
    }
    if (position === 'top') {
      return jsx(Top, _objectSpread({}, props));
    }
    return jsx(Bottom, _objectSpread({}, props));
  });

  var index$4 = withAxis(AxisView);

  var withLegend = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Legend, _Component);
      var _super = _createSuper(Legend);
      function Legend(props) {
        var _this;
        _classCallCheck(this, Legend);
        _this = _super.call(this, props);
        _this._onclick = function (item) {
          var _assertThisInitialize = _assertThisInitialized$2(_this),
            props = _assertThisInitialize.props;
          var chart = props.chart,
            _props$clickable = props.clickable,
            clickable = _props$clickable === void 0 ? true : _props$clickable,
            onClick = props.onClick;
          if (!clickable) return;
          var clickItem = item.currentTarget;
          if (!clickItem) {
            return;
          }
          // @ts-ignore
          var dataItem = clickItem.config['data-item'];
          if (!dataItem) {
            return;
          }
          if (isFunction(onClick)) {
            onClick(dataItem);
          }
          var field = dataItem.field,
            tickValue = dataItem.tickValue;
          var prevFiltered = _this.state.filtered;
          var filtered = _objectSpread(_objectSpread({}, prevFiltered), {}, _defineProperty({}, tickValue, !prevFiltered[tickValue]));
          _this.setState({
            filtered: filtered
          });
          chart.filter(field, function (value) {
            return !filtered[value];
          });
        };
        _this.state = {
          filtered: {},
          items: []
        };
        return _this;
      }
      _createClass$2(Legend, [{
        key: "getOriginItems",
        value: function getOriginItems() {
          var chart = this.props.chart;
          return chart.getLegendItems();
        }
      }, {
        key: "getItems",
        value: function getItems() {
          var _props$items;
          var props = this.props,
            state = this.state;
          var filtered = state.filtered;
          var renderItems = ((_props$items = props.items) === null || _props$items === void 0 ? void 0 : _props$items.length) ? props.items : this.getOriginItems();
          if (!renderItems) return null;
          return renderItems.map(function (item) {
            var tickValue = item.tickValue;
            return _objectSpread(_objectSpread({}, item), {}, {
              filtered: filtered[tickValue]
            });
          });
        }
      }, {
        key: "setItems",
        value: function setItems(items) {
          this.setState({
            items: items
          });
        }
      }, {
        key: "getMaxItemBox",
        value: function getMaxItemBox(node) {
          var maxItemWidth = 0;
          var maxItemHeight = 0;
          (node.children || []).forEach(function (child) {
            var layout = child.layout;
            var width = layout.width,
              height = layout.height;
            maxItemWidth = Math.max(maxItemWidth, width);
            maxItemHeight = Math.max(maxItemHeight, height);
          });
          return {
            width: maxItemWidth,
            height: maxItemHeight
          };
        }
        //  legend 
      }, {
        key: "_init",
        value: function _init() {
          var props = this.props,
            context = this.context;
          var parentLayout = props.layout,
            customWidth = props.width,
            customHeight = props.height,
            _props$position = props.position,
            position = _props$position === void 0 ? 'top' : _props$position;
          var items = this.getItems();
          if (!items || !items.length) return;
          var left = parentLayout.left,
            top = parentLayout.top,
            layoutWidth = parentLayout.width,
            layoutHeight = parentLayout.height;
          var width = context.px2hd(customWidth) || layoutWidth;
          var node = computeLayout$1(this, this.render());
          var _this$getMaxItemBox = this.getMaxItemBox(node),
            itemMaxWidth = _this$getMaxItemBox.width,
            itemMaxHeight = _this$getMaxItemBox.height;
          // 
          var lineMaxCount = Math.max(1, Math.floor(width / itemMaxWidth));
          var itemCount = items.length;
          // legend item 
          var lineCount = Math.ceil(itemCount / lineMaxCount);
          var itemWidth = width / lineMaxCount;
          var autoHeight = itemMaxHeight * lineCount;
          var style = {
            left: left,
            top: top,
            width: width,
            // height 
            height: undefined,
            flexDirection: 'row',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'flex-start'
          };
          // 2
          if (lineCount === 1) {
            style.justifyContent = 'space-between';
          }
          if (position === 'top') {
            style.height = customHeight ? customHeight : autoHeight;
          }
          if (position === 'left') {
            style.flexDirection = 'column';
            style.justifyContent = 'center';
            style.width = itemMaxWidth;
            style.height = customHeight ? customHeight : layoutHeight;
          }
          if (position === 'right') {
            style.flexDirection = 'column';
            style.alignItems = 'flex-start';
            style.justifyContent = 'center';
            style.width = itemMaxWidth;
            style.height = customHeight ? customHeight : layoutHeight;
            style.left = left + (width - itemMaxWidth);
          }
          if (position === 'bottom') {
            style.top = top + (layoutHeight - autoHeight);
            style.height = customHeight ? customHeight : autoHeight;
          }
          this.itemWidth = itemWidth;
          this.legendStyle = style;
        }
      }, {
        key: "updateCoord",
        value: function updateCoord() {
          var context = this.context,
            props = this.props,
            legendStyle = this.legendStyle;
          var _props$position2 = props.position,
            position = _props$position2 === void 0 ? 'top' : _props$position2,
            _props$margin = props.margin,
            margin = _props$margin === void 0 ? '30px' : _props$margin,
            chart = props.chart;
          var width = legendStyle.width,
            height = legendStyle.height;
          var marginNumber = context.px2hd(margin);
          chart.updateCoordFor(this, {
            position: position,
            width: width + marginNumber,
            height: height + marginNumber
          });
        }
      }, {
        key: "willMount",
        value: function willMount() {
          var items = this.getItems();
          if (!items || !items.length) return;
          this._init();
          this.updateCoord();
        }
      }, {
        key: "didMount",
        value: function didMount() {
          // this._initEvent();
        }
      }, {
        key: "willUpdate",
        value: function willUpdate() {
          var items = this.getItems();
          if (!items || !items.length) return;
          this.updateCoord();
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            itemWidth = this.itemWidth,
            legendStyle = this.legendStyle;
          var items = this.getItems();
          if (!items || !items.length) {
            return null;
          }
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            items: items,
            itemWidth: itemWidth,
            style: _objectSpread(_objectSpread({}, legendStyle), props.style),
            onClick: this._onclick
          }));
        }
      }]);
      return Legend;
    }(Component);
  });

  var Marker$1 = function Marker(_ref) {
    var type = _ref.type,
      color = _ref.color;
    if (type === 'square') {
      return jsx("rect", {
        style: {
          width: '12px',
          height: '12px',
          marginRight: '10px'
        },
        attrs: {
          fill: color
        }
      });
    }
    if (type === 'line') {
      return jsx("line", {
        style: {
          width: '19px',
          marginRight: '10px'
        },
        attrs: {
          stroke: color,
          lineCap: 'round',
          lineWidth: '4px'
        }
      });
    }
    return jsx("circle", {
      style: {
        width: '12px',
        height: '12px',
        marginRight: '10px',
        fill: color
      }
    });
  };
  var LegendView = (function (props) {
    var items = props.items,
      itemWidth = props.itemWidth,
      itemFormatter = props.itemFormatter,
      style = props.style,
      _props$marker = props.marker,
      marker = _props$marker === void 0 ? 'circle' : _props$marker,
      itemStyle = props.itemStyle,
      nameStyle = props.nameStyle,
      valueStyle = props.valueStyle,
      valuePrefix = props.valuePrefix,
      onClick = props.onClick;
    var formatValue = function formatValue(value) {
      var valuePrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ': ';
      return "".concat(valuePrefix).concat(value);
    };
    return jsx("group", {
      style: _objectSpread({
        display: 'flex'
      }, style)
    }, items.map(function (item) {
      var color = item.color,
        name = item.name,
        value = item.value,
        filtered = item.filtered,
        tickValue = item.tickValue;
      var valueText = isFunction(itemFormatter) ? itemFormatter(value, tickValue) : value;
      return jsx("group", {
        className: "legend-item",
        style: _objectSpread({
          width: itemWidth,
          display: 'flex',
          flexDirection: 'row',
          alignItems: 'center',
          justifyContent: 'flex-start',
          //TODO: padding12px 
          padding: ['6px', '6px', '6px', 0]
        }, itemStyle),
        "data-item": item,
        onClick: onClick
      }, Marker$1({
        color: filtered ? '#bfbfbf' : color,
        type: marker
      }), jsx("text", {
        attrs: _objectSpread({
          fill: filtered ? '#bfbfbf' : '#808080',
          text: name
        }, nameStyle)
      }), valueText ? jsx("text", {
        attrs: _objectSpread({
          fill: '#808080',
          text: formatValue(valueText, valuePrefix)
        }, valueStyle)
      }) : null);
    }));
  });

  var index$5 = withLegend(LegendView);

  var withGuide = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Guide, _Component);
      var _super = _createSuper(Guide);
      function Guide(props) {
        _classCallCheck(this, Guide);
        return _super.call(this, props);
      }
      _createClass$2(Guide, [{
        key: "getGuideBBox",
        value: function getGuideBBox() {
          var node = computeLayout$1(this, this.render());
          var layout = node.layout;
          if (!layout) return;
          return layout;
        }
        // recordminmax50%...
      }, {
        key: "parseReplaceStr",
        value: function parseReplaceStr(value, scale) {
          var replaceMap = {
            min: 0,
            max: 1,
            median: 0.5
          };
          //  minmaxmedian 
          if (!isNil(replaceMap[value])) {
            return replaceMap[value];
          }
          //  xx%
          if (isString(value) && value.indexOf('%') != -1 && !isNaN(Number(value.slice(0, -1)))) {
            var rateValue = Number(value.slice(0, -1));
            var percent = rateValue / 100;
            return percent;
          }
          return scale.scale(value);
        }
      }, {
        key: "parsePoint",
        value: function parsePoint(record) {
          var props = this.props;
          var chart = props.chart,
            coord = props.coord;
          var xScale = chart.getXScales()[0];
          // yScale
          var yScale = chart.getYScales()[0];
          //  record 
          var x = this.parseReplaceStr(record[xScale.field], xScale);
          var y = this.parseReplaceStr(record[yScale.field], yScale);
          return coord.convertPoint({
            x: x,
            y: y
          });
        }
      }, {
        key: "convertPoints",
        value: function convertPoints(records) {
          var _this = this;
          return records.map(function (record) {
            return _this.parsePoint(record);
          });
        }
      }, {
        key: "getGuideTheme",
        value: function getGuideTheme() {
          var context = this.context;
          var theme = context.theme;
          return theme.guide;
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            context = this.context;
          var coord = props.coord,
            _props$records = props.records,
            records = _props$records === void 0 ? [] : _props$records,
            animation = props.animation,
            chart = props.chart,
            style = props.style,
            _onClick = props.onClick;
          var width = context.width,
            height = context.height;
          var points = this.convertPoints(records);
          var theme = this.getGuideTheme();
          return jsx("group", {
            onClick: function onClick(ev) {
              _onClick && _onClick(ev);
            }
          }, jsx(View, _objectSpread(_objectSpread({
            points: points,
            theme: theme,
            coord: coord
          }, props), {}, {
            canvasWidth: width,
            canvasHeight: height,
            style: isFunction(style) ? style(points, chart) : style,
            animation: isFunction(animation) ? animation(points, chart) : animation
          })));
        }
      }]);
      return Guide;
    }(Component);
  });

  var TextGuideView = (function (props, context) {
    var _props$theme = props.theme,
      theme = _props$theme === void 0 ? {} : _props$theme;
    var _deepMix = deepMix(_objectSpread({}, theme.text), props),
      points = _deepMix.points,
      style = _deepMix.style,
      offsetX = _deepMix.offsetX,
      offsetY = _deepMix.offsetY,
      content = _deepMix.content,
      animation = _deepMix.animation;
    var _ref = points[0] || {},
      x = _ref.x,
      y = _ref.y;
    var offsetXNum = context.px2hd(offsetX);
    var offsetYNum = context.px2hd(offsetY);
    var posX = x + (offsetXNum || 0);
    var posY = y + (offsetYNum || 0);
    return jsx("text", {
      attrs: _objectSpread({
        text: "".concat(content),
        x: posX,
        y: posY
      }, style),
      animation: deepMix({
        update: {
          easing: 'linear',
          duration: 450,
          property: ['x', 'y']
        }
      }, animation)
    });
  });

  var PointGuideView = (function (props, context) {
    var theme = props.theme;
    var _deepMix = deepMix(_objectSpread({}, theme.point), props),
      points = _deepMix.points,
      style = _deepMix.style,
      offsetX = _deepMix.offsetX,
      offsetY = _deepMix.offsetY,
      animation = _deepMix.animation;
    var _ref = points[0] || {},
      x = _ref.x,
      y = _ref.y;
    var offsetXNum = context.px2hd(offsetX);
    var offsetYNum = context.px2hd(offsetY);
    var posX = x + (offsetXNum || 0);
    var posY = y + (offsetYNum || 0);
    return jsx("group", null, jsx("circle", {
      style: _objectSpread({
        cx: posX,
        cy: posY
      }, style),
      animation: animation
    }));
  });

  var LineGuideView = (function (props, context) {
    var _props$theme = props.theme,
      theme = _props$theme === void 0 ? {} : _props$theme;
    var _deepMix = deepMix(_objectSpread({}, theme.line), props),
      points = _deepMix.points,
      style = _deepMix.style,
      offsetX = _deepMix.offsetX,
      offsetY = _deepMix.offsetY,
      animation = _deepMix.animation;
    var _ref = points[0] || {},
      x1 = _ref.x,
      y1 = _ref.y;
    var _ref2 = points[1] || {},
      x2 = _ref2.x,
      y2 = _ref2.y;
    var offsetXNum = context.px2hd(offsetX);
    var offsetYNum = context.px2hd(offsetY);
    var posX1 = x1 + (isArray(offsetXNum) ? offsetXNum[0] || 0 : offsetXNum || 0);
    var posY1 = y1 + (isArray(offsetYNum) ? offsetYNum[0] || 0 : offsetYNum || 0);
    var posX2 = x2 + (isArray(offsetXNum) ? offsetXNum[1] || 0 : offsetXNum || 0);
    var posY2 = y2 + (isArray(offsetYNum) ? offsetYNum[1] || 0 : offsetYNum || 0);
    return jsx("group", null, jsx("line", {
      style: _objectSpread({
        x1: posX1,
        y1: posY1,
        x2: posX2,
        y2: posY2
      }, style),
      animation: animation
    }));
  });

  var ArcGuideView = (function (props) {
    var _props$theme = props.theme,
      theme = _props$theme === void 0 ? {} : _props$theme;
    var _deepMix = deepMix(_objectSpread({}, theme.line), props),
      coord = _deepMix.coord,
      points = _deepMix.points,
      style = _deepMix.style,
      animation = _deepMix.animation;
    var start = points[0] || {};
    var end = points[1] || {};
    var coordCenter = coord.center;
    var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));
    var startAngle = Math.atan2(start.y - coordCenter.y, start.x - coordCenter.x);
    var endAngle = Math.atan2(end.y - coordCenter.y, end.x - coordCenter.x);
    return jsx("group", null, jsx("arc", {
      style: _objectSpread({
        cx: coordCenter.x,
        cy: coordCenter.y,
        r: radius,
        startAngle: "".concat(startAngle, "rad"),
        endAngle: "".concat(endAngle, "rad")
      }, style),
      animation: animation
    }));
  });

  var RectGuideView = (function (props) {
    var _props$theme = props.theme,
      theme = _props$theme === void 0 ? {} : _props$theme;
    var _deepMix = deepMix(_objectSpread({}, theme.rect), props),
      points = _deepMix.points,
      style = _deepMix.style,
      animation = _deepMix.animation;
    var start = points[0] || {};
    var end = points[1] || {};
    return jsx("group", null, jsx("rect", {
      style: _objectSpread({
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y),
        width: Math.abs(end.x - start.x),
        height: Math.abs(start.y - end.y)
      }, style),
      animation: animation
    }));
  });

  var defaultProps = {
    offsetX: 0,
    offsetY: 0,
    points: [],
    src: ''
  };
  var ImageGuideView = (function (props, context) {
    var cfg = deepMix({}, defaultProps, props);
    var points = cfg.points,
      style = cfg.style,
      attrs = cfg.attrs,
      offsetX = cfg.offsetX,
      offsetY = cfg.offsetY,
      src = cfg.src,
      animation = cfg.animation;
    var _ref = points[0] || {},
      x = _ref.x,
      y = _ref.y;
    var _attrs$style = _objectSpread(_objectSpread({}, attrs), style),
      _attrs$style$height = _attrs$style.height,
      height = _attrs$style$height === void 0 ? 0 : _attrs$style$height,
      _attrs$style$width = _attrs$style.width,
      width = _attrs$style$width === void 0 ? 0 : _attrs$style$width;
    var heightNum = context.px2hd(height + 'px');
    var widthNum = context.px2hd(width + 'px');
    var offsetXNum = context.px2hd(offsetX);
    var offsetYNum = context.px2hd(offsetY);
    var posX = x + (offsetXNum || 0) - widthNum / 2;
    var posY = y + (offsetYNum || 0) - heightNum / 2;
    return jsx("group", null, jsx("image", {
      style: _objectSpread(_objectSpread(_objectSpread({}, attrs), style), {}, {
        height: heightNum,
        width: widthNum,
        x: posX,
        y: posY,
        src: src
      }),
      animation: deepMix({
        update: {
          easing: 'linear',
          duration: 450,
          property: ['x', 'y']
        }
      }, animation)
    }));
  });

  var defaultProps$1 = {
    offsetX: 0,
    offsetY: 0,
    points: [],
    direct: 'tl',
    side: '8px',
    autoAdjust: true
  };
  var defaultStyle = {
    container: {
      fill: '#1677FF',
      radius: '4px',
      padding: ['4px', '8px']
    },
    text: {
      fontSize: '22px',
      fill: '#fff'
    },
    arrow: {
      fill: '#1677FF'
    }
  };
  var Label = function Label(_ref) {
    var content = _ref.content,
      background = _ref.background,
      textStyle = _ref.textStyle;
    return jsx("rect", {
      style: _objectSpread({
        display: 'flex',
        fill: defaultStyle.container.fill,
        padding: defaultStyle.container.padding,
        radius: defaultStyle.container.radius
      }, background)
    }, jsx("text", {
      style: _objectSpread({
        text: content,
        fontSize: defaultStyle.text.fontSize,
        fill: defaultStyle.text.fill
      }, textStyle)
    }));
  };
  var Tag = /*#__PURE__*/function (_Component) {
    _inherits(Tag, _Component);
    var _super = _createSuper(Tag);
    function Tag() {
      _classCallCheck(this, Tag);
      return _super.apply(this, arguments);
    }
    _createClass$2(Tag, [{
      key: "render",
      value: function render() {
        var props = this.props,
          context = this.context;
        var px2hd = context.px2hd;
        var cfg = _objectSpread(_objectSpread({}, defaultProps$1), props);
        var _px2hd = px2hd(cfg),
          points = _px2hd.points,
          content = _px2hd.content,
          offsetX = _px2hd.offsetX,
          offsetY = _px2hd.offsetY,
          direct = _px2hd.direct,
          side = _px2hd.side,
          autoAdjust = _px2hd.autoAdjust,
          canvasWidth = _px2hd.canvasWidth,
          canvasHeight = _px2hd.canvasHeight,
          background = _px2hd.background,
          textStyle = _px2hd.textStyle;
        var _ref2 = points[0] || {},
          x = _ref2.x,
          y = _ref2.y;
        var offsetXNum = context.px2hd(offsetX);
        var offsetYNum = context.px2hd(offsetY);
        var posX = x + (offsetXNum || 0);
        var posY = y + (offsetYNum || 0);
        var _computeLayout = computeLayout$1(this, jsx(Label, {
            content: content,
            background: background,
            textStyle: textStyle
          })),
          layout = _computeLayout.layout;
        var guideWidth = layout.width,
          guideHeight = layout.height;
        var _getDirect = function _getDirect(point) {
          var newDirect = direct;
          var x = point.x,
            y = point.y;
          var vertical = newDirect[0];
          var horizontal = newDirect[1];
          // adjust for vertical direction
          if (vertical === 't' && y - side - guideHeight < 0) {
            vertical = 'b';
          } else if (vertical === 'b' && y + side + guideHeight > canvasHeight) {
            vertical = 't';
          }
          // adjust for horizontal direction
          var diff = vertical === 'c' ? side : 0;
          if (horizontal === 'l' && x - diff - guideWidth < 0) {
            horizontal = 'r';
          } else if (horizontal === 'r' && x + diff + guideWidth > canvasWidth) {
            horizontal = 'l';
          } else if (horizontal === 'c') {
            if (guideWidth / 2 + x + diff > canvasWidth) {
              horizontal = 'l';
            } else if (x - guideWidth / 2 - diff < 0) {
              horizontal = 'r';
            }
          }
          newDirect = vertical + horizontal;
          return newDirect;
        };
        var _getArrowPoints = function _getArrowPoints(direct) {
          var arrowPoints = [];
          if (direct === 'tl') {
            arrowPoints = [{
              x: guideWidth,
              y: guideHeight - 1
            }, {
              x: guideWidth,
              y: guideHeight + side
            }, {
              x: guideWidth - side,
              y: guideHeight - 1
            }];
            posX -= guideWidth || 0;
            posY = posY - (guideHeight || 0) - side;
          } else if (direct === 'cl') {
            arrowPoints = [{
              x: guideWidth,
              y: guideHeight / 2 - side
            }, {
              x: guideWidth,
              y: guideHeight / 2 + side
            }, {
              x: guideWidth + side,
              y: guideHeight / 2
            }];
            posX = posX - (guideWidth || 0) - side;
            posY -= guideHeight / 2 || 0;
          } else if (direct === 'bl') {
            arrowPoints = [{
              x: guideWidth,
              y: -side
            }, {
              x: guideWidth,
              y: 1
            }, {
              x: guideWidth - side,
              y: 1
            }];
            posX = posX - (guideWidth || 0);
            posY += side;
          } else if (direct === 'bc') {
            arrowPoints = [{
              x: guideWidth / 2,
              y: -side
            }, {
              x: guideWidth / 2 - side,
              y: 1
            }, {
              x: guideWidth / 2 + side,
              y: 1
            }];
            posX = posX - (guideWidth / 2 || 0);
            posY = posY + side;
          } else if (direct === 'br') {
            arrowPoints = [{
              x: 0,
              y: -side
            }, {
              x: 0,
              y: 1
            }, {
              x: +side,
              y: 1
            }];
            posY += side;
          } else if (direct === 'cr') {
            arrowPoints = [{
              x: -side,
              y: guideHeight / 2
            }, {
              x: 0,
              y: guideHeight / 2 - side
            }, {
              x: 0,
              y: guideHeight / 2 + side
            }];
            posX += side;
            posY -= guideHeight / 2 || 0;
          } else if (direct === 'tr') {
            arrowPoints = [{
              x: 0,
              y: guideHeight + side
            }, {
              x: 0,
              y: guideHeight - 1
            }, {
              x: side,
              y: guideHeight - 1
            }];
            posY = posY - (guideHeight || 0) - side;
          } else if (direct === 'tc') {
            arrowPoints = [{
              x: guideWidth / 2,
              y: guideHeight + side
            }, {
              x: guideWidth / 2 - side,
              y: guideHeight - 1
            }, {
              x: guideWidth / 2 + side,
              y: guideHeight - 1
            }];
            posX -= guideWidth / 2 || 0;
            posY = posY - guideHeight - side;
          }
          return arrowPoints;
        };
        var dr = autoAdjust ? _getDirect(points[0]) : direct;
        var arrowPoints = _getArrowPoints(dr);
        return jsx("group", {
          style: {
            x: posX,
            y: posY
          }
        }, jsx(Label, {
          content: content,
          background: background,
          textStyle: textStyle
        }), jsx("polygon", {
          style: {
            points: arrowPoints.map(function (d) {
              return [d.x, d.y];
            }),
            fill: (background === null || background === void 0 ? void 0 : background.fill) || defaultStyle.arrow.fill
          }
        }));
      }
    }]);
    return Tag;
  }(Component);

  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  var _excluded$c = ["offset", "easing"],
    _excluded2 = ["ignore", "easing", "offset"];
  var eps = 0.0001;
  /**
   * Provides some control methods like:
   * - play
   * - pause
   * - stop
   * - goToAndStop
   * - goToAndPlay
   * @see https://github.com/airbnb/lottie-web/blob/master/player/js/animation/AnimationItem.js
   */
  var LottieAnimation = /*#__PURE__*/function () {
    function LottieAnimation(width, height, elements, context) {
      var _this = this;
      this.width = void 0;
      this.height = void 0;
      this.elements = void 0;
      this.context = void 0;
      this.displayObjects = void 0;
      this.keyframeAnimationMap = new WeakMap();
      this.displayObjectElementMap = new WeakMap();
      this.animations = [];
      this.isPaused = false;
      this.direction = 1;
      this.width = width;
      this.height = height;
      this.elements = elements;
      this.context = context;
      this.displayObjects = elements.map(function (element) {
        return _this.buildHierachy(element);
      });
      // TODO: preload images
      // TODO: preload fonts
    }
    var _proto = LottieAnimation.prototype;
    _proto.generateTransform = function generateTransform(tx, ty, scaleX, scaleY, rotation) {
      var transformStr = '';
      if (tx !== 0 || ty !== 0) {
        transformStr += "translate(" + tx + ", " + ty + ")";
      }
      if (scaleX !== 1 || scaleY !== 1) {
        transformStr += " scale(" + (scaleX === 0 ? eps : scaleX) + ", " + (scaleY === 0 ? eps : scaleY) + ")";
      }
      if (rotation !== 0) {
        transformStr += " rotate(" + rotation + "deg)";
      }
      return transformStr;
    };
    _proto.buildHierachy = function buildHierachy(element) {
      var _this2 = this;
      var type = element.type,
        name = element.name,
        _element$anchorX = element.anchorX,
        anchorX = _element$anchorX === void 0 ? 0 : _element$anchorX,
        _element$anchorY = element.anchorY,
        anchorY = _element$anchorY === void 0 ? 0 : _element$anchorY,
        _element$rotation = element.rotation,
        rotation = _element$rotation === void 0 ? 0 : _element$rotation,
        _element$scaleX = element.scaleX,
        scaleX = _element$scaleX === void 0 ? 1 : _element$scaleX,
        _element$scaleY = element.scaleY,
        scaleY = _element$scaleY === void 0 ? 1 : _element$scaleY,
        _element$x = element.x,
        x = _element$x === void 0 ? 0 : _element$x,
        _element$y = element.y,
        y = _element$y === void 0 ? 0 : _element$y,
        children = element.children,
        shape = element.shape,
        style = element.style,
        keyframeAnimation = element.keyframeAnimation;
      var displayObject;
      var transform = this.generateTransform(x - anchorX, y - anchorY, scaleX, scaleY, rotation);
      // const transformMat = mat4.fromRotationTranslationScaleOrigin(
      //   mat4.create(),
      //   quat.fromEuler(quat.create(), 0, 0, rotation),
      //   [x - anchorX, y - anchorY, 0],
      //   [scaleX, scaleY, 1],
      //   [anchorX, anchorY, 0],
      // );
      // TODO: repeater @see https://lottiefiles.github.io/lottie-docs/shapes/#repeater
      // @see https://lottiefiles.github.io/lottie-docs/shapes/#shape
      // TODO: polystar, convert to Bezier @see https://lottiefiles.github.io/lottie-docs/rendering/#polystar
      if (type === Shape.GROUP) {
        displayObject = new Group({
          style: {
            transformOrigin: anchorX + "px " + anchorY + "px",
            transform: transform
          }
        });
      } else if (type === Shape.ELLIPSE) {
        var cx = shape.cx,
          cy = shape.cy,
          rx = shape.rx,
          ry = shape.ry;
        // const center = vec3.fromValues(cx, cy, 0);
        // vec3.transformMat4(center, center, transformMat);
        displayObject = new Ellipse({
          style: {
            // cx: center[0],
            // cy: center[1],
            cx: cx,
            cy: cy,
            rx: rx,
            ry: ry,
            // reset transform-origin based on anchor & center
            transformOrigin: anchorX - cx + rx + "px " + (anchorY - cy + ry) + "px",
            transform: transform
          }
        });
      } else if (type === Shape.PATH) {
        var d = this.generatePathFromShape(shape);
        displayObject = new Path({
          style: {
            d: d,
            transformOrigin: anchorX + "px " + anchorY + "px",
            transform: transform
          }
        });
      } else if (type === Shape.RECT) {
        // @see https://lottiefiles.github.io/lottie-docs/shapes/#rectangle
        var _cx = shape.x,
          _cy = shape.y,
          width = shape.width,
          height = shape.height,
          r = shape.r;
        displayObject = new Rect({
          style: {
            x: _cx,
            y: _cy,
            width: width,
            height: height,
            anchor: [0.5, 0.5],
            radius: r,
            transformOrigin: anchorX - _cx + width / 2 + "px " + (anchorY - _cy + height / 2) + "px",
            transform: transform
          }
        });
      } else if (type === Shape.IMAGE) {
        var _width = shape.width,
          _height = shape.height,
          src = shape.src;
        displayObject = new Image({
          style: {
            x: 0,
            y: 0,
            width: _width,
            height: _height,
            src: src,
            transformOrigin: anchorX + "px " + anchorY + "px",
            transform: transform
          }
        });
      }
      if (name) {
        displayObject.name = name;
      }
      // TODO: match name `mn`, used in expressions
      if (style) {
        // { fill, fillOpacity, fillRule, opacity, lineDash, lineDashOffset }
        displayObject.attr(style);
      }
      if (keyframeAnimation) {
        this.keyframeAnimationMap.set(displayObject, keyframeAnimation);
      }
      if (children) {
        var _displayObject;
        var childNodes = children.map(function (child) {
          return _this2.buildHierachy(child);
        });
        (_displayObject = displayObject).append.apply(_displayObject, childNodes);
      }
      this.displayObjectElementMap.set(displayObject, element);
      return displayObject;
    };
    _proto.getAnimations = function getAnimations() {
      return this.animations;
    }
    /**
     * Returns the animation duration in seconds or frames.
     * @see https://github.com/airbnb/lottie-web#getdurationinframes
     */;
    _proto.getDuration = function getDuration(inFrames) {
      if (inFrames === void 0) {
        inFrames = false;
      }
      return (inFrames ? this.fps() : 1) * (this.context.endFrame - this.context.startFrame) * this.context.frameTime / 1000;
    }
    /**
     * Returns the animation frame rate (frames / second).
     */;
    _proto.fps = function fps() {
      return this.context.fps;
    };
    _proto.isSameKeyframeOptions = function isSameKeyframeOptions(options1, options2) {
      return options1.delay === options2.delay && options1.duration === options2.duration && options1.easing === options2.easing;
    };
    _proto.isSameKeyframes = function isSameKeyframes(keyframe1, keyframe2) {
      // const { offset: o1, easing: e1, ...rest1 } = keyframe1;
      // const { offset: o2, easing: e2, ...rest2 } = keyframe2;
      // const isAllApplyToTransform =
      //   Object.keys(rest1).every((key) =>
      //     ['x', 'y', 'scaleX', 'scaleY', 'rotation'].includes(key),
      //   ) &&
      //   Object.keys(rest2).every((key) =>
      //     ['x', 'y', 'scaleX', 'scaleY', 'rotation'].includes(key),
      //   );
      return keyframe1.offset === keyframe2.offset && keyframe1.easing === keyframe2.easing
      // (keyframe1.easing === keyframe2.easing || isAllApplyToTransform)
      ;
    };
    _proto.generatePathFromShape = function generatePathFromShape(shape) {
      // @see https://lottiefiles.github.io/lottie-docs/shapes/#path
      var close = shape.close,
        v = shape.v,
        i = shape.in,
        out = shape.out;
      var d = [];
      d.push(['M', v[0][0], v[0][1]]);
      for (var n = 1; n < v.length; n++) {
        // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier
        // The nth bezier segment is defined as:
        // v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1]
        d.push(['C', out[n - 1][0], out[n - 1][1], i[n][0], i[n][1], v[n][0], v[n][1]]);
      }
      if (close) {
        d.push(['C', out[v.length - 1][0], out[v.length - 1][1], i[0][0], i[0][1], v[0][0], v[0][1]]);
        d.push(['Z']);
      }
      return d;
    }
    /**
     * render Lottie Group to canvas or a mounted display object
     */;
    _proto.render = function render(canvasOrDisplayObject) {
      var _this3 = this;
      var wrapper = new Group();
      wrapper.append.apply(wrapper, this.displayObjects);
      if (isCanvas(canvasOrDisplayObject)) {
        canvasOrDisplayObject.appendChild(wrapper);
      } else if (isDisplayObject(canvasOrDisplayObject)) {
        if (!canvasOrDisplayObject.isConnected) {
          throw new Error('[g-lottie-player]: Cannot render Lottie to an unmounted DisplayObject.');
        } else {
          canvasOrDisplayObject.appendChild(wrapper);
        }
      } else {
        throw new Error('[g-lottie-player]: We should render Lottie to a mounted DisplayObject or Canvas.');
      }
      this.displayObjects.forEach(function (parent) {
        parent.forEach(function (child) {
          var keyframeAnimation = _this3.keyframeAnimationMap.get(child);
          // console.log('keyframeAnimation', keyframeAnimation);
          var element = _this3.displayObjectElementMap.get(child);
          if (element && element.clipPath) {
            var _element$clipPath = element.clipPath,
              shape = _element$clipPath.shape,
              _keyframeAnimation = _element$clipPath.keyframeAnimation;
            var clipPath = new Path();
            // use clipPath as target's siblings
            child.parentElement.appendChild(clipPath);
            child.style.clipPath = clipPath;
            if (shape) {
              clipPath.style.d = _this3.generatePathFromShape(shape);
            }
            // TODO: only support one clipPath now
            if (_keyframeAnimation && _keyframeAnimation.length) {
              var _keyframeAnimation$ = _keyframeAnimation[0],
                delay = _keyframeAnimation$.delay,
                duration = _keyframeAnimation$.duration,
                easing = _keyframeAnimation$.easing,
                keyframes = _keyframeAnimation$.keyframes;
              // animate clipPath with its `d` property
              var clipPathAnimation = clipPath.animate(keyframes.map(function (_ref) {
                var offset = _ref.offset,
                  shape = _ref.shape,
                  easing = _ref.easing;
                return {
                  offset: offset,
                  d: path2String(_this3.generatePathFromShape(shape)),
                  easing: easing
                };
              }), {
                delay: delay,
                duration: duration,
                easing: easing,
                iterations: _this3.context.iterations
              });
              _this3.animations.push(clipPathAnimation);
            }
          }
          // account for animation only apply to visibility, e.g. spring
          var visibilityStartOffset = element.visibilityStartOffset,
            visibilityEndOffset = element.visibilityEndOffset,
            visibilityFrame = element.visibilityFrame;
          if (visibilityFrame && (!keyframeAnimation || !keyframeAnimation.length)) {
            keyframeAnimation = [{
              duration: _this3.context.frameTime * visibilityFrame,
              keyframes: [{
                offset: 0,
                style: {
                  opacity: 1
                }
              }, {
                offset: 1,
                style: {
                  opacity: 1
                }
              }]
            }];
          }
          if (keyframeAnimation && keyframeAnimation.length) {
            var _this3$animations;
            var keyframesOptions = [];
            keyframeAnimation.map(function (_ref2) {
              var _ref2$delay = _ref2.delay,
                delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
                duration = _ref2.duration,
                easing = _ref2.easing,
                keyframes = _ref2.keyframes;
              var formattedKeyframes = keyframes.map(function (keyframe) {
                return definedProps(keyframe);
              });
              var options = definedProps({
                delay: delay,
                duration: duration,
                easing: easing,
                iterations: _this3.context.iterations,
                fill: _this3.context.fill
              });
              keyframesOptions.push([formattedKeyframes, options]);
            });
            var mergedKeyframesOptions = [keyframesOptions[0]];
            // merge [{ offset: 0, cx: 1 }, { offset: 0, cy: 1 }] into { offset: 0, cx: 1, cy: 1 }
            var _loop = function _loop() {
              var _keyframesOptions$i = keyframesOptions[i],
                currentKeyframes = _keyframesOptions$i[0],
                currentOptions = _keyframesOptions$i[1];
              // can merge options?
              var existedKeyframeOptions = mergedKeyframesOptions.find(function (_ref4) {
                var keyframes = _ref4[0],
                  options = _ref4[1];
                return keyframes.length === currentKeyframes.length && _this3.isSameKeyframeOptions(currentOptions, options);
              });
              if (existedKeyframeOptions) {
                currentKeyframes.forEach(function (currentKeyframe) {
                  var existedKeyframe = existedKeyframeOptions[0].find(function (keyframe) {
                    return _this3.isSameKeyframes(currentKeyframe, keyframe);
                  });
                  if (existedKeyframe) {
                    var offset = currentKeyframe.offset,
                      _currentKeyframe$easi = currentKeyframe.easing,
                      rest = _objectWithoutPropertiesLoose$1(currentKeyframe, _excluded$c);
                    // merge interpolated properties
                    Object.assign(existedKeyframe, rest);
                  } else {
                    // append if cannot be merged
                    existedKeyframeOptions[0].push(currentKeyframe);
                  }
                });
              } else {
                // cannot be merged since options are different
                mergedKeyframesOptions.push(keyframesOptions[i]);
              }
            };
            for (var i = 1; i < keyframesOptions.length; i++) {
              _loop();
            }
            // restore animations for later use
            (_this3$animations = _this3.animations).push.apply(_this3$animations, mergedKeyframesOptions.map(function (_ref3) {
              var merged = _ref3[0],
                options = _ref3[1];
              // format interpolated properties, e.g. scaleX -> transform
              var formatted = _this3.formatKeyframes(merged, child);
              if (formatted.length) {
                // console.log(child, formatted);
                var animation = child.animate(formatted, options);
                if (!isNil(visibilityStartOffset) && !isNil(visibilityEndOffset)) {
                  child.style.visibility = 'hidden';
                  animation.onframe = function () {
                    var _animation$effect$get = animation.effect.getComputedTiming(),
                      progress = _animation$effect$get.progress;
                    if (progress >= visibilityStartOffset && progress < visibilityEndOffset) {
                      child.style.visibility = 'visible';
                    } else {
                      child.style.visibility = 'hidden';
                    }
                  };
                }
                if (!_this3.context.autoplay) {
                  animation.pause();
                }
                return animation;
              }
            }).filter(function (animation) {
              return !!animation;
            }));
          }
        });
      });
      return wrapper;
    };
    _proto.formatKeyframes = function formatKeyframes(keyframes, object) {
      keyframes.forEach(function (keyframe) {
        // if ('offsetPath' in keyframe) {
        //   if (!object.style.offsetPath) {
        //     const [ox, oy] = object.getOrigin();
        //     (keyframe.offsetPath as AbsoluteArray).forEach((segment) => {
        //       if (segment[0] === 'M') {
        //         segment[1] -= ox;
        //         segment[2] -= oy;
        //       } else if (segment[0] === 'C') {
        //         segment[1] -= ox;
        //         segment[2] -= oy;
        //         segment[3] -= ox;
        //         segment[4] -= oy;
        //         segment[5] -= ox;
        //         segment[6] -= oy;
        //       }
        //     });
        //     const offsetPath = new Path({
        //       style: {
        //         d: keyframe.offsetPath,
        //       },
        //     });
        //     object.style.offsetPath = offsetPath;
        //     console.log(offsetPath);
        //   }
        //   delete keyframe.offsetPath;
        //   // offsetPath should override x/y
        //   delete keyframe.x;
        //   delete keyframe.y;
        // }
        // should keep transform during initialization
        // if (!object.style.offsetPath) {
        //   keyframe.transform = object.style.transform || '';
        // }
        keyframe.transform = object.style.transform || '';
        // TODO: transforms with different easing functions will conflict
        if ('scaleX' in keyframe) {
          keyframe.transform = (keyframe.transform || '') + (" scaleX(" + (keyframe.scaleX === 0 ? eps : keyframe.scaleX) + ")");
          delete keyframe.scaleX;
        }
        if ('scaleY' in keyframe) {
          keyframe.transform = (keyframe.transform || '') + (" scaleY(" + (keyframe.scaleY === 0 ? eps : keyframe.scaleY) + ")");
          delete keyframe.scaleY;
        }
        if ('rotation' in keyframe) {
          keyframe.transform = (keyframe.transform || '') + (" rotate(" + keyframe.rotation + "deg)");
          delete keyframe.rotation;
        }
        // TODO: skew & skewAxis
        // if ('skew' in keyframe) {
        //   keyframe.transform = (keyframe.transform || '') + ` skew(${keyframe.skew}deg)`;
        //   delete keyframe.skew;
        // }
        if ('x' in keyframe) {
          keyframe.transform = (keyframe.transform || '') + (" translateX(" + keyframe.x + "px)");
          delete keyframe.x;
        }
        if ('y' in keyframe) {
          keyframe.transform = (keyframe.transform || '') + (" translateY(" + keyframe.y + "px)");
          delete keyframe.y;
        }
        // { style: { opacity: 1 } }
        if ('style' in keyframe) {
          Object.keys(keyframe.style).forEach(function (name) {
            keyframe[name] = keyframe.style[name];
          });
          delete keyframe.style;
        }
      });
      // ignore empty interpolable attributes
      keyframes = keyframes.filter(function (keyframe) {
        // TODO: support negative offset
        var ignore = keyframe.ignore,
          easing = keyframe.easing,
          offset = keyframe.offset,
          rest = _objectWithoutPropertiesLoose$1(keyframe, _excluded2);
        return offset >= 0 && Object.keys(rest).length > 0;
        // return Object.keys(rest).length > 0;
      });

      if (keyframes.length) {
        // padding offset = 1
        if (keyframes[keyframes.length - 1].offset !== 1) {
          keyframes.push(_extends$3({}, keyframes[keyframes.length - 1], {
            offset: 1
          }));
        }
      }
      // sort by offset
      keyframes.sort(function (a, b) {
        return a.offset - b.offset;
      });
      // remove empty attributes
      keyframes.forEach(function (keyframe) {
        Object.keys(keyframe).forEach(function (name) {
          if (keyframe[name] === '') {
            delete keyframe[name];
          }
        });
      });
      return keyframes;
    }
    /**
     * Destroy all internal displayobjects.
     */;
    _proto.destroy = function destroy() {
      this.displayObjects.forEach(function (object) {
        object.destroy();
      });
    }
    /**
     * Return the size of this animation.
     * @param outputSize - If provided, the size will be copied into here as width, height.
     */;
    _proto.size = function size(outputSize) {
      return {
        width: this.width,
        height: this.height
      };
    }
    /**
     * Bodymovin version
     */;
    _proto.version = function version() {
      return this.context.version;
    };
    _proto.play = function play() {
      this.isPaused = false;
      this.animations.forEach(function (animation) {
        animation.play();
      });
    }
    /**
     * Can contain 2 numeric values that will be used as first and last frame of the animation.
     * @see https://github.com/airbnb/lottie-web#playsegmentssegments-forceflag
     */;
    _proto.playSegments = function playSegments(segments) {
      var _this4 = this;
      var firstFrame = segments[0],
        lastFrame = segments[1];
      this.isPaused = false;
      this.animations.forEach(function (animation) {
        animation.currentTime = firstFrame / _this4.fps() * 1000;
        var originOnFrame = animation.onframe;
        animation.onframe = function (e) {
          if (originOnFrame) {
            // @ts-ignore
            originOnFrame(e);
          }
          if (animation.currentTime >= lastFrame / _this4.fps() * 1000) {
            animation.finish();
            if (originOnFrame) {
              animation.onframe = originOnFrame;
            } else {
              animation.onframe = null;
            }
          }
        };
        animation.play();
      });
    };
    _proto.pause = function pause() {
      this.isPaused = true;
      this.animations.forEach(function (animation) {
        animation.pause();
      });
    }
    /**
     *
     */;
    _proto.togglePause = function togglePause() {
      if (this.isPaused) {
        this.play();
      } else {
        this.pause();
      }
    }
    /**
     * Goto and stop at a specific time(in seconds) or frame.
     * Split goToAndStop/Play into goTo & stop/play
     * @see https://github.com/airbnb/lottie-web
     */;
    _proto.goTo = function goTo(value, isFrame) {
      var _this5 = this;
      if (isFrame === void 0) {
        isFrame = false;
      }
      if (isFrame) {
        this.animations.forEach(function (animation) {
          animation.currentTime = value / _this5.fps() * 1000;
        });
      } else {
        this.animations.forEach(function (animation) {
          animation.currentTime = value * 1000;
        });
      }
    }
    /**
     * @see https://github.com/airbnb/lottie-web#stop
     */;
    _proto.stop = function stop() {
      this.animations.forEach(function (animation) {
        animation.finish();
      });
    }
    /**
     * 1 is normal speed.
     * @see https://github.com/airbnb/lottie-web#setspeedspeed
     */;
    _proto.setSpeed = function setSpeed(speed) {
      var _this6 = this;
      this.animations.forEach(function (animation) {
        animation.playbackRate = speed * _this6.direction;
      });
    };
    /**
     * 1 is forward, -1 is reverse.
     * @see https://github.com/airbnb/lottie-web#setdirectiondirection
     */
    _proto.setDirection = function setDirection(direction) {
      this.direction = direction;
      this.animations.forEach(function (animation) {
        animation.playbackRate *= direction;
      });
    };
    return LottieAnimation;
  }();

  /**
   * borrow from https://github.com/airbnb/lottie-web/blob/master/player/js/utils/DataManager.js#L40-L493
   */
  function completeLayers(layers, comps) {
    var layerData;
    var i;
    var len = layers.length;
    var j;
    var jLen;
    var k;
    var kLen;
    for (i = 0; i < len; i += 1) {
      layerData = layers[i];
      if ('ks' in layerData && !layerData.completed) {
        layerData.completed = true;
        if (layerData.tt) {
          layers[i - 1].td = layerData.tt;
        }
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              convertPathsToAbsoluteValues(maskProps[j].pt.k);
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                }
                if (maskProps[j].pt.k[k].e) {
                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                }
              }
            }
          }
        }
        if (layerData.ty === 0) {
          layerData.layers = findCompLayers(layerData.refId, comps);
          completeLayers(layerData.layers, comps);
        } else if (layerData.ty === 4) {
          completeShapes(layerData.shapes);
        } else if (layerData.ty === 5) {
          completeText(layerData);
        }
      }
    }
  }
  function completeChars(chars, assets) {
    if (chars) {
      var i = 0;
      var len = chars.length;
      for (i = 0; i < len; i += 1) {
        if (chars[i].t === 1) {
          // var compData = findComp(chars[i].data.refId, assets);
          chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);
          // chars[i].data.ip = 0;
          // chars[i].data.op = 99999;
          // chars[i].data.st = 0;
          // chars[i].data.sr = 1;
          // chars[i].w = compData.w;
          // chars[i].data.ks = {
          //   a: { k: [0, 0, 0], a: 0 },
          //   p: { k: [0, -compData.h, 0], a: 0 },
          //   r: { k: 0, a: 0 },
          //   s: { k: [100, 100], a: 0 },
          //   o: { k: 100, a: 0 },
          // };
          completeLayers(chars[i].data.layers, assets);
        }
      }
    }
  }
  function findComp(id, comps) {
    var i = 0;
    var len = comps.length;
    while (i < len) {
      if (comps[i].id === id) {
        return comps[i];
      }
      i += 1;
    }
    return null;
  }
  function findCompLayers(id, comps) {
    var comp = findComp(id, comps);
    if (comp) {
      if (!comp.layers.__used) {
        comp.layers.__used = true;
        return comp.layers;
      }
      return JSON.parse(JSON.stringify(comp.layers));
    }
    return null;
  }
  function completeShapes(arr) {
    var i;
    var len = arr.length;
    var j;
    var jLen;
    for (i = len - 1; i >= 0; i -= 1) {
      if (arr[i].ty === 'sh') {
        if (arr[i].ks.k.i) {
          convertPathsToAbsoluteValues(arr[i].ks.k);
        } else {
          jLen = arr[i].ks.k.length;
          for (j = 0; j < jLen; j += 1) {
            if (arr[i].ks.k[j].s) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
            }
            if (arr[i].ks.k[j].e) {
              convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
            }
          }
        }
      } else if (arr[i].ty === 'gr') {
        completeShapes(arr[i].it);
      }
    }
  }
  function convertPathsToAbsoluteValues(path) {
    var i;
    var len = path.i.length;
    for (i = 0; i < len; i += 1) {
      path.i[i][0] += path.v[i][0];
      path.i[i][1] += path.v[i][1];
      path.o[i][0] += path.v[i][0];
      path.o[i][1] += path.v[i][1];
    }
  }
  function checkVersion(minimum, animVersionString) {
    var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
    if (minimum[0] > animVersion[0]) {
      return true;
    }
    if (animVersion[0] > minimum[0]) {
      return false;
    }
    if (minimum[1] > animVersion[1]) {
      return true;
    }
    if (animVersion[1] > minimum[1]) {
      return false;
    }
    if (minimum[2] > animVersion[2]) {
      return true;
    }
    if (animVersion[2] > minimum[2]) {
      return false;
    }
    return null;
  }
  var checkText = function () {
    var minimumVersion = [4, 4, 14];
    function updateTextLayer(textLayer) {
      var documentData = textLayer.t.d;
      textLayer.t.d = {
        k: [{
          s: documentData,
          t: 0
        }]
      };
    }
    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 5) {
          updateTextLayer(layers[i]);
        }
      }
    }
    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }();
  var checkChars = function () {
    var minimumVersion = [4, 7, 99];
    return function (animationData) {
      if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
        var i;
        var len = animationData.chars.length;
        for (i = 0; i < len; i += 1) {
          var charData = animationData.chars[i];
          if (charData.data && charData.data.shapes) {
            completeShapes(charData.data.shapes);
            charData.data.ip = 0;
            charData.data.op = 99999;
            charData.data.st = 0;
            charData.data.sr = 1;
            charData.data.ks = {
              p: {
                k: [0, 0],
                a: 0
              },
              s: {
                k: [100, 100],
                a: 0
              },
              a: {
                k: [0, 0],
                a: 0
              },
              r: {
                k: 0,
                a: 0
              },
              o: {
                k: 100,
                a: 0
              }
            };
            if (!animationData.chars[i].t) {
              charData.data.shapes.push({
                ty: 'no'
              });
              charData.data.shapes[0].it.push({
                p: {
                  k: [0, 0],
                  a: 0
                },
                s: {
                  k: [100, 100],
                  a: 0
                },
                a: {
                  k: [0, 0],
                  a: 0
                },
                r: {
                  k: 0,
                  a: 0
                },
                o: {
                  k: 100,
                  a: 0
                },
                sk: {
                  k: 0,
                  a: 0
                },
                sa: {
                  k: 0,
                  a: 0
                },
                ty: 'tr'
              });
            }
          }
        }
      }
    };
  }();
  var checkPathProperties = function () {
    var minimumVersion = [5, 7, 15];
    function updateTextLayer(textLayer) {
      var pathData = textLayer.t.p;
      if (typeof pathData.a === 'number') {
        pathData.a = {
          a: 0,
          k: pathData.a
        };
      }
      if (typeof pathData.p === 'number') {
        pathData.p = {
          a: 0,
          k: pathData.p
        };
      }
      if (typeof pathData.r === 'number') {
        pathData.r = {
          a: 0,
          k: pathData.r
        };
      }
    }
    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 5) {
          updateTextLayer(layers[i]);
        }
      }
    }
    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }();
  var checkColors = function () {
    var minimumVersion = [4, 1, 9];
    function iterateShapes(shapes) {
      var i;
      var len = shapes.length;
      var j;
      var jLen;
      for (i = 0; i < len; i += 1) {
        if (shapes[i].ty === 'gr') {
          iterateShapes(shapes[i].it);
        } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
          if (shapes[i].c.k && shapes[i].c.k[0].i) {
            jLen = shapes[i].c.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (shapes[i].c.k[j].s) {
                shapes[i].c.k[j].s[0] /= 255;
                shapes[i].c.k[j].s[1] /= 255;
                shapes[i].c.k[j].s[2] /= 255;
                shapes[i].c.k[j].s[3] /= 255;
              }
              if (shapes[i].c.k[j].e) {
                shapes[i].c.k[j].e[0] /= 255;
                shapes[i].c.k[j].e[1] /= 255;
                shapes[i].c.k[j].e[2] /= 255;
                shapes[i].c.k[j].e[3] /= 255;
              }
            }
          } else {
            shapes[i].c.k[0] /= 255;
            shapes[i].c.k[1] /= 255;
            shapes[i].c.k[2] /= 255;
            shapes[i].c.k[3] /= 255;
          }
        }
      }
    }
    function iterateLayers(layers) {
      var i;
      var len = layers.length;
      for (i = 0; i < len; i += 1) {
        if (layers[i].ty === 4) {
          iterateShapes(layers[i].shapes);
        }
      }
    }
    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }();
  var checkShapes = function () {
    var minimumVersion = [4, 4, 18];
    function completeClosingShapes(arr) {
      var i;
      var len = arr.length;
      var j;
      var jLen;
      for (i = len - 1; i >= 0; i -= 1) {
        if (arr[i].ty === 'sh') {
          if (arr[i].ks.k.i) {
            arr[i].ks.k.c = arr[i].closed;
          } else {
            jLen = arr[i].ks.k.length;
            for (j = 0; j < jLen; j += 1) {
              if (arr[i].ks.k[j].s) {
                arr[i].ks.k[j].s[0].c = arr[i].closed;
              }
              if (arr[i].ks.k[j].e) {
                arr[i].ks.k[j].e[0].c = arr[i].closed;
              }
            }
          }
        } else if (arr[i].ty === 'gr') {
          completeClosingShapes(arr[i].it);
        }
      }
    }
    function iterateLayers(layers) {
      var layerData;
      var i;
      var len = layers.length;
      var j;
      var jLen;
      var k;
      var kLen;
      for (i = 0; i < len; i += 1) {
        layerData = layers[i];
        if (layerData.hasMask) {
          var maskProps = layerData.masksProperties;
          jLen = maskProps.length;
          for (j = 0; j < jLen; j += 1) {
            if (maskProps[j].pt.k.i) {
              maskProps[j].pt.k.c = maskProps[j].cl;
            } else {
              kLen = maskProps[j].pt.k.length;
              for (k = 0; k < kLen; k += 1) {
                if (maskProps[j].pt.k[k].s) {
                  maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                }
                if (maskProps[j].pt.k[k].e) {
                  maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                }
              }
            }
          }
        }
        if (layerData.ty === 4) {
          completeClosingShapes(layerData.shapes);
        }
      }
    }
    return function (animationData) {
      if (checkVersion(minimumVersion, animationData.v)) {
        iterateLayers(animationData.layers);
        if (animationData.assets) {
          var i;
          var len = animationData.assets.length;
          for (i = 0; i < len; i += 1) {
            if (animationData.assets[i].layers) {
              iterateLayers(animationData.assets[i].layers);
            }
          }
        }
      }
    };
  }();
  function completeData(animationData) {
    if (animationData.__complete) {
      return;
    }
    checkColors(animationData);
    checkText(animationData);
    checkChars(animationData);
    checkPathProperties(animationData);
    checkShapes(animationData);
    completeLayers(animationData.layers, animationData.assets);
    completeChars(animationData.chars, animationData.assets);
    animationData.__complete = true;
  }
  function completeText(data) {
    if (data.t.a.length === 0 && !('m' in data.t.p)) ;
  }

  /**
   * https://lottiefiles.github.io/lottie-docs/constants/
   */
  var BlendMode;
  (function (BlendMode) {
    BlendMode[BlendMode["Normal"] = 0] = "Normal";
    BlendMode[BlendMode["Multiply"] = 1] = "Multiply";
    BlendMode[BlendMode["Screen"] = 2] = "Screen";
    BlendMode[BlendMode["Overlay"] = 3] = "Overlay";
    BlendMode[BlendMode["Darken"] = 4] = "Darken";
    BlendMode[BlendMode["Lighten"] = 5] = "Lighten";
    BlendMode[BlendMode["ColorDodge"] = 6] = "ColorDodge";
    BlendMode[BlendMode["ColorBurn"] = 7] = "ColorBurn";
    BlendMode[BlendMode["HardLight"] = 8] = "HardLight";
    BlendMode[BlendMode["SoftLight"] = 9] = "SoftLight";
    BlendMode[BlendMode["Difference"] = 10] = "Difference";
    BlendMode[BlendMode["Exclusion"] = 11] = "Exclusion";
    BlendMode[BlendMode["Hue"] = 12] = "Hue";
    BlendMode[BlendMode["Saturation"] = 13] = "Saturation";
    BlendMode[BlendMode["Color"] = 14] = "Color";
    BlendMode[BlendMode["Luminosity"] = 15] = "Luminosity";
    BlendMode[BlendMode["Add"] = 16] = "Add";
    BlendMode[BlendMode["HardMix"] = 17] = "HardMix";
  })(BlendMode || (BlendMode = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/constants/#mattemode
   */
  var MatteMode;
  (function (MatteMode) {
    MatteMode[MatteMode["Normal"] = 0] = "Normal";
    MatteMode[MatteMode["Alpha"] = 1] = "Alpha";
    MatteMode[MatteMode["InvertedAlpha"] = 2] = "InvertedAlpha";
    MatteMode[MatteMode["Luma"] = 3] = "Luma";
    MatteMode[MatteMode["InvertedLuma"] = 4] = "InvertedLuma";
  })(MatteMode || (MatteMode = {}));
  var Layer3DMode;
  (function (Layer3DMode) {
    Layer3DMode[Layer3DMode["Off"] = 0] = "Off";
    Layer3DMode[Layer3DMode["On"] = 1] = "On";
  })(Layer3DMode || (Layer3DMode = {}));
  var AutoOrientMode;
  (function (AutoOrientMode) {
    AutoOrientMode[AutoOrientMode["Off"] = 0] = "Off";
    AutoOrientMode[AutoOrientMode["On"] = 1] = "On";
  })(AutoOrientMode || (AutoOrientMode = {}));
  var EffectValueType;
  (function (EffectValueType) {
    EffectValueType[EffectValueType["Number"] = 0] = "Number";
    EffectValueType[EffectValueType["Color"] = 2] = "Color";
    EffectValueType[EffectValueType["MultiDimensional"] = 3] = "MultiDimensional";
    EffectValueType[EffectValueType["Boolean"] = 7] = "Boolean";
  })(EffectValueType || (EffectValueType = {}));
  var EffectType;
  (function (EffectType) {
    EffectType[EffectType["Transform"] = 5] = "Transform";
    EffectType[EffectType["DropShadow"] = 25] = "DropShadow";
  })(EffectType || (EffectType = {}));
  var LayerType;
  (function (LayerType) {
    LayerType[LayerType["precomp"] = 0] = "precomp";
    LayerType[LayerType["solid"] = 1] = "solid";
    LayerType[LayerType["image"] = 2] = "image";
    LayerType[LayerType["null"] = 3] = "null";
    LayerType[LayerType["shape"] = 4] = "shape";
    LayerType[LayerType["text"] = 5] = "text";
    LayerType[LayerType["audio"] = 6] = "audio";
    LayerType[LayerType["pholderVideo"] = 7] = "pholderVideo";
    LayerType[LayerType["imageSeq"] = 8] = "imageSeq";
    LayerType[LayerType["video"] = 9] = "video";
    LayerType[LayerType["pholderStill"] = 10] = "pholderStill";
    LayerType[LayerType["guide"] = 11] = "guide";
    LayerType[LayerType["adjustment"] = 12] = "adjustment";
    LayerType[LayerType["camera"] = 13] = "camera";
    LayerType[LayerType["light"] = 14] = "light";
    LayerType[LayerType["data"] = 15] = "data";
  })(LayerType || (LayerType = {}));
  var TextJustify;
  (function (TextJustify) {
    TextJustify[TextJustify["Left"] = 0] = "Left";
    TextJustify[TextJustify["Right"] = 1] = "Right";
    TextJustify[TextJustify["Center"] = 2] = "Center";
  })(TextJustify || (TextJustify = {}));
  var VerticalJustify;
  (function (VerticalJustify) {
    VerticalJustify[VerticalJustify["Top"] = 0] = "Top";
    VerticalJustify[VerticalJustify["Center"] = 1] = "Center";
    VerticalJustify[VerticalJustify["Bottom"] = 2] = "Bottom";
  })(VerticalJustify || (VerticalJustify = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/shapes/#shape-types
   */
  var ShapeType;
  (function (ShapeType) {
    ShapeType["Rectangle"] = "rc";
    ShapeType["Ellipse"] = "el";
    ShapeType["PolyStar"] = "sr";
    ShapeType["Path"] = "sh";
    ShapeType["Fill"] = "fl";
    ShapeType["Stroke"] = "st";
    ShapeType["GradientFill"] = "gf";
    ShapeType["GradientStroke"] = "gs";
    ShapeType["NoStyle"] = "no";
    ShapeType["Group"] = "gr";
    ShapeType["Transform"] = "tr";
    ShapeType["Repeater"] = "rp";
    ShapeType["Trim"] = "tm";
    ShapeType["RoundedCorners"] = "rd";
    ShapeType["PuckerOrBloat"] = "pb";
    ShapeType["Merge"] = "mm";
    ShapeType["Twist"] = "tw";
    ShapeType["OffsetPath"] = "op";
    ShapeType["ZigZag"] = "zz";
  })(ShapeType || (ShapeType = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/constants/#fillrule
   */
  var FillRule;
  (function (FillRule) {
    FillRule[FillRule["NonZero"] = 1] = "NonZero";
    FillRule[FillRule["EvenOdd"] = 2] = "EvenOdd";
  })(FillRule || (FillRule = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/constants/#linejoin
   */
  var LineJoin;
  (function (LineJoin) {
    LineJoin[LineJoin["Miter"] = 1] = "Miter";
    LineJoin[LineJoin["Round"] = 2] = "Round";
    LineJoin[LineJoin["Bevel"] = 3] = "Bevel";
  })(LineJoin || (LineJoin = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/constants/#linecap
   */
  var LineCap;
  (function (LineCap) {
    LineCap[LineCap["Butt"] = 1] = "Butt";
    LineCap[LineCap["Round"] = 2] = "Round";
    LineCap[LineCap["Square"] = 3] = "Square";
  })(LineCap || (LineCap = {}));
  /**
   * @see https://lottiefiles.github.io/lottie-docs/constants/#gradienttype
   */
  var GradientType$1;
  (function (GradientType) {
    GradientType[GradientType["Linear"] = 1] = "Linear";
    GradientType[GradientType["Radial"] = 2] = "Radial";
  })(GradientType$1 || (GradientType$1 = {}));
  var FontPathOrigin;
  (function (FontPathOrigin) {
    FontPathOrigin[FontPathOrigin["CssUrl"] = 1] = "CssUrl";
    FontPathOrigin[FontPathOrigin["ScriptUrl"] = 2] = "ScriptUrl";
    FontPathOrigin[FontPathOrigin["FontUrl"] = 3] = "FontUrl";
  })(FontPathOrigin || (FontPathOrigin = {}));

  var ParseContext = function ParseContext() {
    this.fps = void 0;
    this.frameTime = 1000 / 30;
    this.startFrame = 0;
    this.endFrame = void 0;
    this.version = void 0;
    this.autoplay = false;
    this.fill = 'auto';
    this.iterations = 0;
    this.assetsMap = new Map();
    this.layerOffsetTime = void 0;
  };
  function isNumberArray(val) {
    return Array.isArray(val) && typeof val[0] === 'number';
  }
  function isMultiDimensionalValue(val) {
    return isNumberArray(val === null || val === void 0 ? void 0 : val.k);
  }
  function isMultiDimensionalKeyframedValue(val) {
    var k = val === null || val === void 0 ? void 0 : val.k;
    return Array.isArray(k) && k[0].t !== undefined && isNumberArray(k[0].s);
  }
  function isValue(val) {
    // TODO is [100] sort of value?
    return typeof (val === null || val === void 0 ? void 0 : val.k) === 'number';
  }
  function isKeyframedValue(val) {
    var k = val === null || val === void 0 ? void 0 : val.k;
    return Array.isArray(k) && k[0].t !== undefined && typeof k[0].s === 'number';
  }
  function toColorString(val) {
    var opacity = getMultiDimensionValue(val, 3);
    return "rgba(" + [Math.round(getMultiDimensionValue(val, 0) * 255), Math.round(getMultiDimensionValue(val, 1) * 255), Math.round(getMultiDimensionValue(val, 2) * 255), !isNil(opacity) ? opacity : 1].join(',') + ")";
  }
  function getMultiDimensionValue(val, dimIndex) {
    return val != null ? typeof val === 'number' ? val : val[dimIndex || 0] : NaN;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/concepts/#easing-handles
   */
  function getMultiDimensionEasingBezierString(kf, nextKf, dimIndex) {
    var _kf$o, _kf$o2, _kf$i, _kf$i2;
    var bezierEasing = [];
    bezierEasing.push(((_kf$o = kf.o) === null || _kf$o === void 0 ? void 0 : _kf$o.x) && (getMultiDimensionValue(kf.o.x, dimIndex) || getMultiDimensionValue(kf.o.x, 0)) || 0, ((_kf$o2 = kf.o) === null || _kf$o2 === void 0 ? void 0 : _kf$o2.y) && (getMultiDimensionValue(kf.o.y, dimIndex) || getMultiDimensionValue(kf.o.y, 0)) || 0, ((_kf$i = kf.i) === null || _kf$i === void 0 ? void 0 : _kf$i.x) && (getMultiDimensionValue(kf.i.x, dimIndex) || getMultiDimensionValue(kf.i.x, 0)) || 1, ((_kf$i2 = kf.i) === null || _kf$i2 === void 0 ? void 0 : _kf$i2.y) && (getMultiDimensionValue(kf.i.y, dimIndex) || getMultiDimensionValue(kf.i.y, 0)) || 1);
    // linear by default
    if (!(bezierEasing[0] === 0 && bezierEasing[1] === 0 && bezierEasing[2] === 1 && bezierEasing[3] === 1)) {
      return "cubic-bezier(" + bezierEasing.join(',') + ")";
    }
    return;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/concepts/#keyframe
   */
  function parseKeyframe(kfs, bezierEasingDimIndex, context, setVal) {
    var kfsLen = kfs.length;
    // const offset = context.layerStartTime;
    var duration = context.endFrame - context.startFrame;
    var out = {
      duration: 0,
      delay: 0,
      keyframes: []
    };
    var prevKf;
    for (var i = 0; i < kfsLen; i++) {
      var _prevKf;
      var kf = kfs[i];
      var nextKf = kfs[i + 1];
      // If h is present and it's 1, you don't need i and o,
      // as the property will keep the same value until the next keyframe.
      var isDiscrete = kf.h === 1;
      var offset = (kf.t + context.layerOffsetTime - context.startFrame) / duration;
      var outKeyframe = {
        offset: offset
      };
      if (!isDiscrete) {
        outKeyframe.easing = getMultiDimensionEasingBezierString(kf, nextKf, bezierEasingDimIndex);
      }
      // Use end state of later frame if start state not exits.
      // @see https://lottiefiles.github.io/lottie-docs/concepts/#old-lottie-keyframes
      var startVal = kf.s || ((_prevKf = prevKf) === null || _prevKf === void 0 ? void 0 : _prevKf.e);
      if (startVal) {
        setVal(outKeyframe, startVal);
      }
      if (outKeyframe.offset > 0 && i === 0) {
        // Set initial
        var initialKeyframe = {
          offset: 0
        };
        if (startVal) {
          setVal(initialKeyframe, startVal);
        }
        out.keyframes.push(initialKeyframe);
      }
      out.keyframes.push(outKeyframe);
      if (isDiscrete && nextKf) {
        // Use two keyframe to simulate the discrete animation.
        var extraKeyframe = {
          offset: Math.max((nextKf.t + context.layerOffsetTime - context.startFrame) / duration, 0)
        };
        setVal(extraKeyframe, startVal);
        out.keyframes.push(extraKeyframe);
      }
      prevKf = kf;
    }
    if (kfsLen) {
      out.duration = context.frameTime * duration;
    }
    return out;
  }
  function parseOffsetKeyframe(kfs, targetPropName, propNames, keyframeAnimations, context, convertVal) {
    var _loop = function _loop(dimIndex) {
      var propName = propNames[dimIndex];
      var keyframeAnim = parseKeyframe(kfs, dimIndex, context, function (outKeyframe, startVal) {
        var val = getMultiDimensionValue(startVal, dimIndex);
        if (convertVal) {
          val = convertVal(val);
        }
        (targetPropName ? outKeyframe[targetPropName] = {} : outKeyframe)[propName] = val;
      });
      // moving position around a curved path
      var needOffsetPath = kfs.some(function (kf) {
        return kf.ti && kf.to;
      });
      if (needOffsetPath) {
        var offsetPath = [];
        kfs.forEach(function (kf, i) {
          keyframeAnim.keyframes[i].offsetPath = offsetPath;
          // convert to & ti(Tangent for values (eg: moving position around a curved path)) to offsetPath & offsetDistance
          // @see https://lottiefiles.github.io/lottie-docs/concepts/#animated-position
          if (kf.ti && kf.to) {
            if (i === 0) {
              offsetPath.push(['M', kf.s[0], kf.s[1]]);
            }
            keyframeAnim.keyframes[i].segmentLength = getTotalLength(offsetPath);
            // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier
            // The nth bezier segment is defined as:
            // v[n], v[n]+o[n], v[n+1]+i[n+1], v[n+1]
            offsetPath.push(['C', kf.s[0] + kf.to[0], kf.s[1] + kf.to[1], kf.s[0] + kf.ti[0], kf.s[1] + kf.ti[1], kf.e[0], kf.e[1]]);
          }
        });
        // calculate offsetDistance: segmentLength / totalLength
        var totalLength = getTotalLength(offsetPath);
        keyframeAnim.keyframes.forEach(function (kf) {
          kf.offsetDistance = isNil(kf.segmentLength) ? 1 : kf.segmentLength / totalLength;
          delete kf.segmentLength;
        });
      }
      if (keyframeAnim.keyframes.length) {
        keyframeAnimations.push(keyframeAnim);
      }
    };
    for (var dimIndex = 0; dimIndex < propNames.length; dimIndex++) {
      _loop(dimIndex);
    }
  }
  function parseColorOffsetKeyframe(kfs, targetPropName, propName, keyframeAnimations, context) {
    var keyframeAnim = parseKeyframe(kfs, 0, context, function (outKeyframe, startVal) {
      (targetPropName ? outKeyframe[targetPropName] = {} : outKeyframe)[propName] = toColorString(startVal);
    });
    if (keyframeAnim.keyframes.length) {
      keyframeAnimations.push(keyframeAnim);
    }
  }
  function parseValue(lottieVal, attrs, targetPropName, propNames, animations, context, convertVal) {
    if (targetPropName) {
      attrs[targetPropName] = attrs[targetPropName] || {};
    }
    var target = targetPropName ? attrs[targetPropName] : attrs;
    if (isValue(lottieVal)) {
      var val = lottieVal.k;
      target[propNames[0]] = convertVal ? convertVal(val) : val;
    } else if (isKeyframedValue(lottieVal)) {
      parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);
    } else if (isMultiDimensionalValue(lottieVal)) {
      for (var i = 0; i < propNames.length; i++) {
        var _val = getMultiDimensionValue(lottieVal.k, i);
        target[propNames[i]] = convertVal ? convertVal(_val) : _val;
      }
    } else if (isMultiDimensionalKeyframedValue(lottieVal)) {
      // TODO Merge dimensions
      parseOffsetKeyframe(lottieVal.k, targetPropName, propNames, animations, context, convertVal);
    }
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/concepts/#transform
   */
  function parseTransforms(ks, attrs, animations, context, targetProp, transformProps) {
    if (targetProp === void 0) {
      targetProp = '';
    }
    if (transformProps === void 0) {
      transformProps = {
        x: 'x',
        y: 'y',
        rotation: 'rotation',
        scaleX: 'scaleX',
        scaleY: 'scaleY',
        anchorX: 'anchorX',
        anchorY: 'anchorY',
        skew: 'skew',
        skewAxis: 'skewAxis'
      };
    }
    // @see https://lottiefiles.github.io/lottie-docs/concepts/#split-vector
    if (ks.p.s) {
      parseValue(ks.p.x, attrs, targetProp, [transformProps.x], animations, context);
      parseValue(ks.p.y, attrs, targetProp, [transformProps.y], animations, context);
    } else {
      parseValue(ks.p, attrs, targetProp, [transformProps.x, transformProps.y], animations, context);
    }
    parseValue(ks.s, attrs, targetProp, [transformProps.scaleX, transformProps.scaleY], animations, context, function (val) {
      return val / 100;
    });
    parseValue(ks.r, attrs, targetProp, [transformProps.rotation], animations, context);
    parseValue(ks.a, attrs, targetProp, [transformProps.anchorX, transformProps.anchorY], animations, context);
    parseValue(ks.sk, attrs, targetProp, [transformProps.skew], animations, context);
    parseValue(ks.sa, attrs, targetProp, [transformProps.skewAxis], animations, context);
  }
  function isGradientFillOrStroke(fl) {
    return fl.g && fl.s && fl.e;
  }
  function convertColorStops(arr, count) {
    var colorStops = [];
    for (var i = 0; i < count * 4;) {
      var offset = arr[i++];
      var r = Math.round(arr[i++] * 255);
      var g = Math.round(arr[i++] * 255);
      var b = Math.round(arr[i++] * 255);
      colorStops.push({
        offset: offset,
        color: "rgb(" + r + ", " + g + ", " + b + ")"
      });
    }
    return colorStops;
  }
  function joinColorStops(colorStops) {
    return "" + colorStops.map(function (_ref) {
      var offset = _ref.offset,
        color = _ref.color;
      return color + " " + offset * 100 + "%";
    }).join(', ');
  }
  /**
   * TODO:
   * * Transition
   * * Highlight length & angle in Radial Gradient
   *
   * @see https://lottiefiles.github.io/lottie-docs/concepts/#gradients
   * @see https://lottiefiles.github.io/lottie-docs/shapes/#gradients
   */
  function parseGradient$2(shape) {
    var colorArr = shape.g.k.k;
    var colorStops = convertColorStops(colorArr, shape.g.p);
    // @see https://lottiefiles.github.io/lottie-docs/constants/#gradienttype
    if (shape.t === GradientType$1.Linear) {
      var angle = rad2deg(Math.atan2(shape.e.k[1] - shape.s.k[1], shape.e.k[0] - shape.s.k[0]));
      // @see https://g-next.antv.vision/zh/docs/api/css/css-properties-values-api#linear-gradient
      return "linear-gradient(" + angle + "deg, " + joinColorStops(colorStops) + ")";
    } else if (shape.t === GradientType$1.Radial) {
      // TODO: highlight length & angle (h & a)
      // Highlight Length, as a percentage between s and e
      // Highlight Angle, relative to the direction from s to e
      var size = distanceSquareRoot(shape.e.k, shape.s.k);
      // @see https://g-next.antv.vision/zh/docs/api/css/css-properties-values-api#radial-gradient
      return "radial-gradient(circle " + size + "px at " + shape.s.k[0] + "px " + shape.s.k[1] + "px, " + joinColorStops(colorStops) + ")";
    } else {
      // Invalid gradient
      return '#000';
    }
  }
  function parseFill(fl, attrs, animations, context) {
    attrs.style = attrs.style || {};
    // Color
    if (isGradientFillOrStroke(fl)) {
      attrs.style.fill = parseGradient$2(fl);
    } else {
      if (isMultiDimensionalValue(fl.c)) {
        attrs.style.fill = toColorString(fl.c.k);
      } else if (isMultiDimensionalKeyframedValue(fl.c)) {
        parseColorOffsetKeyframe(fl.c.k, 'style', 'fill', animations, context);
      }
    }
    // FillRule @see https://lottiefiles.github.io/lottie-docs/constants/#fillrule
    attrs.style.fillRule = fl.r === FillRule.EvenOdd ? 'evenodd' : 'nonzero';
    // Opacity
    parseValue(fl.o, attrs, 'style', ['fillOpacity'], animations, context, function (opacity) {
      return opacity / 100;
    });
  }
  function parseStroke(st, attrs, animations, context) {
    attrs.style = attrs.style || {};
    // Color
    if (isGradientFillOrStroke(st)) {
      attrs.style.stroke = parseGradient$2(st);
    } else {
      if (isMultiDimensionalValue(st.c)) {
        attrs.style.stroke = toColorString(st.c.k);
      } else if (isMultiDimensionalKeyframedValue(st.c)) {
        parseColorOffsetKeyframe(st.c.k, 'style', 'stroke', animations, context);
      }
    }
    // Opacity
    parseValue(st.o, attrs, 'style', ['strokeOpacity'], animations, context, function (opacity) {
      return opacity / 100;
    });
    // Line width
    parseValue(st.w, attrs, 'style', ['lineWidth'], animations, context);
    switch (st.lj) {
      case LineJoin.Bevel:
        attrs.style.lineJoin = 'bevel';
        break;
      case LineJoin.Round:
        attrs.style.lineJoin = 'round';
        break;
      case LineJoin.Miter:
        attrs.style.lineJoin = 'miter';
        break;
    }
    switch (st.lc) {
      case LineCap.Butt:
        attrs.style.lineCap = 'butt';
        break;
      case LineCap.Round:
        attrs.style.lineCap = 'round';
        break;
      case LineCap.Square:
        attrs.style.lineCap = 'square';
        break;
    }
    // Line dash
    var dashArray = [];
    var dashOffset = 0;
    if (st.d) {
      st.d.forEach(function (item) {
        if (item.n !== 'o') {
          dashArray.push(item.v.k);
        } else {
          dashOffset = item.v.k;
        }
      });
      attrs.style.lineDash = dashArray;
      attrs.style.lineDashOffset = dashOffset;
    }
  }
  function isBezier(k) {
    return k && k.i && k.o && k.v;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/shapes/#path
   */
  function parseShapePaths(shape, animations, context) {
    var attrs = {
      type: Shape.PATH,
      // Should have no fill and stroke by default
      style: {
        fill: 'none',
        stroke: 'none'
      }
    };
    // @see https://lottiefiles.github.io/lottie-docs/concepts/#bezier
    if (isBezier(shape.ks.k)) {
      attrs.shape = {
        in: shape.ks.k.i,
        out: shape.ks.k.o,
        v: shape.ks.k.v,
        close: shape.ks.k.c
      };
    } else if (Array.isArray(shape.ks.k)) {
      var keyframeAnim = parseKeyframe(shape.ks.k, 0, context, function (outKeyframe, startVal) {
        outKeyframe.shape = {
          in: startVal[0].i,
          out: startVal[0].o,
          v: startVal[0].v,
          close: startVal[0].c
        };
      });
      if (keyframeAnim.keyframes.length) {
        animations.push(keyframeAnim);
      }
    }
    return attrs;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/shapes/#rectangle
   */
  function parseShapeRect(shape, animations, context) {
    var attrs = {
      type: Shape.RECT,
      // Should have no fill and stroke by default
      style: {
        fill: 'none',
        stroke: 'none'
      },
      shape: {}
    };
    parseValue(shape.p, attrs, 'shape', ['x', 'y'], animations, context);
    parseValue(shape.s, attrs, 'shape', ['width', 'height'], animations, context);
    parseValue(shape.r, attrs, 'shape', ['r'], animations, context);
    return attrs;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/layers/#image-layer
   */
  function parseImageLayer(layer, context) {
    var attrs = {
      type: Shape.IMAGE,
      style: {},
      shape: {
        width: 0,
        height: 0,
        src: ''
      }
    };
    var asset = context.assetsMap.get(layer.refId);
    if (asset) {
      attrs.shape.width = asset.w;
      attrs.shape.height = asset.h;
      // TODO: url to fetch
      attrs.shape.src = asset.p;
    }
    return attrs;
  }
  /**
   * @see https://lottiefiles.github.io/lottie-docs/shapes/#ellipse
   */
  function parseShapeEllipse(shape, animations, context) {
    var attrs = {
      type: Shape.ELLIPSE,
      // Should have no fill and stroke by default
      style: {
        fill: 'none',
        stroke: 'none'
      },
      shape: {}
    };
    parseValue(shape.p, attrs, 'shape', ['cx', 'cy'], animations, context);
    parseValue(shape.s, attrs, 'shape', ['rx', 'ry'], animations, context, function (val) {
      return val / 2;
    });
    return attrs;
  }
  function parseShapeLayer(layer, context) {
    function tryCreateShape(shape, keyframeAnimations) {
      var ecEl;
      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
      switch (shape.ty) {
        case ShapeType.Path:
          ecEl = parseShapePaths(shape, keyframeAnimations, context);
          break;
        case ShapeType.Ellipse:
          ecEl = parseShapeEllipse(shape, keyframeAnimations, context);
          break;
        case ShapeType.Rectangle:
          ecEl = parseShapeRect(shape, keyframeAnimations, context);
          break;
        case ShapeType.PolyStar:
          // TODO: parseShapePolyStar
          break;
      }
      return ecEl;
    }
    function parseModifiers(shapes, modifiers) {
      shapes.forEach(function (shape) {
        if (shape.hd) {
          return;
        }
        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
        switch (shape.ty) {
          case ShapeType.Repeater:
            parseValue(shape.c, modifiers.attrs, 'shape', ['repeat'], modifiers.keyframeAnimations, context);
            parseTransforms(shape.tr, modifiers.attrs, modifiers.keyframeAnimations, context, 'shape', {
              x: 'repeatX',
              y: 'repeatY',
              rotation: 'repeatRot',
              scaleX: 'repeatScaleX',
              scaleY: 'repeatScaleY',
              anchorX: 'repeatAnchorX',
              anchorY: 'repeatAnchorY',
              skew: 'repeatSkew',
              skewAxis: 'repeatSkewAxis'
            });
            break;
          case ShapeType.Trim:
            parseValue(shape.s, modifiers.attrs, 'shape', ['trimStart'], modifiers.keyframeAnimations, context);
            parseValue(shape.e, modifiers.attrs, 'shape', ['trimEnd'], modifiers.keyframeAnimations, context);
            break;
        }
      });
    }
    function parseIterations(shapes, modifiers) {
      var ecEls = [];
      var attrs = {};
      var keyframeAnimations = [];
      // Order is reversed
      shapes = shapes.slice().reverse();
      // Modifiers first:
      parseModifiers(shapes, modifiers);
      shapes.forEach(function (shape) {
        if (shape.hd) {
          return;
        }
        var ecEl;
        switch (shape.ty) {
          case ShapeType.Group:
            ecEl = {
              type: Shape.GROUP,
              children: parseIterations(shape.it,
              // Modifiers will be applied to all childrens.
              modifiers)
            };
            break;
          // TODO Multiple fill and stroke
          case ShapeType.Fill:
          case ShapeType.GradientFill:
            parseFill(shape, attrs, keyframeAnimations, context);
            break;
          case ShapeType.Stroke:
          case ShapeType.GradientStroke:
            parseStroke(shape, attrs, keyframeAnimations, context);
            break;
          case ShapeType.Transform:
            parseTransforms(shape, attrs, keyframeAnimations, context);
            break;
          // TODO Multiple shapes.
          default:
            ecEl = tryCreateShape(shape, keyframeAnimations);
        }
        if (ecEl) {
          ecEl.name = shape.nm;
          ecEls.push(ecEl);
        }
      });
      ecEls.forEach(function (el, idx) {
        // Apply modifiers first
        el = _extends$3({}, el, definedProps(modifiers.attrs), attrs);
        if (keyframeAnimations.length || modifiers.keyframeAnimations.length) {
          el.keyframeAnimation = [].concat(modifiers.keyframeAnimations, keyframeAnimations);
        }
        ecEls[idx] = el;
      });
      return ecEls;
    }
    return {
      type: Shape.GROUP,
      children: parseIterations(layer.shapes, {
        attrs: {},
        keyframeAnimations: []
      })
    };
  }
  function traverse(el, cb) {
    cb(el);
    if (el.type === Shape.GROUP) {
      var _el$children;
      (_el$children = el.children) === null || _el$children === void 0 ? void 0 : _el$children.forEach(function (child) {
        traverse(child, cb);
      });
    }
  }
  function addLayerOpacity(layer, layerGroup, context) {
    var _layer$ks;
    var opacityAttrs = {};
    var opacityAnimations = [];
    if ((_layer$ks = layer.ks) === null || _layer$ks === void 0 ? void 0 : _layer$ks.o) {
      var _opacityAttrs$style;
      parseValue(layer.ks.o, opacityAttrs, 'style', ['opacity'], opacityAnimations, context, function (val) {
        return val / 100;
      });
      if (((_opacityAttrs$style = opacityAttrs.style) === null || _opacityAttrs$style === void 0 ? void 0 : _opacityAttrs$style.opacity) || opacityAnimations.length) {
        // apply opacity to group's children
        traverse(layerGroup, function (el) {
          if (el.type !== Shape.GROUP && el.style) {
            Object.assign(el.style, opacityAttrs.style);
            if (opacityAnimations.length) {
              el.keyframeAnimation = (el.keyframeAnimation || []).concat(opacityAnimations);
            }
          }
        });
      }
    }
  }
  function parseSolidShape(layer) {
    return {
      type: Shape.RECT,
      shape: {
        x: 0,
        y: 0,
        width: layer.sw,
        height: layer.sh
      },
      style: {
        fill: layer.sc
      }
    };
  }
  function parseLayers(layers, context, precompLayerTl) {
    var _layers;
    var elements = [];
    // Order is reversed
    layers = layers.slice().reverse();
    var layerIndexMap = new Map();
    var offsetTime = (precompLayerTl === null || precompLayerTl === void 0 ? void 0 : precompLayerTl.st) || 0;
    (_layers = layers) === null || _layers === void 0 ? void 0 : _layers.forEach(function (layer) {
      var _context$assetsMap$ge;
      // Layer time is offseted by the precomp layer.
      // Use the ip, op, st of ref from.
      var layerIp = offsetTime + layer.ip;
      var layerOp = offsetTime + layer.op;
      var layerSt = offsetTime + layer.st;
      context.layerOffsetTime = offsetTime;
      var layerGroup;
      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
      switch (layer.ty) {
        case LayerType.shape:
          // @see https://lottiefiles.github.io/lottie-docs/layers/#shape-layer
          layerGroup = parseShapeLayer(layer, context);
          break;
        case LayerType.null:
          // @see https://lottiefiles.github.io/lottie-docs/layers/#null-layer
          layerGroup = {
            type: Shape.GROUP,
            children: []
          };
          break;
        case LayerType.solid:
          // @see https://lottiefiles.github.io/lottie-docs/layers/#solid-color-layer
          layerGroup = {
            type: Shape.GROUP,
            children: []
          };
          // Anything you can do with solid layers, you can do better with a shape layer and a rectangle shape
          // since none of this layer's own properties can be animated.
          if (layer.sc) {
            layerGroup.children.push(parseSolidShape(layer));
          }
          break;
        case LayerType.precomp:
          // @see https://lottiefiles.github.io/lottie-docs/layers/#precomposition-layer
          layerGroup = {
            type: Shape.GROUP,
            children: parseLayers(((_context$assetsMap$ge = context.assetsMap.get(layer.refId)) === null || _context$assetsMap$ge === void 0 ? void 0 : _context$assetsMap$ge.layers) || [], context, {
              st: layerSt
            })
          };
          break;
        case LayerType.text:
          // TODO: https://lottiefiles.github.io/lottie-docs/layers/#text-layer
          break;
        case LayerType.image:
          // TODO: https://lottiefiles.github.io/lottie-docs/layers/#image-layer
          layerGroup = layerGroup = {
            type: Shape.GROUP,
            children: [parseImageLayer(layer, context)]
          };
          break;
      }
      if (layerGroup) {
        var _layer$masksPropertie;
        var keyframeAnimations = [];
        var attrs = {
          name: layer.nm
        };
        if (layer.ks) {
          parseTransforms(layer.ks, attrs, keyframeAnimations, context);
        }
        Object.assign(layerGroup, attrs);
        if (layer.ind != null) {
          layerIndexMap.set(layer.ind, layerGroup);
        }
        layerGroup.extra = {
          layerParent: layer.parent
        };
        // Masks @see https://lottiefiles.github.io/lottie-docs/layers/#masks
        // @see https://lottie-animation-community.github.io/docs/specs/layers/common/#clipping-masks
        // TODO: not support alpha and other modes.
        // @see https://lottie-animation-community.github.io/docs/specs/properties/mask-mode-types/
        if (layer.hasMask && ((_layer$masksPropertie = layer.masksProperties) === null || _layer$masksPropertie === void 0 ? void 0 : _layer$masksPropertie.length)) {
          var maskKeyframeAnimations = [];
          // TODO: Only support one mask now.
          var _attrs = parseShapePaths({
            ks: layer.masksProperties[0].pt
          }, maskKeyframeAnimations, context);
          layerGroup.clipPath = _extends$3({
            type: Shape.PATH
          }, _attrs);
          if (maskKeyframeAnimations.length) {
            layerGroup.clipPath.keyframeAnimation = maskKeyframeAnimations;
          }
        }
        addLayerOpacity(layer, layerGroup, context);
        // Update in and out animation.
        if (layerIp != null && layerOp != null && (layerIp > context.startFrame || layerOp < context.endFrame)) {
          var duration = context.endFrame - context.startFrame;
          var visibilityStartOffset = (layerIp - context.startFrame) / duration;
          var visibilityEndOffset = (layerOp - context.startFrame) / duration;
          layerGroup.visibilityStartOffset = visibilityStartOffset;
          layerGroup.visibilityEndOffset = visibilityEndOffset;
          layerGroup.visibilityFrame = duration;
        }
        if (keyframeAnimations.length) {
          layerGroup.keyframeAnimation = keyframeAnimations;
        }
        elements.push(layerGroup);
      }
    });
    // Build hierarchy
    return elements.filter(function (el) {
      var _el$extra;
      var parentLayer = layerIndexMap.get((_el$extra = el.extra) === null || _el$extra === void 0 ? void 0 : _el$extra.layerParent);
      if (parentLayer) {
        var _parentLayer$children;
        (_parentLayer$children = parentLayer.children) === null || _parentLayer$children === void 0 ? void 0 : _parentLayer$children.push(el);
        return false;
      }
      return true;
    });
  }
  var DEFAULT_LOAD_ANIMATION_OPTIONS = {
    loop: true,
    autoplay: false,
    fill: 'both'
  };
  function parse(data, options) {
    var _data$assets;
    completeData(data);
    var _DEFAULT_LOAD_ANIMATI = _extends$3({}, DEFAULT_LOAD_ANIMATION_OPTIONS, options),
      loop = _DEFAULT_LOAD_ANIMATI.loop,
      autoplay = _DEFAULT_LOAD_ANIMATI.autoplay,
      fill = _DEFAULT_LOAD_ANIMATI.fill;
    var context = new ParseContext();
    context.fps = data.fr || 30;
    context.frameTime = 1000 / context.fps;
    context.startFrame = data.ip;
    context.endFrame = data.op;
    context.version = data.v;
    context.autoplay = !!autoplay;
    context.fill = fill;
    context.iterations = isNumber(loop) ? loop : loop ? Infinity : 1;
    // @see https://lottiefiles.github.io/lottie-docs/assets/
    (_data$assets = data.assets) === null || _data$assets === void 0 ? void 0 : _data$assets.forEach(function (asset) {
      context.assetsMap.set(asset.id, asset);
    });
    var elements = parseLayers(data.layers || [], context);
    return {
      width: data.w,
      height: data.h,
      elements: elements,
      context: context
    };
  }

  /**
   * @see https://github.com/airbnb/lottie-web/wiki/loadAnimation-options
   * @see https://github.com/airbnb/lottie-web#other-loading-options
   */
  function loadAnimation(data, options) {
    var _parse = parse(data, options),
      width = _parse.width,
      height = _parse.height,
      elements = _parse.elements,
      context = _parse.context;
    return new LottieAnimation(width, height, elements, context);
  }

  var Lottie = /** @class */function (_super) {
    __extends(Lottie, _super);
    function Lottie(props) {
      var _this = _super.call(this, props) || this;
      _this.addLottie = function () {
        var _a = _this,
          props = _a.props,
          context = _a.context;
        var data = props.data,
          options = props.options,
          play = props.play;
        var canvas = context.canvas;
        if (!data) return;
        // lottie
        canvas.ready.then(function () {
          _this.animation = _this.animation ? _this.animation : loadAnimation(data, options);
          _this.animation.render(_this.ref.current);
          _this.size = _this.animation.size();
          _this.updateSize();
          // 
          if (play) {
            var _a = play.speed,
              speed = _a === void 0 ? 1 : _a,
              _b = play.start,
              start = _b === void 0 ? 0 : _b,
              _c = play.end,
              end = _c === void 0 ? _this.animation.getDuration(true) : _c;
            _this.animation.setSpeed(speed);
            _this.animation.playSegments([start, end]);
          }
        });
      };
      _this.updateSize = function () {
        var _a = _this.size,
          currentWidth = _a.width,
          currentHeight = _a.height;
        var style = _this.props.style;
        if (!style) return;
        var _b = style.width,
          width = _b === void 0 ? currentWidth : _b,
          _c = style.height,
          height = _c === void 0 ? currentHeight : _c;
        _this.ref.current.scale(width / currentWidth, height / currentHeight);
        _this.size = {
          width: width,
          height: height
        };
      };
      _this.ref = createRef();
      return _this;
    }
    Lottie.prototype.didMount = function () {
      this.addLottie();
    };
    Lottie.prototype.willUpdate = function () {
      this.addLottie();
    };
    Lottie.prototype.render = function () {
      var _a = this.props,
        style = _a.style,
        animation = _a.animation;
      return jsx("group", {
        ref: this.ref,
        style: style,
        animation: animation
      });
    };
    return Lottie;
  }(Component);

  var defaultProps$2 = {
    offsetX: 0,
    offsetY: 0,
    points: [],
    data: '',
    animation: null,
    options: {
      loop: true,
      autoplay: true
    }
  };
  var LottieGuideView = (function (props, context) {
    var cfg = deepMix({}, defaultProps$2, props);
    var points = cfg.points,
      style = cfg.style,
      offsetX = cfg.offsetX,
      offsetY = cfg.offsetY,
      lottieJson = cfg.lottieJson,
      animation = cfg.animation,
      options = cfg.options;
    var _ref = points[0] || {},
      x = _ref.x,
      y = _ref.y;
    var _style$height = style.height,
      height = _style$height === void 0 ? 0 : _style$height,
      _style$width = style.width,
      width = _style$width === void 0 ? 0 : _style$width;
    var offsetXNum = context.px2hd(offsetX);
    var offsetYNum = context.px2hd(offsetY);
    var posX = x + (offsetXNum || 0) - width / 2;
    var posY = y + (offsetYNum || 0) - height / 2;
    return jsx(Lottie, {
      data: lottieJson,
      options: options,
      style: {
        x: posX,
        y: posY,
        width: width,
        height: height
      },
      animation: deepMix({
        update: {
          easing: 'linear',
          duration: 450,
          property: ['x', 'y']
        }
      }, animation)
    });
  });

  var DefaultGuideView = function DefaultGuideView() {
    return null;
  };
  var TextGuide = withGuide(TextGuideView);
  var PointGuide = withGuide(PointGuideView);
  var LineGuide = withGuide(LineGuideView);
  var ArcGuide = withGuide(ArcGuideView);
  var RectGuide = withGuide(RectGuideView);
  var ImageGuide = withGuide(ImageGuideView);
  var TagGuide = withGuide(Tag);
  var LottieGuide = withGuide(LottieGuideView);
  var index$6 = withGuide(DefaultGuideView);

  var withTooltip = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Tooltip, _Component);
      var _super = _createSuper(Tooltip);
      function Tooltip(props) {
        var _this;
        _classCallCheck(this, Tooltip);
        _this = _super.call(this, props);
        _this._triggerOn = function (ev) {
          var x = ev.x,
            y = ev.y;
          _this.show({
            x: x,
            y: y
          }, ev);
        };
        _this._triggerOff = function () {
          var _assertThisInitialize = _assertThisInitialized$2(_this),
            _assertThisInitialize2 = _assertThisInitialize.props.alwaysShow,
            alwaysShow = _assertThisInitialize2 === void 0 ? false : _assertThisInitialize2;
          if (!alwaysShow) {
            _this.hide();
          }
        };
        _this.state = {
          records: null
        };
        return _this;
      }
      _createClass$2(Tooltip, [{
        key: "updateCoord",
        value: function updateCoord() {
          var props = this.props,
            context = this.context;
          var _props$padding = props.padding,
            padding = _props$padding === void 0 ? '10px' : _props$padding,
            chart = props.chart;
          chart.updateCoordFor(this, {
            position: 'top',
            width: 0,
            height: context.px2hd(padding)
          });
        }
      }, {
        key: "willMount",
        value: function willMount() {
          this.updateCoord();
        }
      }, {
        key: "didMount",
        value: function didMount() {
          this._initShow();
          this._initEvent();
        }
      }, {
        key: "_initEvent",
        value: function _initEvent() {
          var _this$props = this.props,
            chart = _this$props.chart,
            _this$props$triggerOn = _this$props.triggerOn,
            triggerOn = _this$props$triggerOn === void 0 ? 'press' : _this$props$triggerOn,
            _this$props$triggerOf = _this$props.triggerOff,
            triggerOff = _this$props$triggerOf === void 0 ? 'pressend' : _this$props$triggerOf;
          chart.on(triggerOn, this._triggerOn);
          chart.on(triggerOff, this._triggerOff);
        }
      }, {
        key: "willReceiveProps",
        value: function willReceiveProps(nextProps) {
          var nextDefaultItem = nextProps.defaultItem,
            nextCoord = nextProps.coord;
          var _this$props2 = this.props,
            lastDefaultItem = _this$props2.defaultItem,
            lastCoord = _this$props2.coord;
          // 
          if (!equal(nextDefaultItem, lastDefaultItem) || !equal(nextCoord, lastCoord)) {
            this._showByData(nextDefaultItem);
          }
        }
      }, {
        key: "_initShow",
        value: function _initShow() {
          var props = this.props;
          var defaultItem = props.defaultItem;
          this._showByData(defaultItem);
        }
      }, {
        key: "_showByData",
        value: function _showByData(dataItem) {
          var _this2 = this;
          if (!dataItem) return;
          var props = this.props;
          var chart = props.chart;
          //  tooltip  geometry  geometry render 
          setTimeout(function () {
            var snapRecords = chart.getRecords(dataItem, 'xfield');
            _this2.showSnapRecords(snapRecords);
          }, 0);
        }
      }, {
        key: "show",
        value: function show(point, _ev) {
          var props = this.props;
          var chart = props.chart;
          var snapRecords = chart.getSnapRecords(point, true); // 
          if (!snapRecords || !snapRecords.length) return;
          this.showSnapRecords(snapRecords);
        }
      }, {
        key: "showSnapRecords",
        value: function showSnapRecords(snapRecords) {
          var _this$props3 = this.props,
            chart = _this$props3.chart,
            onChange = _this$props3.onChange;
          var legendItems = chart.getLegendItems();
          var _snapRecords$ = snapRecords[0],
            xField = _snapRecords$.xField,
            yField = _snapRecords$.yField;
          var xScale = chart.getScale(xField);
          var yScale = chart.getScale(yField);
          var records = snapRecords.map(function (record) {
            var origin = record.origin,
              xField = record.xField,
              yField = record.yField;
            var value = yScale.getText(origin[yField]);
            //  alias 
            var name = yScale.alias;
            if (!name) {
              name = xScale.getText(origin[xField]);
              if (legendItems && legendItems.length) {
                var item = find(legendItems, function (item) {
                  var field = item.field,
                    tickValue = item.tickValue;
                  return origin[field] === tickValue;
                });
                if (item && item.name) {
                  name = item.name;
                }
              }
            }
            return _objectSpread(_objectSpread({}, record), {}, {
              name: name,
              value: value
            });
          });
          if (!isArray(records) || !records.length) {
            return;
          }
          this.setState({
            records: records
          });
          if (isFunction(onChange)) {
            onChange(records);
          }
        }
      }, {
        key: "hide",
        value: function hide() {
          this.setState({
            records: null
          });
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            state = this.state;
          var visible = props.visible;
          if (visible === false) {
            return null;
          }
          var records = state.records;
          return records && records.length && jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            records: records
          }));
        }
      }]);
      return Tooltip;
    }(Component);
  });

  // view 
  var defaultStyle$1 = {
    showTitle: false,
    showCrosshairs: false,
    crosshairsType: 'y',
    crosshairsStyle: {
      stroke: 'rgba(0, 0, 0, 0.25)',
      lineWidth: '2px'
    },
    showTooltipMarker: false,
    markerBackgroundStyle: {
      fill: '#CCD6EC',
      opacity: 0.3,
      padding: '6px'
    },
    tooltipMarkerStyle: {
      fill: '#fff',
      lineWidth: '3px'
    },
    background: {
      radius: '4px',
      fill: 'rgba(0, 0, 0, 0.65)',
      padding: ['6px', '10px']
    },
    titleStyle: {
      fontSize: '24px',
      fill: '#fff',
      textAlign: 'start',
      textBaseline: 'top'
    },
    nameStyle: {
      fontSize: '24px',
      fill: 'rgba(255, 255, 255, 0.65)',
      textAlign: 'start',
      textBaseline: 'middle'
    },
    valueStyle: {
      fontSize: '24px',
      fill: '#fff',
      textAlign: 'start',
      textBaseline: 'middle'
    },
    joinString: ': ',
    showItemMarker: true,
    itemMarkerStyle: {
      width: '12px',
      radius: '6px',
      symbol: 'circle',
      lineWidth: '2px',
      stroke: '#fff'
    },
    layout: 'horizontal',
    snap: false,
    xTipTextStyle: {
      fontSize: '24px',
      fill: '#fff'
    },
    yTipTextStyle: {
      fontSize: '24px',
      fill: '#fff'
    },
    xTipBackground: {
      radius: '4px',
      fill: 'rgba(0, 0, 0, 0.65)',
      padding: ['6px', '10px'],
      marginLeft: '-50%',
      marginTop: '6px'
    },
    yTipBackground: {
      radius: '4px',
      fill: 'rgba(0, 0, 0, 0.65)',
      padding: ['6px', '10px'],
      marginLeft: '-100%',
      marginTop: '-50%'
    }
  };
  function directionEnabled(mode, dir) {
    if (mode === undefined) {
      return true;
    } else if (typeof mode === 'string') {
      return mode.indexOf(dir) !== -1;
    }
    return false;
  }
  var RenderItemMarker = function RenderItemMarker(props) {
    var records = props.records,
      coord = props.coord,
      context = props.context,
      markerBackgroundStyle = props.markerBackgroundStyle;
    var point = coord.convertPoint({
      x: 1,
      y: 1
    });
    var padding = context.px2hd(markerBackgroundStyle.padding || '6px');
    var xPoints = [].concat(_toConsumableArray(records.map(function (record) {
      return record.xMin;
    })), _toConsumableArray(records.map(function (record) {
      return record.xMax;
    })));
    var yPoints = [].concat(_toConsumableArray(records.map(function (record) {
      return record.yMin;
    })), _toConsumableArray(records.map(function (record) {
      return record.yMax;
    })));
    if (coord.transposed) {
      xPoints.push(point.x);
    } else {
      yPoints.push(point.y);
    }
    var xMin = Math.min.apply(null, xPoints);
    var xMax = Math.max.apply(null, xPoints);
    var yMin = Math.min.apply(null, yPoints);
    var yMax = Math.max.apply(null, yPoints);
    var x = coord.transposed ? xMin : xMin - padding;
    var y = coord.transposed ? yMin - padding : yMin;
    var width = coord.transposed ? xMax - xMin : xMax - xMin + 2 * padding;
    var height = coord.transposed ? yMax - yMin + 2 * padding : yMax - yMin;
    return jsx("rect", {
      style: _objectSpread({
        x: x,
        y: y,
        width: width,
        height: height
      }, markerBackgroundStyle)
    });
  };
  var RenderCrosshairs = function RenderCrosshairs(props) {
    var records = props.records,
      coord = props.coord,
      chart = props.chart,
      crosshairsType = props.crosshairsType,
      crosshairsStyle = props.crosshairsStyle;
    var coordLeft = coord.left,
      coordTop = coord.top,
      coordRight = coord.right,
      coordBottom = coord.bottom,
      center = coord.center;
    var firstRecord = records[0];
    var x = firstRecord.x,
      y = firstRecord.y,
      origin = firstRecord.origin,
      xField = firstRecord.xField;
    if (coord.isPolar) {
      // 
      var xScale = chart.getScale(xField);
      var ticks = xScale.getTicks();
      var tick = find(ticks, function (tick) {
        return origin[xField] === tick.tickValue;
      });
      var end = coord.convertPoint({
        x: tick.value,
        y: 1
      });
      return jsx("line", {
        style: _objectSpread({
          x1: center.x,
          y1: center.y,
          x2: end.x,
          y2: end.y
        }, crosshairsStyle)
      });
    }
    return jsx("group", null, directionEnabled(crosshairsType, 'x') ? jsx("line", {
      style: _objectSpread({
        x1: coordLeft,
        y1: y,
        x2: coordRight,
        y2: y
      }, crosshairsStyle)
    }) : null, directionEnabled(crosshairsType, 'y') ? jsx("line", {
      style: _objectSpread({
        x1: x,
        y1: coordTop,
        x2: x,
        y2: coordBottom
      }, crosshairsStyle)
    }) : null);
  };
  var RenderXTip = function RenderXTip(props) {
    var records = props.records,
      coord = props.coord,
      xTip = props.xTip,
      xTipTextStyle = props.xTipTextStyle,
      xTipBackground = props.xTipBackground;
    var coordBottom = coord.bottom;
    var firstRecord = records[0];
    var x = firstRecord.x;
    var xFirstText = firstRecord.name;
    return jsx("rect", {
      style: _objectSpread({
        display: 'flex',
        left: x,
        top: coordBottom
      }, xTipBackground)
    }, jsx("text", {
      style: _objectSpread(_objectSpread({}, xTipTextStyle), {}, {
        text: isFunction(xTip) ? xTip(xFirstText) : xFirstText
      })
    }));
  };
  var RenderYTip = function RenderYTip(props) {
    var records = props.records,
      coord = props.coord,
      yTip = props.yTip,
      yTipTextStyle = props.yTipTextStyle,
      yTipBackground = props.yTipBackground;
    var coordLeft = coord.left;
    var firstRecord = records[0];
    var y = firstRecord.y;
    var yFirstText = firstRecord.value;
    return jsx("rect", {
      style: _objectSpread({
        display: 'flex',
        left: coordLeft,
        top: y
      }, yTipBackground)
    }, jsx("text", {
      style: _objectSpread(_objectSpread({}, yTipTextStyle), {}, {
        text: isFunction(yTip) ? yTip(yFirstText) : yFirstText
      })
    }));
  };
  // tooltip 
  var RenderLabel = /*#__PURE__*/function (_Component) {
    _inherits(RenderLabel, _Component);
    var _super = _createSuper(RenderLabel);
    function RenderLabel() {
      _classCallCheck(this, RenderLabel);
      return _super.apply(this, arguments);
    }
    _createClass$2(RenderLabel, [{
      key: "render",
      value: function render() {
        var _this$props = this.props,
          records = _this$props.records,
          background = _this$props.background,
          showItemMarker = _this$props.showItemMarker,
          itemMarkerStyle = _this$props.itemMarkerStyle,
          customText = _this$props.customText,
          nameStyle = _this$props.nameStyle,
          valueStyle = _this$props.valueStyle,
          joinString = _this$props.joinString,
          arrowWidth = _this$props.arrowWidth,
          x = _this$props.x,
          coord = _this$props.coord;
        // 
        var labelView = function labelView(left, top) {
          return jsx("group", {
            style: {
              display: 'flex'
            }
          }, jsx("group", {
            style: _objectSpread({
              display: 'flex',
              flexDirection: 'row',
              flexWrap: 'wrap',
              padding: [0, 0, 0, '6px'],
              left: left,
              top: top
            }, background)
          }, records.map(function (record) {
            var name = record.name,
              value = record.value;
            return jsx("group", {
              style: {
                display: 'flex',
                flexDirection: 'row',
                alignItems: 'center',
                padding: [0, '6px', 0, 0]
              }
            }, showItemMarker ? jsx("marker", {
              style: _objectSpread(_objectSpread({
                width: itemMarkerStyle.width,
                marginRight: '6px'
              }, itemMarkerStyle), {}, {
                fill: record.color
              })
            }) : null, customText && isFunction(customText) ? customText(record) : jsx("group", {
              style: {
                display: 'flex',
                flexDirection: 'row'
              }
            }, jsx("text", {
              style: _objectSpread(_objectSpread({}, nameStyle), {}, {
                text: value ? "".concat(name).concat(joinString) : name
              })
            }), jsx("text", {
              style: _objectSpread(_objectSpread({}, valueStyle), {}, {
                text: value
              })
            })));
          })), jsx("group", null, jsx("polygon", {
            style: {
              points: [[x - arrowWidth, top], [x + arrowWidth, top], [x, top + arrowWidth]],
              fill: background.fill
            }
          })));
        };
        // 
        var _computeLayout = computeLayout$1(this, labelView(0, 0)),
          layout = _computeLayout.layout; // 
        var coordLeft = coord.left,
          coordTop = coord.top,
          coordRight = coord.right;
        var width = layout.width,
          height = layout.height;
        var halfWidth = width / 2;
        //  tooltip  coord 
        var advanceLeft = x - halfWidth;
        var advanceTop = coordTop - height;
        var left = advanceLeft < coordLeft ? coordLeft : advanceLeft > coordRight - width ? coordRight - width : advanceLeft;
        var top = advanceTop < 0 ? 0 : advanceTop;
        return labelView(left, top);
      }
    }]);
    return RenderLabel;
  }(Component);
  var TooltipView = /*#__PURE__*/function (_Component2) {
    _inherits(TooltipView, _Component2);
    var _super2 = _createSuper(TooltipView);
    function TooltipView() {
      _classCallCheck(this, TooltipView);
      return _super2.apply(this, arguments);
    }
    _createClass$2(TooltipView, [{
      key: "render",
      value: function render() {
        var props = this.props,
          context = this.context;
        var records = props.records,
          coord = props.coord;
        var firstRecord = records[0];
        var x = firstRecord.x;
        var chart = props.chart,
          customBackground = props.background,
          _props$showTooltipMar = props.showTooltipMarker,
          showTooltipMarker = _props$showTooltipMar === void 0 ? defaultStyle$1.showTooltipMarker : _props$showTooltipMar,
          _props$markerBackgrou = props.markerBackgroundStyle,
          markerBackgroundStyle = _props$markerBackgrou === void 0 ? defaultStyle$1.markerBackgroundStyle : _props$markerBackgrou,
          _props$showItemMarker = props.showItemMarker,
          showItemMarker = _props$showItemMarker === void 0 ? defaultStyle$1.showItemMarker : _props$showItemMarker,
          customItemMarkerStyle = props.itemMarkerStyle,
          nameStyle = props.nameStyle,
          valueStyle = props.valueStyle,
          _props$joinString = props.joinString,
          joinString = _props$joinString === void 0 ? defaultStyle$1.joinString : _props$joinString,
          _props$showCrosshairs = props.showCrosshairs,
          showCrosshairs = _props$showCrosshairs === void 0 ? defaultStyle$1.showCrosshairs : _props$showCrosshairs,
          crosshairsStyle = props.crosshairsStyle,
          _props$crosshairsType = props.crosshairsType,
          crosshairsType = _props$crosshairsType === void 0 ? defaultStyle$1.crosshairsType : _props$crosshairsType,
          _props$snap = props.snap,
          snap = _props$snap === void 0 ? defaultStyle$1.snap : _props$snap,
          _props$tooltipMarkerS = props.tooltipMarkerStyle,
          tooltipMarkerStyle = _props$tooltipMarkerS === void 0 ? defaultStyle$1.tooltipMarkerStyle : _props$tooltipMarkerS,
          showXTip = props.showXTip,
          showYTip = props.showYTip,
          xTip = props.xTip,
          yTip = props.yTip,
          _props$xTipTextStyle = props.xTipTextStyle,
          xTipTextStyle = _props$xTipTextStyle === void 0 ? defaultStyle$1.xTipTextStyle : _props$xTipTextStyle,
          _props$yTipTextStyle = props.yTipTextStyle,
          yTipTextStyle = _props$yTipTextStyle === void 0 ? defaultStyle$1.yTipTextStyle : _props$yTipTextStyle,
          _props$xTipBackground = props.xTipBackground,
          xTipBackground = _props$xTipBackground === void 0 ? defaultStyle$1.xTipBackground : _props$xTipBackground,
          _props$yTipBackground = props.yTipBackground,
          yTipBackground = _props$yTipBackground === void 0 ? defaultStyle$1.yTipBackground : _props$yTipBackground,
          _props$custom = props.custom,
          custom = _props$custom === void 0 ? false : _props$custom,
          customText = props.customText;
        var itemMarkerStyle = _objectSpread(_objectSpread({}, customItemMarkerStyle), defaultStyle$1.itemMarkerStyle);
        var background = _objectSpread(_objectSpread({}, defaultStyle$1.background), customBackground);
        var arrowWidth = context.px2hd('6px');
        return jsx("group", null, showTooltipMarker ? jsx(RenderItemMarker, {
          coord: coord,
          context: context,
          records: records,
          markerBackgroundStyle: markerBackgroundStyle
        }) : null, showCrosshairs ? jsx(RenderCrosshairs, {
          chart: chart,
          coord: coord,
          records: records,
          crosshairsType: crosshairsType,
          crosshairsStyle: _objectSpread(_objectSpread({}, defaultStyle$1.crosshairsStyle), crosshairsStyle)
        }) : null, snap ? records.map(function (item) {
          var x = item.x,
            y = item.y,
            color = item.color,
            shape = item.shape;
          return jsx("circle", {
            style: _objectSpread(_objectSpread({
              cx: x,
              cy: y,
              r: '6px',
              stroke: color,
              fill: color
            }, shape), tooltipMarkerStyle)
          });
        }) : null, showXTip && jsx(RenderXTip, {
          records: records,
          coord: coord,
          xTip: xTip,
          xTipTextStyle: _objectSpread(_objectSpread({}, defaultStyle$1.xTipTextStyle), {}, {
            xTipTextStyle: xTipTextStyle
          }),
          xTipBackground: _objectSpread(_objectSpread({}, defaultStyle$1.xTipBackground), {}, {
            xTipBackground: xTipBackground
          })
        }), showYTip && jsx(RenderYTip, {
          records: records,
          coord: coord,
          yTip: yTip,
          yTipTextStyle: _objectSpread(_objectSpread({}, defaultStyle$1.yTipTextStyle), {}, {
            yTipTextStyle: yTipTextStyle
          }),
          yTipBackground: _objectSpread(_objectSpread({}, defaultStyle$1.yTipBackground), {}, {
            yTipBackground: yTipBackground
          })
        }), !custom && jsx(RenderLabel, {
          records: records,
          coord: coord,
          itemMarkerStyle: itemMarkerStyle,
          customText: customText,
          showItemMarker: showItemMarker,
          x: x,
          arrowWidth: arrowWidth,
          background: background,
          nameStyle: _objectSpread(_objectSpread({}, defaultStyle$1.nameStyle), {}, {
            nameStyle: nameStyle
          }),
          valueStyle: _objectSpread(_objectSpread({}, defaultStyle$1.valueStyle), {}, {
            valueStyle: valueStyle
          }),
          joinString: joinString
        }));
      }
    }]);
    return TooltipView;
  }(Component);

  var index$7 = withTooltip(TooltipView);

  function count(node) {
    var sum = 0,
      children = node.children,
      i = children && children.length;
    if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
    node.value = sum;
  }
  function node_count () {
    return this.eachAfter(count);
  }

  var createForOfIteratorHelper = createCommonjsModule(function (module) {
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function F() {};
        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e) {
            throw _e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  var _createForOfIteratorHelper = /*@__PURE__*/getDefaultExportFromCjs(createForOfIteratorHelper);

  function node_each (callback, that) {
    var index = -1;
    var _iterator = _createForOfIteratorHelper(this),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        callback.call(that, node, ++index, this);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return this;
  }

  function node_eachBefore (callback, that) {
    var node = this,
      nodes = [node],
      children,
      i,
      index = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index, this);
      if (children = node.children) {
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
    }
    return this;
  }

  function node_eachAfter (callback, that) {
    var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n,
      index = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index, this);
    }
    return this;
  }

  function node_find (callback, that) {
    var index = -1;
    var _iterator = _createForOfIteratorHelper(this),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  function node_sum (value) {
    return this.eachAfter(function (node) {
      var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
      while (--i >= 0) sum += children[i].value;
      node.value = sum;
    });
  }

  function node_sort (compare) {
    return this.eachBefore(function (node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  function node_path (end) {
    var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
    a = aNodes.pop();
    b = bNodes.pop();
    while (a === b) {
      c = a;
      a = aNodes.pop();
      b = bNodes.pop();
    }
    return c;
  }

  function node_ancestors () {
    var node = this,
      nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  function node_descendants () {
    return Array.from(this);
  }

  function node_leaves () {
    var leaves = [];
    this.eachBefore(function (node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  function node_links () {
    var root = this,
      links = [];
    root.each(function (node) {
      if (node !== root) {
        // Dont include the roots parent, if any.
        links.push({
          source: node.parent,
          target: node
        });
      }
    });
    return links;
  }

  var regeneratorRuntime$1 = createCommonjsModule(function (module) {
  var _typeof = _typeof_1["default"];
  function _regeneratorRuntime() {
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function stop() {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  });

  // TODO(Babel 8): Remove this file.

  var runtime$1 = regeneratorRuntime$1();
  var regenerator = runtime$1;

  // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
  try {
    regeneratorRuntime = runtime$1;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime$1;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime$1);
    }
  }

  var _marked = /*#__PURE__*/regenerator.mark(_callee);
  function _callee() {
    var node, current, next, children, i, n;
    return regenerator.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          node = this, next = [node];
        case 1:
          current = next.reverse(), next = [];
        case 2:
          if (!(node = current.pop())) {
            _context.next = 8;
            break;
          }
          _context.next = 5;
          return node;
        case 5:
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
          _context.next = 2;
          break;
        case 8:
          if (next.length) {
            _context.next = 1;
            break;
          }
        case 9:
        case "end":
          return _context.stop();
      }
    }, _marked, this);
  }

  function hierarchy(data, children) {
    if (data instanceof Map) {
      data = [undefined, data];
      if (children === undefined) children = mapChildren;
    } else if (children === undefined) {
      children = objectChildren;
    }
    var root = new Node$2(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;
    while (node = nodes.pop()) {
      if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node$2(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }
    return root.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d) {
    return d.children;
  }
  function mapChildren(d) {
    return Array.isArray(d) ? d[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== undefined) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height = 0;
    do node.height = height; while ((node = node.parent) && node.height < ++height);
  }
  function Node$2(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node$2.prototype = hierarchy.prototype = _defineProperty({
    constructor: Node$2,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    find: node_find,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy
  }, Symbol.iterator, _callee);

  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }

  function constantZero() {
    return 0;
  }
  function constant$1 (x) {
    return function () {
      return x;
    };
  }

  function roundNode (node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  function treemapDice (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;
    while (++i < n) {
      node = nodes[i], node.y0 = y0, node.y1 = y1;
      node.x0 = x0, node.x1 = x0 += node.value * k;
    }
  }

  function partition () {
    var dx = 1,
      dy = 1,
      padding = 0,
      round = false;
    function partition(root) {
      var n = root.height + 1;
      root.x0 = root.y0 = padding;
      root.x1 = dx;
      root.y1 = dy / n;
      root.eachBefore(positionNode(dy, n));
      if (round) root.eachBefore(roundNode);
      return root;
    }
    function positionNode(dy, n) {
      return function (node) {
        if (node.children) {
          treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
        }
        var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
      };
    }
    partition.round = function (x) {
      return arguments.length ? (round = !!x, partition) : round;
    };
    partition.size = function (x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
    };
    partition.padding = function (x) {
      return arguments.length ? (padding = +x, partition) : padding;
    };
    return partition;
  }

  function treemapSlice (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;
    while (++i < n) {
      node = nodes[i], node.x0 = x0, node.x1 = x1;
      node.y0 = y0, node.y1 = y0 += node.value * k;
    }
  }

  var phi = (1 + Math.sqrt(5)) / 2;
  function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
    var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;
    while (i0 < n) {
      dx = x1 - x0, dy = y1 - y0;

      // Find the next non-empty node.
      do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);

      // Keep adding nodes while the aspect ratio maintains or improves.
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;
          break;
        }
        minRatio = newRatio;
      }

      // Position and record the row orientation.
      rows.push(row = {
        value: sumValue,
        dice: dx < dy,
        children: nodes.slice(i0, i1)
      });
      if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
      value -= sumValue, i0 = i1;
    }
    return rows;
  }
  var squarify = (function custom(ratio) {
    function squarify(parent, x0, y0, x1, y1) {
      squarifyRatio(ratio, parent, x0, y0, x1, y1);
    }
    squarify.ratio = function (x) {
      return custom((x = +x) > 1 ? x : 1);
    };
    return squarify;
  })(phi);

  function treemap () {
    var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;
    function treemap(root) {
      root.x0 = root.y0 = 0;
      root.x1 = dx;
      root.y1 = dy;
      root.eachBefore(positionNode);
      paddingStack = [0];
      if (round) root.eachBefore(roundNode);
      return root;
    }
    function positionNode(node) {
      var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
      if (node.children) {
        p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x0 += paddingLeft(node) - p;
        y0 += paddingTop(node) - p;
        x1 -= paddingRight(node) - p;
        y1 -= paddingBottom(node) - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        tile(node, x0, y0, x1, y1);
      }
    }
    treemap.round = function (x) {
      return arguments.length ? (round = !!x, treemap) : round;
    };
    treemap.size = function (x) {
      return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
    };
    treemap.tile = function (x) {
      return arguments.length ? (tile = required(x), treemap) : tile;
    };
    treemap.padding = function (x) {
      return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
    };
    treemap.paddingInner = function (x) {
      return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$1(+x), treemap) : paddingInner;
    };
    treemap.paddingOuter = function (x) {
      return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
    };
    treemap.paddingTop = function (x) {
      return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$1(+x), treemap) : paddingTop;
    };
    treemap.paddingRight = function (x) {
      return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$1(+x), treemap) : paddingRight;
    };
    treemap.paddingBottom = function (x) {
      return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$1(+x), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function (x) {
      return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$1(+x), treemap) : paddingLeft;
    };
    return treemap;
  }

  function treemapBinary (parent, x0, y0, x1, y1) {
    var nodes = parent.children,
      i,
      n = nodes.length,
      sum,
      sums = new Array(n + 1);
    for (sums[0] = sum = i = 0; i < n; ++i) {
      sums[i + 1] = sum += nodes[i].value;
    }
    partition(0, n, parent.value, x0, y0, x1, y1);
    function partition(i, j, value, x0, y0, x1, y1) {
      if (i >= j - 1) {
        var node = nodes[i];
        node.x0 = x0, node.y0 = y0;
        node.x1 = x1, node.y1 = y1;
        return;
      }
      var valueOffset = sums[i],
        valueTarget = value / 2 + valueOffset,
        k = i + 1,
        hi = j - 1;
      while (k < hi) {
        var mid = k + hi >>> 1;
        if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
      }
      if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
      var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;
      if (x1 - x0 > y1 - y0) {
        var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
        partition(i, k, valueLeft, x0, y0, xk, y1);
        partition(k, j, valueRight, xk, y0, x1, y1);
      } else {
        var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
        partition(i, k, valueLeft, x0, y0, x1, yk);
        partition(k, j, valueRight, x0, yk, x1, y1);
      }
    }
  }

  var withTreemap = function withTreemap(View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Treemap, _Component);
      var _super = _createSuper(Treemap);
      function Treemap(props, context) {
        var _this;
        _classCallCheck(this, Treemap);
        _this = _super.call(this, props, context);
        var color = props.color,
          data = props.data,
          theme = props.theme;
        var px2hd = context.px2hd;
        context.theme = deepMix(px2hd(Theme), theme);
        _this.coord = new coordController();
        _this.color = new Category$1(_objectSpread(_objectSpread({
          range: context.theme.colors
        }, color), {}, {
          data: data
        }));
        return _this;
      }
      _createClass$2(Treemap, [{
        key: "willMount",
        value: function willMount() {
          var props = this.props,
            coord = this.coord,
            layout = this.layout;
          var coordOption = props.coord;
          coord.updateLayout(layout);
          coord.create(coordOption);
        }
      }, {
        key: "treemapLayout",
        value: function treemapLayout() {
          var props = this.props,
            coord = this.coord,
            colorAttr = this.color;
          var _coord$getCoord = coord.getCoord(),
            width = _coord$getCoord.width,
            height = _coord$getCoord.height;
          var data = props.data,
            value = props.value,
            _props$space = props.space,
            space = _props$space === void 0 ? 0 : _props$space;
          var root = hierarchy({
            children: data
          }).sum(function (d) {
            return d[value];
          }).sort(function (a, b) {
            return b[value] - a[value];
          });
          var treemapLayout = treemap()
          // treemapSquarify
          .tile(treemapBinary).round(false).size([width, height])
          // .padding(1);
          .paddingInner(space);
          // .paddingOuter(options.paddingOuter)
          // .paddingTop(options.paddingTop)
          // .paddingRight(options.paddingRight)
          // .paddingBottom(options.paddingBottom)
          // .paddingLeft(options.paddingLeft);
          var nodes = treemapLayout(root);
          return nodes.children.map(function (item) {
            var data = item.data,
              x0 = item.x0,
              y0 = item.y0,
              x1 = item.x1,
              y1 = item.y1;
            var color = colorAttr.mapping(data[colorAttr.field]);
            var rect = {
              xMin: x0,
              xMax: x1,
              yMin: y0,
              yMax: y1
            };
            return _objectSpread({
              key: data.key,
              origin: data,
              color: color
            }, rect);
          });
        }
      }, {
        key: "render",
        value: function render() {
          var nodes = this.treemapLayout();
          var props = this.props,
            coord = this.coord;
          return jsx(View, _objectSpread(_objectSpread({
            nodes: nodes
          }, props), {}, {
            coord: coord.getCoord()
          }));
        }
      }]);
      return Treemap;
    }(Component);
  };

  var TreemapView = (function (props // Coord  withTreemap  Coord 
  ) {
    var nodes = props.nodes,
      coord = props.coord,
      onClick = props.onClick,
      _props$label = props.label,
      label = _props$label === void 0 ? false : _props$label;
    if (coord.isPolar) {
      var center = coord.center;
      var x = center.x,
        y = center.y;
      return jsx("group", null, nodes.map(function (node) {
        var xMin = node.xMin,
          xMax = node.xMax,
          yMin = node.yMin,
          yMax = node.yMax,
          color = node.color;
        return jsx("sector", {
          style: {
            cx: x,
            cy: y,
            lineWidth: '1px',
            stroke: '#fff',
            startAngle: xMin,
            endAngle: xMax,
            r0: yMin,
            r: yMax,
            fill: color
          },
          onClick: onClick ? function () {
            return onClick(node);
          } : null
        });
      }));
    }
    return jsx("group", null, nodes.map(function (node) {
      var key = node.key,
        xMin = node.xMin,
        xMax = node.xMax,
        yMin = node.yMin,
        yMax = node.yMax,
        color = node.color;
      return jsx("group", null, jsx("rect", {
        key: key,
        style: {
          x: xMin,
          y: yMin,
          width: xMax - xMin,
          height: yMax - yMin,
          fill: color,
          lineWidth: '4px',
          stroke: '#fff',
          radius: '8px'
        },
        animation: {
          appear: {
            easing: 'linear',
            duration: 450,
            property: ['fillOpacity', 'strokeOpacity'],
            start: {
              fillOpacity: 0,
              strokeOpacity: 0
            },
            end: {
              fillOpacity: 1,
              strokeOpacity: 1
            }
          },
          update: {
            easing: 'linear',
            duration: 450,
            property: ['x', 'y', 'width', 'height', 'radius', 'lineWidth']
          }
        },
        onClick: onClick ? function () {
          return onClick(node);
        } : null
      }), label && jsx("text", {
        style: _objectSpread({
          x: (xMin + xMax) / 2,
          y: (yMin + yMax) / 2,
          text: node.origin.name,
          fill: 'white',
          textAlign: 'center',
          textBaseline: 'middle'
        }, label)
      }));
    }));
  });

  var index$8 = withTreemap(TreemapView);

  function rootParent(data) {
    var d = data;
    while (d.depth > 1) {
      d = d.parent;
    }
    return d;
  }
  var withSunburst = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Sunburst, _Component);
      var _super = _createSuper(Sunburst);
      function Sunburst(props, context) {
        var _this;
        _classCallCheck(this, Sunburst);
        _this = _super.call(this, props, context);
        var color = props.color,
          data = props.data;
        _this.coord = new coordController();
        _this.color = new Category$1(_objectSpread(_objectSpread({
          range: Theme.colors
        }, color), {}, {
          data: data
        }));
        return _this;
      }
      _createClass$2(Sunburst, [{
        key: "willMount",
        value: function willMount() {
          var props = this.props,
            coord = this.coord,
            layout = this.layout;
          var coordOption = props.coord;
          coord.updateLayout(layout);
          coord.create(coordOption);
        }
      }, {
        key: "didMount",
        value: function didMount() {}
      }, {
        key: "_mapping",
        value: function _mapping(children) {
          var colorAttr = this.color,
            coord = this.coord;
          for (var i = 0, len = children.length; i < len; i++) {
            var node = children[i];
            var root = rootParent(node);
            var color = colorAttr.mapping(root.data[colorAttr.field]);
            node.color = color;
            var x0 = node.x0,
              x1 = node.x1,
              y0 = node.y0,
              y1 = node.y1;
            var rect = coord.getCoord().convertRect({
              x: [x0, x1],
              y: [y0, y1]
            });
            mix(node, rect);
            // 
            if (node.children && node.children.length) {
              this._mapping(node.children);
            }
          }
        }
      }, {
        key: "sunburst",
        value: function sunburst() {
          var props = this.props;
          var data = props.data,
            value = props.value,
            _props$sort = props.sort,
            sort = _props$sort === void 0 ? true : _props$sort;
          var root = hierarchy({
            children: data
          }).sum(function (d) {
            return d[value];
          });
          // valuesort
          if (sort === true || isFunction(sort)) {
            var sortFn = isFunction(sort) ? sort : function (a, b) {
              return b[value] - a[value];
            };
            root.sort(sortFn);
          }
          var nodes = partition()(root);
          var children = nodes.children;
          this._mapping(children);
          return nodes;
        }
      }, {
        key: "render",
        value: function render() {
          var node = this.sunburst();
          var coord = this.coord,
            props = this.props;
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            coord: coord.getCoord(),
            node: node,
            triggerRef: this.triggerRef
          }));
        }
      }]);
      return Sunburst;
    }(Component);
  });

  var SunburstView = (function (props) {
    var coord = props.coord,
      node = props.node,
      onClick = props.onClick;
    var children = node.children;
    var _coord$center = coord.center,
      x = _coord$center.x,
      y = _coord$center.y;
    var renderNodes = function renderNodes(nodes) {
      return jsx("group", null, nodes.map(function (node) {
        var xMin = node.xMin,
          xMax = node.xMax,
          yMin = node.yMin,
          yMax = node.yMax,
          color = node.color,
          children = node.children;
        return jsx("group", {
          onClick: onClick
        }, jsx("sector", {
          attrs: {
            cx: x,
            cy: y,
            lineWidth: '1px',
            stroke: '#fff',
            startAngle: "".concat(xMin, " rad"),
            endAngle: "".concat(xMax, " rad"),
            r0: yMin,
            r: yMax,
            fill: color
          }
        }), children && children.length ? renderNodes(children) : null);
      }));
    };
    return renderNodes(children);
  });

  var IcicleView = (function (props) {
    var node = props.node,
      onClick = props.onClick;
    var children = node.children;
    var renderNodes = function renderNodes(nodes) {
      return jsx("group", null, nodes.map(function (node) {
        var xMin = node.xMin,
          xMax = node.xMax,
          yMin = node.yMin,
          yMax = node.yMax,
          color = node.color,
          children = node.children;
        return jsx("group", {
          onClick: onClick
        }, jsx("rect", {
          attrs: {
            x: xMin,
            y: yMin,
            width: xMax - xMin,
            height: yMax - yMin,
            lineWidth: '1px',
            stroke: '#fff',
            fill: color
          }
        }), children && children.length ? renderNodes(children) : null);
      }));
    };
    return renderNodes(children);
  });

  var View = (function (props) {
    var coord = props.coord;
    if (coord.type === 'polar') {
      return jsx(SunburstView, _objectSpread({}, props));
    }
    return jsx(IcicleView, _objectSpread({}, props));
  });

  var index$9 = withSunburst(View);

  var DEFAULT_CONFIG = {
    anchorOffset: '10px',
    inflectionOffset: '30px',
    sidePadding: '15px',
    height: '64px',
    adjustOffset: '30',
    triggerOn: 'click',
    // activeShape: false, // 
    // activeStyle: {
    //   offset: '1px',
    //   appendRadius: '8px',
    //   fillOpacity: 0.5,
    // },
    label1OffsetY: '-4px',
    label2OffsetY: '4px'
  };
  function getEndPoint(center, angle, r) {
    return {
      x: center.x + r * Math.cos(angle),
      y: center.y + r * Math.sin(angle)
    };
  }
  // 
  function getMiddleAngle(startAngle, endAngle) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
    return (endAngle + startAngle) / 2;
  }
  function move(from, to, count, center) {
    var x = center.x;
    var sort = from.sort(function (a, b) {
      var aDistance = Math.abs(a.x - x);
      var bDistance = Math.abs(b.x - x);
      return bDistance - aDistance;
    });
    return [sort.slice(0, sort.length - count), sort.slice(sort.length - count).concat(to)];
  }
  // 
  function isFirstQuadrant(angle) {
    return angle >= -Math.PI / 2 && angle < 0;
  }
  // 
  function isSecondQuadrant(angle) {
    return angle >= 0 && angle < Math.PI / 2;
  }
  function isThirdQuadrant(angle) {
    return angle >= Math.PI / 2 && angle < Math.PI;
  }
  function isFourthQuadrant(angle) {
    return angle >= Math.PI && angle < Math.PI * 3 / 2;
  }
  var withPieLabel = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(PieLabel, _Component);
      var _super = _createSuper(PieLabel);
      function PieLabel(props) {
        _classCallCheck(this, PieLabel);
        return _super.call(this, props);
      }
      _createClass$2(PieLabel, [{
        key: "willMount",
        value: function willMount() {}
        /**
         * 
         */
      }, {
        key: "didMount",
        value: function didMount() {}
      }, {
        key: "getLabels",
        value: function getLabels(props) {
          var chart = props.chart,
            coord = props.coord,
            anchorOffset = props.anchorOffset,
            inflectionOffset = props.inflectionOffset,
            label1 = props.label1,
            label2 = props.label2,
            itemHeight = props.height,
            sidePadding = props.sidePadding;
          var center = coord.center,
            radius = coord.radius,
            coordWidth = coord.width,
            coordHeight = coord.height,
            coordLeft = coord.left,
            coordRight = coord.right,
            coordTop = coord.top;
          var maxCountForOneSide = Math.floor(coordHeight / itemHeight);
          var maxCount = maxCountForOneSide * 2;
          var geometry = chart.getGeometrys()[0];
          var records = geometry.flatRecords()
          // 
          .sort(function (a, b) {
            var angle1 = a.xMax - a.xMin;
            var angle2 = b.xMax - b.xMin;
            return angle2 - angle1;
          })
          //  maxCount 
          .slice(0, maxCount);
          //  labels
          var halves = [[], [] // right
          ];

          records.forEach(function (record) {
            var xMin = record.xMin,
              xMax = record.xMax,
              color = record.color,
              origin = record.origin;
            // 
            var anchorAngle = getMiddleAngle(xMin, xMax);
            // 
            var anchorPoint = getEndPoint(center, anchorAngle, radius + anchorOffset);
            // 
            var inflectionPoint = getEndPoint(center, anchorAngle, radius + inflectionOffset);
            // 
            var side = anchorPoint.x < center.x ? 'left' : 'right';
            var label = {
              origin: origin,
              angle: anchorAngle,
              anchor: anchorPoint,
              inflection: inflectionPoint,
              side: side,
              x: inflectionPoint.x,
              y: inflectionPoint.y,
              r: radius + inflectionOffset,
              color: color,
              label1: isFunction(label1) ? label1(origin, record) : label1,
              label2: isFunction(label2) ? label2(origin, record) : label2
            };
            // 
            if (side === 'left') {
              halves[0].push(label);
            } else {
              halves[1].push(label);
            }
          });
          // 
          if (halves[0].length > maxCountForOneSide) {
            halves = move(halves[0], halves[1], halves[0].length - maxCountForOneSide, center);
          } else if (halves[1].length > maxCountForOneSide) {
            var _move = move(halves[1], halves[0], halves[1].length - maxCountForOneSide, center),
              _move2 = _slicedToArray(_move, 2),
              right = _move2[0],
              left = _move2[1];
            halves = [left, right];
          }
          // label 
          var labelWidth = coordWidth / 2 - radius - anchorOffset - inflectionOffset - 2 * sidePadding;
          var labels = [];
          halves.forEach(function (half, index) {
            var showSide = index === 0 ? 'left' : 'right';
            // 
            half.sort(function (a, b) {
              var aAngle = a.angle;
              var bAngle = b.angle;
              if (showSide === 'left') {
                // 
                aAngle = isFirstQuadrant(aAngle) ? aAngle + Math.PI * 2 : aAngle;
                bAngle = isFirstQuadrant(bAngle) ? bAngle + Math.PI * 2 : bAngle;
                return bAngle - aAngle;
              } else {
                // 
                aAngle = isFourthQuadrant(aAngle) ? aAngle - Math.PI * 2 : aAngle;
                bAngle = isFourthQuadrant(bAngle) ? bAngle - Math.PI * 2 : bAngle;
                return aAngle - bAngle;
              }
            });
            var pointsY = half.map(function (label) {
              return label.y;
            });
            var maxY = Math.max.apply(null, pointsY);
            var minY = Math.min.apply(null, pointsY);
            //  label 
            var labelCount = half.length;
            var labelHeight = coordHeight / labelCount;
            var halfLabelHeight = labelHeight / 2;
            // 
            var lineInterval = 2;
            if (showSide === 'left') {
              half.forEach(function (label, index) {
                var anchor = label.anchor,
                  inflection = label.inflection,
                  angle = label.angle,
                  x = label.x,
                  y = label.y;
                var points = [anchor, inflection];
                var endX = coordLeft + sidePadding;
                var endY = coordTop + halfLabelHeight + labelHeight * index;
                // 
                var labelStart = {
                  x: endX + labelWidth + lineInterval * index,
                  y: endY
                };
                // 
                var labelEnd = {
                  x: endX,
                  y: endY
                };
                // 
                if (isFirstQuadrant(angle)) {
                  var pointY = minY - lineInterval * (labelCount - index);
                  points.push({
                    x: x,
                    y: pointY
                  });
                  points.push({
                    x: labelStart.x,
                    y: pointY
                  });
                } else if (isThirdQuadrant(angle) || isFourthQuadrant(angle)) {
                  points.push({
                    x: labelStart.x,
                    y: y
                  });
                } else if (isSecondQuadrant(angle)) {
                  var _pointY = maxY + lineInterval * index;
                  points.push({
                    x: x,
                    y: _pointY
                  });
                  points.push({
                    x: labelStart.x,
                    y: _pointY
                  });
                }
                points.push(labelStart);
                points.push(labelEnd);
                label.points = points;
                label.side = showSide;
                labels.push(label);
              });
            } else {
              half.forEach(function (label, index) {
                var anchor = label.anchor,
                  inflection = label.inflection,
                  angle = label.angle,
                  x = label.x,
                  y = label.y;
                // 
                var points = [anchor, inflection];
                var endX = coordRight - sidePadding;
                var endY = coordTop + halfLabelHeight + labelHeight * index;
                // 
                var labelStart = {
                  x: endX - labelWidth - lineInterval * index,
                  y: endY
                };
                // 
                var labelEnd = {
                  x: endX,
                  y: endY
                };
                // 
                if (isFourthQuadrant(angle)) {
                  var pointY = minY - lineInterval * (labelCount - index);
                  points.push({
                    x: x,
                    y: pointY
                  });
                  points.push({
                    x: labelStart.x,
                    y: pointY
                  });
                } else if (isFirstQuadrant(angle) || isSecondQuadrant(angle)) {
                  points.push({
                    x: labelStart.x,
                    y: y
                  });
                } else if (isThirdQuadrant(angle)) {
                  var _pointY2 = maxY + lineInterval * index;
                  points.push({
                    x: x,
                    y: _pointY2
                  });
                  points.push({
                    x: labelStart.x,
                    y: _pointY2
                  });
                }
                points.push(labelStart);
                points.push(labelEnd);
                label.points = points;
                label.side = showSide;
                labels.push(label);
              });
            }
          });
          return labels;
        }
      }, {
        key: "render",
        value: function render() {
          var context = this.context;
          var props = context.px2hd(deepMix({}, DEFAULT_CONFIG, this.props));
          var labels = this.getLabels(props);
          return jsx(View, _objectSpread({
            labels: labels
          }, props));
        }
      }]);
      return PieLabel;
    }(Component);
  });

  var PieLabelView = (function (props) {
    var lineStyle = props.lineStyle,
      anchorStyle = props.anchorStyle,
      labels = props.labels,
      label1OffsetY = props.label1OffsetY,
      label2OffsetY = props.label2OffsetY,
      triggerRef = props.triggerRef,
      onClick = props.onClick;
    return jsx("group", {
      ref: triggerRef
    }, labels.map(function (label) {
      var origin = label.origin,
        anchor = label.anchor,
        side = label.side,
        color = label.color,
        label1 = label.label1,
        label2 = label.label2,
        points = label.points;
      var end = points[points.length - 1];
      return jsx("group", {
        onClick: onClick
      }, jsx("circle", {
        attrs: _objectSpread({
          r: '4px',
          cx: anchor.x,
          cy: anchor.y,
          fill: color
        }, anchorStyle)
      }), jsx("polyline", {
        attrs: _objectSpread({
          points: points.map(function (d) {
            return [d.x, d.y];
          }),
          lineWidth: '2px',
          stroke: color
        }, lineStyle)
      }), jsx("text", {
        className: "click",
        attrs: _objectSpread({
          x: end.x,
          y: end.y + label1OffsetY,
          fontSize: '24px',
          lineHeight: '24px',
          fill: color,
          textBaseline: 'bottom',
          textAlign: side === 'left' ? 'left' : 'right'
        }, label1),
        data: origin
      }), jsx("text", {
        className: "click",
        attrs: _objectSpread({
          x: end.x,
          y: end.y + label2OffsetY,
          fontSize: '24px',
          lineHeight: '24px',
          fill: '#808080',
          textBaseline: 'top',
          textAlign: side === 'left' ? 'left' : 'right'
        }, label2),
        data: origin
      }));
    }));
  });

  var index$a = withPieLabel(PieLabelView);

  var getPoint$2 = function getPoint(cener, angle, r) {
    var x = cener.x + Math.cos(angle) * r;
    var y = cener.y + Math.sin(angle) * r;
    return {
      x: x,
      y: y
    };
  };
  var getTicks = function getTicks(start, end, tickCount, center, r, tickOffset, tickLength) {
    var ticks = [];
    var diff = end - start;
    for (var i = 0; i <= tickCount; i++) {
      var tickValue = start + diff * i / tickCount;
      var startPoint = getPoint$2(center, tickValue, r + tickOffset - tickLength);
      var endPoint = getPoint$2(center, tickValue, r + tickOffset);
      ticks.push({
        tickValue: tickValue,
        start: startPoint,
        end: endPoint
      });
    }
    return ticks;
  };
  var withGauge = function withGauge(View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Gauge, _Component);
      var _super = _createSuper(Gauge);
      function Gauge() {
        _classCallCheck(this, Gauge);
        return _super.apply(this, arguments);
      }
      _createClass$2(Gauge, [{
        key: "render",
        value: function render() {
          var props = this.props,
            context = this.context;
          var startAngle = props.startAngle,
            endAngle = props.endAngle,
            tickCount = props.tickCount,
            center = props.center,
            r = props.r,
            tickOffset = props.tickOffset,
            tickLength = props.tickLength;
          var ticks = getTicks(startAngle, endAngle, tickCount, center, context.px2hd(r), context.px2hd(tickOffset), context.px2hd(tickLength));
          return jsx(View, _objectSpread(_objectSpread({}, props), {}, {
            ticks: ticks
          }));
        }
      }]);
      return Gauge;
    }(Component);
  };

  var GaugeView = (function (props) {
    var center = props.center,
      startAngle = props.startAngle,
      endAngle = props.endAngle,
      r = props.r,
      percent = props.percent,
      ticks = props.ticks;
    var x = center.x,
      y = center.y;
    var diff = endAngle - startAngle;
    return jsx("group", null, jsx("arc", {
      attrs: {
        cx: x,
        cy: y,
        r: r,
        startAngle: "".concat(startAngle, " rad"),
        endAngle: "".concat(endAngle, " rad"),
        lineWidth: '20px',
        lineCap: 'round',
        stroke: '#e7e7e7'
      }
    }), jsx("arc", {
      attrs: {
        cx: x,
        cy: y,
        r: r,
        startAngle: "".concat(startAngle, " rad"),
        endAngle: "".concat(startAngle, " rad"),
        lineWidth: '40px',
        lineCap: 'round',
        stroke: '#0075ff'
      },
      animation: {
        appear: {
          easing: 'linear',
          duration: 500,
          property: ['endAngle'],
          start: {
            endAngle: "".concat(startAngle, " rad")
          },
          end: {
            endAngle: "".concat(startAngle + diff * percent, " rad")
          }
        }
      }
    }), ticks.map(function (tick) {
      var start = tick.start,
        end = tick.end;
      return jsx("line", {
        attrs: {
          x1: start.x,
          y1: start.y,
          x2: end.x,
          y2: end.y,
          lineWidth: '6px',
          lineCap: 'round',
          stroke: '#e7e7e7'
        }
      });
    }));
  });

  var index$b = withGauge(GaugeView);

  // values
  function isValuesEqual(values, newValues) {
    if (values.length !== newValues.length) {
      return false;
    }
    var lastIndex = values.length - 1;
    return values[0] === newValues[0] && values[lastIndex] === newValues[lastIndex];
  }
  function updateCategoryRange(scale, originScale, range) {
    var currentValues = scale.values,
      currentTicks = scale.ticks,
      tickMethod = scale.tickMethod,
      tickCount = scale.tickCount;
    var originValues = originScale.values;
    var _range = _slicedToArray(range, 2),
      start = _range[0],
      end = _range[1];
    var len = originValues.length;
    var valueStart = start * len;
    var valueEnd = end * len;
    // 
    var count = Math.round(valueEnd - valueStart);
    var sliceSatrt = Math.round(valueStart);
    // 
    var newValues = originValues.slice(sliceSatrt, sliceSatrt + count);
    // tickCountticks
    var newTickCount = Math.round(tickCount * originValues.length / newValues.length);
    // ticks
    var catTicks = getTickMethod(tickMethod);
    var newTicks = catTicks({
      tickCount: newTickCount,
      values: originValues
    });
    // 
    if (isValuesEqual(currentValues, newValues) && isValuesEqual(currentTicks, newTicks)) {
      return;
    }
    scale.change({
      values: newValues,
      ticks: newTicks
    });
    return scale;
  }
  function updateLinearRange(scale, originScale, range) {
    var min = originScale.min,
      max = originScale.max;
    var _range2 = _slicedToArray(range, 2),
      start = _range2[0],
      end = _range2[1];
    var newMin = min + (max - min) * start;
    var newMax = min + (max - min) * end;
    scale.change({
      min: newMin,
      max: newMax,
      nice: false
    });
  }
  function updateScale(scale, values) {
    var isLinear = scale.isLinear;
    if (isLinear) {
      var _getRange = getRange(values),
        min = _getRange.min,
        max = _getRange.max;
      return scale.change({
        min: min,
        max: max,
        nice: true
      });
    }
  }
  function updateRange(scale, originScale, range) {
    var isCategory = scale.isCategory,
      isLinear = scale.isLinear;
    if (isCategory) {
      return updateCategoryRange(scale, originScale, range);
    }
    if (isLinear) {
      return updateLinearRange(scale, originScale, range);
    }
  }
  function updateFollow(scales, mainScale, data) {
    var mainField = mainScale.field,
      mainType = mainScale.type,
      mainValues = mainScale.values;
    //  map 
    var mainValuesMap = {};
    mainValues.forEach(function (item) {
      mainValuesMap[item] = true;
    });
    return scales.map(function (scale) {
      var followField = scale.field;
      var values = [];
      data.forEach(function (item) {
        var value = mainType === 'timeCat' ? toTimeStamp$1(item[mainField]) : item[mainField];
        if (mainValuesMap[value]) {
          values.push(item[followField]);
        }
      });
      return updateScale(scale, values);
    });
  }

  function lerp$1(min, max, fraction) {
    return (max - min) * fraction + min;
  }
  function isEqualRange(aRange, bRange) {
    for (var i in aRange) {
      if (!isNumberEqual(aRange[i], bRange[i])) return false;
    }
    return true;
  }
  function cloneScale$1(scale, scaleConfig) {
    // @ts-ignore
    return new scale.constructor(_objectSpread(_objectSpread({}, scale.__cfg__), scaleConfig));
  }
  var withZoom = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(Zoom, _Component);
      var _super = _createSuper(Zoom);
      function Zoom(props) {
        var _this;
        _classCallCheck(this, Zoom);
        var defaultProps = {
          onPanStart: function onPanStart() {},
          onPinchStart: function onPinchStart() {},
          onPan: function onPan() {},
          onPinch: function onPinch() {},
          onInit: function onInit() {},
          onPanEnd: function onPanEnd() {},
          onPinchEnd: function onPinchEnd() {},
          minCount: 10
        };
        _this = _super.call(this, _objectSpread(_objectSpread({}, defaultProps), props));
        _this.scale = {};
        _this.originScale = {};
        //swipe end x y
        _this.swipeEnd = {
          startX: 0,
          startY: 0,
          endX: 0,
          endY: 0
        };
        _this.onStart = function () {
          var _assertThisInitialize = _assertThisInitialized$2(_this),
            state = _assertThisInitialize.state;
          var range = state.range;
          _this.startRange = range;
          _this.loop && cancelAnimationFrame(_this.loop);
        };
        _this.onPan = function (ev) {
          var _assertThisInitialize2 = _assertThisInitialized$2(_this),
            dims = _assertThisInitialize2.dims;
          var range = {};
          each(dims, function (dim) {
            if (dim === 'x') {
              range['x'] = _this._doXPan(ev);
              return;
            }
            if (dim === 'y') {
              range['y'] = _this._doYPan(ev);
              return;
            }
          });
          if (isEqualRange(range, _this.state.range)) return;
          _this.setState({
            range: range
          });
        };
        _this.onSwipe = function (ev) {
          var swipe = _this.props.swipe;
          if (_this.props.mode.length < 2 || !swipe) return;
          var _ev$velocityX = ev.velocityX,
            velocityX = _ev$velocityX === void 0 ? 0 : _ev$velocityX,
            _ev$velocityY = ev.velocityY,
            velocityY = _ev$velocityY === void 0 ? 0 : _ev$velocityY,
            points = ev.points;
          var range = _this.state.range;
          var _points$ = points[0],
            x = _points$.x,
            y = _points$.y;
          // 
          if (Math.abs((range === null || range === void 0 ? void 0 : range.x[0]) - 0) < 0.0005 && velocityX > 0) return;
          if (Math.abs((range === null || range === void 0 ? void 0 : range.x[1]) - 1) < 0.0005 && velocityX < 0) return;
          if (Math.abs((range === null || range === void 0 ? void 0 : range.y[0]) - 0) < 0.0005 && velocityY < 0) return;
          if (Math.abs((range === null || range === void 0 ? void 0 : range.x[1]) - 1) < 0.0005 && velocityY > 0) return;
          _this.swipeEnd = {
            startX: x,
            startY: y,
            endX: x + velocityX * 50,
            endY: y - velocityY * 50
          };
          _this.onStart();
          _this.update();
        };
        _this.onPinch = function (ev) {
          var _assertThisInitialize3 = _assertThisInitialized$2(_this),
            dims = _assertThisInitialize3.dims;
          var range = {};
          each(dims, function (dim) {
            if (dim === 'x') {
              range['x'] = _this._doXPinch(ev);
              return;
            }
            if (dim === 'y') {
              range['y'] = _this._doYPinch(ev);
              return;
            }
          });
          if (isEqualRange(range, _this.state.range)) return;
          _this.setState({
            range: range
          });
        };
        _this.onEnd = function () {
          _this.startRange = null;
        };
        var mode = props.mode;
        _this.dims = isArray(mode) ? mode : [mode];
        return _this;
      }
      _createClass$2(Zoom, [{
        key: "didMount",
        value: function didMount() {
          var scale = this.scale;
          var onInit = this.props.onInit;
          onInit({
            scale: scale
          });
          this._bindEvents();
        }
      }, {
        key: "willReceiveProps",
        value: function willReceiveProps(nextProps) {
          var nextRange = nextProps.range;
          var lastRange = this.props.range;
          if (!equal(nextRange, lastRange)) {
            var cacheRange = {};
            each(this.dims, function (dim) {
              cacheRange[dim] = nextRange;
            });
            this.state = {
              range: cacheRange
            };
          }
        }
      }, {
        key: "willMount",
        value: function willMount() {
          var _this2 = this;
          var props = this.props,
            dims = this.dims;
          var minCount = props.minCount,
            range = props.range;
          var valueLength = Number.MIN_VALUE;
          var cacheRange = {};
          each(dims, function (dim) {
            var scale = _this2._getScale(dim);
            var values = scale.values;
            valueLength = values.length > valueLength ? values.length : valueLength;
            _this2.scale[dim] = scale;
            _this2.originScale[dim] = cloneScale$1(scale);
            _this2.updateRange(range, dim);
            cacheRange[dim] = range;
          });
          //  MIN_COUNT 
          this.minScale = minCount / valueLength;
          this.state = {
            range: cacheRange
          };
        }
      }, {
        key: "didUnmount",
        value: function didUnmount() {
          this.loop && cancelAnimationFrame(this.loop);
        }
      }, {
        key: "_bindEvents",
        value: function _bindEvents() {
          var _this3 = this;
          var scale = this.scale;
          var _this$props = this.props,
            chart = _this$props.chart,
            onPinchStart = _this$props.onPinchStart,
            onPanStart = _this$props.onPanStart,
            onPanEnd = _this$props.onPanEnd,
            pan = _this$props.pan,
            pinch = _this$props.pinch,
            swipe = _this$props.swipe,
            onPan = _this$props.onPan,
            onPinch = _this$props.onPinch,
            onPinchEnd = _this$props.onPinchEnd;
          // 
          if (pan !== false) {
            chart.on('panstart', function () {
              _this3.onStart();
              onPanStart({
                scale: scale
              });
            });
            chart.on('pan', function (ev) {
              _this3.onPan(ev);
              onPan(ev);
            });
            chart.on('panend', function () {
              _this3.onEnd();
              onPanEnd({
                scale: scale
              });
            });
          }
          if (pinch !== false) {
            chart.on('pinchstart', function () {
              _this3.onStart();
              onPinchStart();
            });
            chart.on('pinch', function (ev) {
              _this3.onPinch(ev);
              onPinch(ev);
            });
            chart.on('pinchend', function () {
              _this3.onEnd();
              onPinchEnd({
                scale: scale
              });
            });
          }
          if (swipe !== false) {
            chart.on('swipe', this.onSwipe);
          }
        }
      }, {
        key: "update",
        value: function update() {
          var _this4 = this;
          var _this$swipeEnd = this.swipeEnd,
            startX = _this$swipeEnd.startX,
            startY = _this$swipeEnd.startY,
            endX = _this$swipeEnd.endX,
            endY = _this$swipeEnd.endY;
          var x = lerp$1(startX, endX, 0.05);
          var y = lerp$1(startY, endY, 0.05);
          this.swipeEnd = {
            startX: x,
            startY: y,
            endX: endX,
            endY: endY
          };
          var props = this.props;
          var coord = props.coord;
          var coordWidth = coord.width,
            coordHeight = coord.height;
          var range = {};
          range['x'] = this._doPan((x - startX) / coordWidth, 'x');
          range['y'] = this._doPan((y - startY) / coordHeight, 'y');
          this.setState({
            range: range
          });
          this.startRange = range;
          this.loop = requestAnimationFrame(function () {
            return _this4.update();
          });
          if (Math.abs(x - endX) < 0.0005 && Math.abs(y - endY) < 0.0005) {
            this.onEnd();
            cancelAnimationFrame(this.loop);
          }
        }
      }, {
        key: "_doXPan",
        value: function _doXPan(ev) {
          var direction = ev.direction,
            deltaX = ev.deltaX;
          if (this.props.mode.length === 1 && (direction === 'up' || direction === 'down')) {
            return this.state.range['x'];
          }
          ev.preventDefault && ev.preventDefault();
          var props = this.props;
          var coord = props.coord,
            _props$panSensitive = props.panSensitive,
            panSensitive = _props$panSensitive === void 0 ? 1 : _props$panSensitive;
          var coordWidth = coord.width;
          var ratio = deltaX / coordWidth * panSensitive;
          var newRange = this._doPan(ratio, 'x');
          return newRange;
        }
      }, {
        key: "_doYPan",
        value: function _doYPan(ev) {
          var direction = ev.direction,
            deltaY = ev.deltaY;
          if (this.props.mode.length === 1 && (direction === 'left' || direction === 'right')) {
            return this.state.range['y'];
          }
          ev.preventDefault && ev.preventDefault();
          var props = this.props;
          var coord = props.coord,
            _props$panSensitive2 = props.panSensitive,
            panSensitive = _props$panSensitive2 === void 0 ? 1 : _props$panSensitive2;
          var coordHeight = coord.height;
          var ratio = -deltaY / coordHeight * panSensitive;
          var newRange = this._doPan(ratio, 'y');
          return newRange;
        }
      }, {
        key: "_doPan",
        value: function _doPan(ratio, dim) {
          var startRange = this.startRange;
          var _startRange$dim = _slicedToArray(startRange[dim], 2),
            start = _startRange$dim[0],
            end = _startRange$dim[1];
          var rangeLen = end - start;
          var rangeOffset = rangeLen * ratio;
          var newStart = start - rangeOffset;
          var newEnd = end - rangeOffset;
          var newRange = this.updateRange([newStart, newEnd], dim);
          return newRange;
        }
      }, {
        key: "_doXPinch",
        value: function _doXPinch(ev) {
          ev.preventDefault && ev.preventDefault();
          var zoom = ev.zoom,
            center = ev.center;
          var props = this.props;
          var coord = props.coord;
          var coordWidth = coord.width,
            left = coord.left,
            right = coord.right;
          var leftLen = Math.abs(center.x - left);
          var rightLen = Math.abs(right - center.x);
          // 
          var leftZoom = leftLen / coordWidth;
          var rightZoom = rightLen / coordWidth;
          var newRange = this._doPinch(leftZoom, rightZoom, zoom, 'x');
          return newRange;
        }
      }, {
        key: "_doYPinch",
        value: function _doYPinch(ev) {
          ev.preventDefault && ev.preventDefault();
          var zoom = ev.zoom,
            center = ev.center;
          var props = this.props;
          var coord = props.coord;
          var coordHeight = coord.height,
            top = coord.top,
            bottom = coord.bottom;
          var topLen = Math.abs(center.y - top);
          var bottomLen = Math.abs(bottom - center.y);
          // 
          var topZoom = topLen / coordHeight;
          var bottomZoom = bottomLen / coordHeight;
          var newRange = this._doPinch(topZoom, bottomZoom, zoom, 'y');
          return newRange;
        }
      }, {
        key: "_doPinch",
        value: function _doPinch(startRatio, endRatio, zoom, dim) {
          var startRange = this.startRange,
            minScale = this.minScale,
            props = this.props;
          var _props$pinchSensitive = props.pinchSensitive,
            pinchSensitive = _props$pinchSensitive === void 0 ? 1 : _props$pinchSensitive;
          var _startRange$dim2 = _slicedToArray(startRange[dim], 2),
            start = _startRange$dim2[0],
            end = _startRange$dim2[1];
          var zoomOffset = zoom < 1 ? (1 / zoom - 1) * pinchSensitive : (1 - zoom) * pinchSensitive;
          var rangeLen = end - start;
          var rangeOffset = rangeLen * zoomOffset;
          var startOffset = rangeOffset * startRatio;
          var endOffset = rangeOffset * endRatio;
          var newStart = Math.max(0, start - startOffset);
          var newEnd = Math.min(1, end + endOffset);
          var newRange = [newStart, newEnd];
          // 
          if (newEnd - newStart < minScale) {
            return this.state.range[dim];
          }
          return this.updateRange(newRange, dim);
        }
      }, {
        key: "updateRange",
        value: function updateRange$1(originalRange, dim) {
          if (!originalRange) return;
          var _originalRange = _slicedToArray(originalRange, 2),
            start = _originalRange[0],
            end = _originalRange[1];
          var rangeLength = end - start;
          // 
          var newRange;
          if (start < 0) {
            newRange = [0, rangeLength];
          } else if (end > 1) {
            newRange = [1 - rangeLength, 1];
          } else {
            newRange = originalRange;
          }
          var props = this.props,
            scale = this.scale,
            originScale = this.originScale,
            state = this.state;
          var chart = props.chart,
            data = props.data,
            autoFit = props.autoFit;
          var range = state.range;
          if (range && isEqualRange(newRange, range[dim])) return newRange;
          //  scale
          updateRange(scale[dim], originScale[dim], newRange);
          if (autoFit) {
            var followScale = this._getFollowScales(dim);
            this.updateFollow(followScale, scale[dim], data);
          }
          // 
          var animate = chart.animate;
          chart.setAnimate(false);
          chart.forceUpdate(function () {
            chart.setAnimate(animate);
          });
          return newRange;
        }
      }, {
        key: "updateFollow",
        value: function updateFollow$1(scales, mainScale, data) {
          updateFollow(scales, mainScale, data);
        }
      }, {
        key: "_getScale",
        value: function _getScale(dim) {
          var _this$props2 = this.props,
            coord = _this$props2.coord,
            chart = _this$props2.chart;
          if (dim === 'x') {
            return coord.transposed ? chart.getYScales()[0] : chart.getXScales()[0];
          } else {
            return coord.transposed ? chart.getXScales()[0] : chart.getYScales()[0];
          }
        }
      }, {
        key: "_getFollowScales",
        value: function _getFollowScales(dim) {
          var _this$props3 = this.props,
            coord = _this$props3.coord,
            chart = _this$props3.chart;
          if (dim === 'x') {
            return coord.transposed ? chart.getXScales() : chart.getYScales();
          }
          if (dim === 'y') {
            return coord.transposed ? chart.getYScales() : chart.getXScales();
          }
        }
      }, {
        key: "render",
        value: function render() {
          return jsx(View, _objectSpread(_objectSpread({}, this.props), this.state));
        }
      }]);
      return Zoom;
    }(Component);
  });

  var withScrollBar = (function (View) {
    return /*#__PURE__*/function (_Component) {
      _inherits(ScrollBar, _Component);
      var _super = _createSuper(ScrollBar);
      function ScrollBar() {
        _classCallCheck(this, ScrollBar);
        return _super.apply(this, arguments);
      }
      _createClass$2(ScrollBar, [{
        key: "willMount",
        value: function willMount() {
          _get(_getPrototypeOf(ScrollBar.prototype), "willMount", this).call(this);
          var context = this.context,
            props = this.props;
          var visible = props.visible,
            _props$position = props.position,
            position = _props$position === void 0 ? 'bottom' : _props$position,
            _props$margin = props.margin,
            margin = _props$margin === void 0 ? '16px' : _props$margin,
            chart = props.chart;
          var marginNumber = context.px2hd(margin);
          if (visible === false) {
            return null;
          }
          chart.updateCoordFor(this, {
            position: position,
            width: position === 'left' || position === 'right' ? marginNumber : 0,
            height: position === 'bottom' || position === 'top' ? marginNumber : 0
          });
        }
      }, {
        key: "render",
        value: function render() {
          var props = this.props,
            state = this.state;
          var visible = props.visible;
          if (visible === false) {
            return null;
          }
          return jsx(View, _objectSpread(_objectSpread({
            position: "bottom"
          }, props), state));
        }
      }]);
      return ScrollBar;
    }(Component);
  });

  var Horizontal = (function (props, context) {
    var coord = props.coord,
      range = props.range,
      position = props.position,
      layout = props.layout;
    var left = coord.left,
      width = coord.width;
    var top = layout.top,
      height = layout.height;
    var _ref = (range === null || range === void 0 ? void 0 : range.x) || (range === null || range === void 0 ? void 0 : range.y),
      _ref2 = _slicedToArray(_ref, 2),
      start = _ref2[0],
      end = _ref2[1];
    var barLeft = width * start;
    var barWidth = width * (end - start);
    if (isNaN(barWidth)) return;
    return jsx("group", {
      style: {
        display: 'flex',
        left: left,
        top: position === 'top' ? top - context.px2hd('8px') : top + height
      }
    }, jsx("line", {
      style: {
        display: 'flex',
        position: 'absolute',
        left: 0,
        width: width,
        height: 0,
        stroke: 'rgba(202, 215, 239, .2)',
        lineCap: 'round',
        lineWidth: '8px'
      }
    }), jsx("line", {
      style: {
        display: 'flex',
        position: 'absolute',
        left: barLeft,
        width: barWidth,
        height: 0,
        stroke: 'rgba(202, 215, 239, .5)',
        lineCap: 'round',
        lineWidth: '8px'
      }
    }));
  });

  var Vertical = (function (props, context) {
    var coord = props.coord,
      range = props.range,
      position = props.position,
      layout = props.layout;
    var top = coord.top,
      height = coord.height;
    var left = layout.left,
      width = layout.width;
    var _ref = (range === null || range === void 0 ? void 0 : range.y) || (range === null || range === void 0 ? void 0 : range.x),
      _ref2 = _slicedToArray(_ref, 2),
      start = _ref2[0],
      end = _ref2[1];
    var barTop = height * start;
    var barHeight = height * (end - start);
    return jsx("group", {
      style: {
        display: 'flex',
        top: top,
        left: position === 'left' ? left - context.px2hd('8px') : left + width
      }
    }, jsx("line", {
      style: {
        position: 'absolute',
        top: 0,
        left: 0,
        width: 0,
        height: height,
        stroke: 'rgba(202, 215, 239, .2)',
        lineCap: 'round',
        lineWidth: '8px'
      }
    }), jsx("line", {
      style: {
        position: 'absolute',
        top: barTop,
        width: 0,
        height: barHeight,
        stroke: 'rgba(202, 215, 239, .5)',
        lineCap: 'round',
        lineWidth: '8px'
      }
    }));
  });

  var ScrollBarView = (function (props) {
    var position = props.position,
      mode = props.mode;
    if (mode.length > 1) {
      return jsx("group", null, jsx(Vertical, _objectSpread({}, props)), jsx(Horizontal, _objectSpread({}, props)));
    }
    if (position === 'left' || position === 'right') {
      return jsx(Vertical, _objectSpread({}, props));
    }
    return jsx(Horizontal, _objectSpread({}, props));
  });

  var index$c = withZoom(withScrollBar(ScrollBarView));

  exports.ArcGuide = ArcGuide;
  exports.Area = index$1;
  exports.AreaView = AreaView;
  exports.Axis = index$4;
  exports.AxisView = AxisView;
  exports.Canvas = Canvas$1;
  exports.CanvasRenderer = Renderer;
  exports.Chart = Chart;
  exports.Children = Children;
  exports.Component = Component;
  exports.Fragment = fragment;
  exports.Gauge = index$b;
  exports.GaugeView = GaugeView;
  exports.Geometry = Geometry;
  exports.Gesture = Gesture$1;
  exports.Guide = index$6;
  exports.ImageGuide = ImageGuide;
  exports.Interval = index$2;
  exports.IntervalView = intervalView;
  exports.Legend = index$5;
  exports.LegendView = LegendView;
  exports.Line = index;
  exports.LineGuide = LineGuide;
  exports.LineView = LineView;
  exports.LottieGuide = LottieGuide;
  exports.PieLabel = index$a;
  exports.PieLabelView = PieLabelView;
  exports.Point = index$3;
  exports.PointGuide = PointGuide;
  exports.PointView = PointView;
  exports.RectGuide = RectGuide;
  exports.Scale = Scale;
  exports.ScrollBar = index$c;
  exports.ScrollBarView = ScrollBarView;
  exports.Smooth = smooth;
  exports.Sunburst = index$9;
  exports.SunburstView = SunburstView;
  exports.TagGuide = TagGuide;
  exports.TextGuide = TextGuide;
  exports.Timeline = Timeline;
  exports.Tooltip = index$7;
  exports.TooltipView = TooltipView;
  exports.Treemap = index$8;
  exports.TreemapView = TreemapView;
  exports.Zoom = withZoom;
  exports.computeLayout = computeLayout$1;
  exports.createElement = jsx;
  exports.createRef = createRef;
  exports.isEqual = equal;
  exports.jsx = jsx;
  exports.registerTag = registerTag;
  exports.withArea = withArea;
  exports.withAxis = withAxis;
  exports.withGauge = withGauge;
  exports.withGuide = withGuide;
  exports.withInterval = withInterval;
  exports.withLegend = withLegend;
  exports.withLine = withLine;
  exports.withPieLabel = withPieLabel;
  exports.withPoint = withPoint;
  exports.withScrollBar = withScrollBar;
  exports.withSunburst = withSunburst;
  exports.withTooltip = withTooltip;
  exports.withTreemap = withTreemap;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
